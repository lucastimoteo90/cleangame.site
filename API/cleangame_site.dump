--
-- PostgreSQL database dump
--

-- Dumped from database version 10.10 (Ubuntu 10.10-0ubuntu0.18.04.1)
-- Dumped by pg_dump version 10.10 (Ubuntu 10.10-0ubuntu0.18.04.1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: answer; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.answer (
    id integer NOT NULL,
    alternative integer,
    correct boolean,
    endtime timestamp without time zone,
    score integer,
    skip boolean,
    start timestamp without time zone,
    tip1 boolean,
    tip2 boolean,
    tip3 boolean,
    tips integer,
    question_id integer,
    team_id integer,
    user_id integer
);


ALTER TABLE public.answer OWNER TO postgres;

--
-- Name: answer_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.answer_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.answer_id_seq OWNER TO postgres;

--
-- Name: answer_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.answer_id_seq OWNED BY public.answer.id;


--
-- Name: bad_smell; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.bad_smell (
    id integer NOT NULL,
    description character varying(255),
    name character varying(255)
);


ALTER TABLE public.bad_smell OWNER TO postgres;

--
-- Name: bad_smell_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.bad_smell_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bad_smell_id_seq OWNER TO postgres;

--
-- Name: bad_smell_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.bad_smell_id_seq OWNED BY public.bad_smell.id;


--
-- Name: battle; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.battle (
    id integer NOT NULL,
    attack_id integer,
    room_id integer,
    team1_id integer,
    team2_id integer
);


ALTER TABLE public.battle OWNER TO postgres;

--
-- Name: battle_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.battle_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.battle_id_seq OWNER TO postgres;

--
-- Name: battle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.battle_id_seq OWNED BY public.battle.id;


--
-- Name: code_bad_smell; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_bad_smell (
    id integer NOT NULL,
    endline integer,
    startline integer,
    badsmell_id integer,
    hard_question_id integer
);


ALTER TABLE public.code_bad_smell OWNER TO postgres;

--
-- Name: code_bad_smell_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_bad_smell_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_bad_smell_id_seq OWNER TO postgres;

--
-- Name: code_bad_smell_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.code_bad_smell_id_seq OWNED BY public.code_bad_smell.id;


--
-- Name: easy_question; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.easy_question (
    level integer,
    id integer NOT NULL
);


ALTER TABLE public.easy_question OWNER TO postgres;

--
-- Name: easy_room; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.easy_room (
    id integer NOT NULL
);


ALTER TABLE public.easy_room OWNER TO postgres;

--
-- Name: hard_question; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.hard_question (
    id integer NOT NULL
);


ALTER TABLE public.hard_question OWNER TO postgres;

--
-- Name: hard_room; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.hard_room (
    id integer NOT NULL
);


ALTER TABLE public.hard_room OWNER TO postgres;

--
-- Name: medium_room; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.medium_room (
    clone_status character varying(255),
    git character varying(255),
    make_question_status character varying(255),
    pmd_status character varying(255),
    id integer NOT NULL
);


ALTER TABLE public.medium_room OWNER TO postgres;

--
-- Name: pmderrors; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pmderrors (
    id integer NOT NULL,
    jpackage character varying(255),
    description character varying(255),
    file_dir character varying(255),
    line integer,
    priority integer,
    rule character varying(255),
    rule_set character varying(255),
    room_id integer
);


ALTER TABLE public.pmderrors OWNER TO postgres;

--
-- Name: pmderrors_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.pmderrors_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pmderrors_id_seq OWNER TO postgres;

--
-- Name: pmderrors_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.pmderrors_id_seq OWNED BY public.pmderrors.id;


--
-- Name: profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profiles (
    user_id integer NOT NULL,
    profiles integer
);


ALTER TABLE public.profiles OWNER TO postgres;

--
-- Name: question; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.question (
    id integer NOT NULL,
    ask character varying(255),
    code text,
    correct character varying(255),
    fake1 character varying(255),
    fake2 character varying(255),
    fake3 character varying(255),
    filename character varying(255),
    md5correct character varying(255),
    right_answer integer,
    tip character varying(255),
    tip2 character varying(255),
    tip3 character varying(255),
    valid boolean,
    room_id integer
);


ALTER TABLE public.question OWNER TO postgres;

--
-- Name: question_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.question_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.question_id_seq OWNER TO postgres;

--
-- Name: question_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.question_id_seq OWNED BY public.question.id;


--
-- Name: question_temp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.question_temp (
    id integer NOT NULL,
    ask character varying(255),
    code text,
    correct character varying(255),
    fake1 character varying(255),
    fake2 character varying(255),
    fake3 character varying(255),
    filename character varying(255),
    md5correct character varying(255),
    right_answer integer,
    tip character varying(255),
    tip2 character varying(255),
    tip3 character varying(255),
    valid boolean,
    question_id integer,
    room_id integer
);


ALTER TABLE public.question_temp OWNER TO postgres;

--
-- Name: question_temp_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.question_temp_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.question_temp_id_seq OWNER TO postgres;

--
-- Name: question_temp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.question_temp_id_seq OWNED BY public.question_temp.id;


--
-- Name: room; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.room (
    id integer NOT NULL,
    description character varying(255),
    git_url character varying(255),
    is_public boolean NOT NULL,
    name character varying(255),
    open boolean,
    total_participantes integer,
    type integer
);


ALTER TABLE public.room OWNER TO postgres;

--
-- Name: room_admin; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.room_admin (
    room_id integer NOT NULL,
    admin_id integer NOT NULL
);


ALTER TABLE public.room_admin OWNER TO postgres;

--
-- Name: room_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.room_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.room_id_seq OWNER TO postgres;

--
-- Name: room_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.room_id_seq OWNED BY public.room.id;


--
-- Name: room_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.room_member (
    room_id integer NOT NULL,
    member_id integer NOT NULL
);


ALTER TABLE public.room_member OWNER TO postgres;

--
-- Name: rooms_team; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rooms_team (
    team_id integer NOT NULL,
    room_id integer NOT NULL
);


ALTER TABLE public.rooms_team OWNER TO postgres;

--
-- Name: score; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.score (
    id integer NOT NULL,
    bonus double precision,
    bonus_consecutive integer,
    consecutive_hits integer,
    gettip boolean NOT NULL,
    panalites double precision,
    points double precision,
    score double precision,
    total_errors double precision,
    total_hits double precision,
    room_id integer,
    team_id integer,
    user_id integer
);


ALTER TABLE public.score OWNER TO postgres;

--
-- Name: score_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.score_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.score_id_seq OWNER TO postgres;

--
-- Name: score_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.score_id_seq OWNED BY public.score.id;


--
-- Name: team; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.team (
    id integer NOT NULL,
    name character varying(255)
);


ALTER TABLE public.team OWNER TO postgres;

--
-- Name: team_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.team_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.team_id_seq OWNER TO postgres;

--
-- Name: team_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.team_id_seq OWNED BY public.team.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id integer NOT NULL,
    mail character varying(255),
    name character varying(255),
    passwd character varying(255)
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_id_seq OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.users_id_seq OWNED BY public.users.id;


--
-- Name: users_team; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users_team (
    team_id integer NOT NULL,
    user_id integer NOT NULL
);


ALTER TABLE public.users_team OWNER TO postgres;

--
-- Name: answer id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer ALTER COLUMN id SET DEFAULT nextval('public.answer_id_seq'::regclass);


--
-- Name: bad_smell id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.bad_smell ALTER COLUMN id SET DEFAULT nextval('public.bad_smell_id_seq'::regclass);


--
-- Name: battle id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.battle ALTER COLUMN id SET DEFAULT nextval('public.battle_id_seq'::regclass);


--
-- Name: code_bad_smell id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_bad_smell ALTER COLUMN id SET DEFAULT nextval('public.code_bad_smell_id_seq'::regclass);


--
-- Name: pmderrors id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pmderrors ALTER COLUMN id SET DEFAULT nextval('public.pmderrors_id_seq'::regclass);


--
-- Name: question id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question ALTER COLUMN id SET DEFAULT nextval('public.question_id_seq'::regclass);


--
-- Name: question_temp id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question_temp ALTER COLUMN id SET DEFAULT nextval('public.question_temp_id_seq'::regclass);


--
-- Name: room id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.room ALTER COLUMN id SET DEFAULT nextval('public.room_id_seq'::regclass);


--
-- Name: score id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.score ALTER COLUMN id SET DEFAULT nextval('public.score_id_seq'::regclass);


--
-- Name: team id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.team ALTER COLUMN id SET DEFAULT nextval('public.team_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users ALTER COLUMN id SET DEFAULT nextval('public.users_id_seq'::regclass);


--
-- Data for Name: answer; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.answer (id, alternative, correct, endtime, score, skip, start, tip1, tip2, tip3, tips, question_id, team_id, user_id) FROM stdin;
\.


--
-- Data for Name: bad_smell; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.bad_smell (id, description, name) FROM stdin;
\.


--
-- Data for Name: battle; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.battle (id, attack_id, room_id, team1_id, team2_id) FROM stdin;
\.


--
-- Data for Name: code_bad_smell; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.code_bad_smell (id, endline, startline, badsmell_id, hard_question_id) FROM stdin;
\.


--
-- Data for Name: easy_question; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.easy_question (level, id) FROM stdin;
\.


--
-- Data for Name: easy_room; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.easy_room (id) FROM stdin;
1
\.


--
-- Data for Name: hard_question; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.hard_question (id) FROM stdin;
\.


--
-- Data for Name: hard_room; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.hard_room (id) FROM stdin;
\.


--
-- Data for Name: medium_room; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.medium_room (clone_status, git, make_question_status, pmd_status, id) FROM stdin;
EXECUTING	\N	Aguardando execução	Aguardando execução	2
EXECUTING	\N	Aguardando execução	Aguardando execução	3
\.


--
-- Data for Name: pmderrors; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.pmderrors (id, jpackage, description, file_dir, line, priority, rule, rule_set, room_id) FROM stdin;
\.


--
-- Data for Name: profiles; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.profiles (user_id, profiles) FROM stdin;
1	2
2	2
\.


--
-- Data for Name: question; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.question (id, ask, code, correct, fake1, fake2, fake3, filename, md5correct, right_answer, tip, tip2, tip3, valid, room_id) FROM stdin;
2	Para resolver o bad smell Divergent Change, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Divergent Change, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Extract Method	Inline Class	Replace Inheritance with Delagation	""	d09616ec1f29c6c8ced7a5a821588d4c	\N	\N	\N	\N	t	1
3	Para resolver o bad smell Shotgun Surgery, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Shotgun Surgery, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Extract Class	Extract Method	Replace Inheritance with Delagation	""	bb692987916b5b4f10444429e77235b9	\N	\N	\N	\N	t	1
4	Os bad smells “Divergent Change”...	""	Os bad smells “Divergent Change”...	são semelhantes aos bad smells Shotgun Surgery.	faz com que todas as vezes que uma classe for alterada ,  várias pequenas mudanças em outras classes diferentes tenham que ser feitas.	podem ser resolvidos com a refatoração Move Method..	""	dc0f55740dbed3266140b44d074f8521	\N	\N	\N	\N	t	1
6	Para resolver o bad smell Long Method/God Method, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Long Method/God Method, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Move Method	Extract Subclass	Replace Inheritance with Delagation	""	e83a9ea8aadbd6a6efa33c22564a03ca	\N	\N	\N	\N	t	1
7	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Push Down Field	Push Down Method	Rename Field	""	bb692987916b5b4f10444429e77235b9	\N	\N	\N	\N	t	1
8	Os bad smells “Feature Envy”...	""	Os bad smells “Feature Envy”...	ocorrem quando uma classe pode mudar frequentemente de diferentes formas e por razões distintas.	faz com que todas as vezes que uma classe for alterada ,  várias pequenas mudanças em outras classes diferentes tenham que ser feitas.	ocorrem quando uma classe herda atributos e métodos de outra classe, mas não os usa.	""	02cbc100b74c1e08c8d8d26d041582f5	\N	\N	\N	\N	t	1
10	Qual das opções abaixo se refere ao bad smell "Long Method"?	""	Qual das opções abaixo se refere ao bad smell "Long Method"?	Um sintoma pode ser o execco de atributos.	Um método de uma classe usa atributos somentoe de outra classe,	Algo está errado com a decomposição hierárquica.	""	526a278967e4eab05528ef9b49cf227e	\N	\N	\N	\N	t	1
13	Para resolver o bad smell Large Class/God Class, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Large Class/God Class, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Move Method	Inline Class	Extract Method	""	7c4cefe7a5af7931cb64c0643bfaff0e	\N	\N	\N	\N	t	1
14	Para resolver o bad smell Refused Bequest, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Refused Bequest, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Extract Class	Extract Method	Inline Class	""	d5ebe8cec2fdaef6e35c399e6285423f	\N	\N	\N	\N	t	1
15	Os bad smells “Shotgun Surgery”...	""	Os bad smells “Shotgun Surgery”...	são semelhantes aos bad smells Divergent Change.	ocorrem quando uma classe pode mudar frequentemente de diferentes formas e por razões distintas.	podem ser resolvidos com a refatoração Extract Class.	""	22ed010b79b521548c80fada95bc8387	\N	\N	\N	\N	t	1
16	Qual das seguintes opções NÃO se refere a um bad smell definido no livro Refactoring do Martin Fowler?	""	Qual das seguintes opções NÃO se refere a um bad smell definido no livro Refactoring do Martin Fowler?	Data Clumps	Primitive Obsession	Long Parameter List	""	d42441cb7ba780da014182c3595a92c4	\N	\N	\N	\N	t	1
17	Para resolver o bad smell Refused Bequest, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	""	Para resolver o bad smell Refused Bequest, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	Push Down Method	Push Down Field	Replace Inheritance with Delagation	""	18bae10850e8f96548985e5d59188df0	\N	\N	\N	\N	t	1
19	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	""	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	Inline Class	Move Method	Move Field	""	7c4cefe7a5af7931cb64c0643bfaff0e	\N	\N	\N	\N	t	1
20	Para resolver o bad smell Comments, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?São	""	Para resolver o bad smell Comments, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?São	Extract Class	Inline Class	Replace Inheritance with Delagation	""	e83a9ea8aadbd6a6efa33c22564a03ca	\N	\N	\N	\N	t	1
21	Para resolver o bad smell Divergent Change, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Divergent Change, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Extract Method	Inline Class	Replace Inheritance with Delagation	""	d09616ec1f29c6c8ced7a5a821588d4c	\N	\N	\N	\N	t	1
24	Qual das opções abaixo NÃO é um exemplo de bad smell definido no livro do Fowler?	""	Qual das opções abaixo NÃO é um exemplo de bad smell definido no livro do Fowler?	Duplicated Code	Long Method	Switch Statement	""	b7b78fc7494d6ce81485e862b2196071	\N	\N	\N	\N	t	1
28	O excesso de atributos pode ser um sintoma de qual bad smell?	""	O excesso de atributos pode ser um sintoma de qual bad smell?	God Method	Feature Envy	Divergent Change	""	a11020143047a5100ce24af8367610aa	\N	\N	\N	\N	t	1
31	Os bad smells “Feature Envy”...	""	Os bad smells “Feature Envy”...	ocorrem quando uma classe pode mudar frequentemente de diferentes formas e por razões distintas.	faz com que todas as vezes que uma classe for alterada ,  várias pequenas mudanças em outras classes diferentes tenham que ser feitas.	ocorrem quando uma classe herda atributos e métodos de outra classe, mas não os usa.	""	02cbc100b74c1e08c8d8d26d041582f5	\N	\N	\N	\N	t	1
1	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	""	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	Inline Class	Move Method	Move Field	""	7c4cefe7a5af7931cb64c0643bfaff0e	\N	\N	\N	\N	t	1
5	Para resolver o bad smell Large Class/God Class, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Large Class/God Class, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Move Method	Inline Class	Extract Method	""	7c4cefe7a5af7931cb64c0643bfaff0e	\N	\N	\N	\N	t	1
9	Qual das opções abaixo representa um bad smell com sua respectiva refatoração?	""	Qual das opções abaixo representa um bad smell com sua respectiva refatoração?	God Method - > Move Method	Feature Envy -> Extract Method	Feature Envy -> Extract Class	""	cace93b4463b9f8801b3b0a331127a9d	\N	\N	\N	\N	t	1
11	Os bad smells “Divergent Change”...	""	Os bad smells “Divergent Change”...	são semelhantes aos bad smells Shotgun Surgery.	faz com que todas as vezes que uma classe for alterada ,  várias pequenas mudanças em outras classes diferentes tenham que ser feitas.	podem ser resolvidos com a refatoração Move Method..	""	dc0f55740dbed3266140b44d074f8521	\N	\N	\N	\N	t	1
12	Para resolver o bad smell Large Class/God Class, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Large Class/God Class, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Move Field	Inline Class	Extract Method	""	d09616ec1f29c6c8ced7a5a821588d4c	\N	\N	\N	\N	t	1
18	Para resolver o bad smell Shotgun Surgery, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Shotgun Surgery, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Extract Class	Extract Method	Replace Inheritance with Delagation	""	bb692987916b5b4f10444429e77235b9	\N	\N	\N	\N	t	1
22	Para resolver o bad smell Shotgun Surgery, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	""	Para resolver o bad smell Shotgun Surgery, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	Move Method	Move Field	Inline Class	""	d09616ec1f29c6c8ced7a5a821588d4c	\N	\N	\N	\N	t	1
23	Para resolver o bad smell Comments, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	""	Para resolver o bad smell Comments, são sugeridas algumas refatorações de código. Qual das refatorações abaixo NÃO é indicada para este bad smell?	Extract Method	Rename Method	Rename Field	""	d09616ec1f29c6c8ced7a5a821588d4c	\N	\N	\N	\N	t	1
25	Qual das opções abaixo se refere ao bad smell "Refused Bequest"?	""	Qual das opções abaixo se refere ao bad smell "Refused Bequest"?	Parte do código de uma classe “inveja” outra classe.	Métodos que centralizam a funcionalidade da classe.	Uma classe que faz coisa demais no sistema.	""	a1593984ecf377af50185647cee14dfc	\N	\N	\N	\N	t	1
26	Qual das opções abaixo se refere ao bad smell "Long Method"?	""	Qual das opções abaixo se refere ao bad smell "Long Method"?	Um sintoma pode ser o execco de atributos.	Um método de uma classe usa atributos somentoe de outra classe,	Algo está errado com a decomposição hierárquica.	""	526a278967e4eab05528ef9b49cf227e	\N	\N	\N	\N	t	1
27	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Feature Envy, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Push Down Field	Push Down Method	Rename Field	""	bb692987916b5b4f10444429e77235b9	\N	\N	\N	\N	t	1
29	Para resolver o bad smell Long Method/God Method, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Long Method/God Method, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Move Method	Extract Subclass	Replace Inheritance with Delagation	""	e83a9ea8aadbd6a6efa33c22564a03ca	\N	\N	\N	\N	t	1
30	"Idealmente, cada classe deve ser alterada apenas por um tipo de mudança." Qual bad smell inviabiliza esse tipo de ação?	""	"Idealmente, cada classe deve ser alterada apenas por um tipo de mudança." Qual bad smell inviabiliza esse tipo de ação?	God Class	Shotgun Surgery	Refused Bequest	""	9aa0a177fe1900bc8c86e3295a20f74c	\N	\N	\N	\N	t	1
32	Para resolver o bad smell Long Method/God Method, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	""	Para resolver o bad smell Long Method/God Method, são sugeridas algumas refatorações de código. Qual das refatorações abaixo é indicada para este bad smell?	Move Method	Extract Class	Move Field	""	42ce0c3f343aa9745f203a46441ec6d5	\N	\N	\N	\N	t	1
33	Qual das opções abaixo representa um bad smell com sua respectiva refatoração?	""	Qual das opções abaixo representa um bad smell com sua respectiva refatoração?	God Method - > Move Method	Feature Envy -> Extract Method	Feature Envy -> Extract Class	""	cace93b4463b9f8801b3b0a331127a9d	\N	\N	\N	\N	t	1
34	Qual das opções abaixo NÃO representa um bad smell com sua respectiva refatoração?	""	Qual das opções abaixo NÃO representa um bad smell com sua respectiva refatoração?	God Method -> Replace Method with Method Object	Divergent Change -> Extract Class	Refused Bequest -> Push Down Method	""	748fe1887662c467b6f8e3c0ef1d139b	\N	\N	\N	\N	t	1
43	Identifique o Bad Smell na classe abaixo	/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the "License"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.taskdefs.optional.net;\n\nimport java.net.Authenticator;\nimport java.net.PasswordAuthentication;\nimport java.util.Properties;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.util.ProxySetup;\n\n/**\n * Sets Java's web proxy properties, so that tasks and code run in\n * the same JVM can have through-the-firewall access to remote web sites,\n * and remote ftp sites.\n * You can nominate an http and ftp proxy, or a socks server, reset the server\n * settings, or do nothing at all.\n * <p>\n * Examples\n * <pre>&lt;setproxy/&gt;</pre>\n * do nothing\n * <pre>&lt;setproxy proxyhost="firewall"/&gt;</pre>\n * set the proxy to firewall:80\n * <pre>&lt;setproxy proxyhost="firewall" proxyport="81"/&gt;</pre>\n * set the proxy to firewall:81\n * <pre>&lt;setproxy proxyhost=""/&gt;</pre>\n * stop using the http proxy; don't change the socks settings\n * <pre>&lt;setproxy socksproxyhost="socksy"/&gt;</pre>\n * use socks via socksy:1080\n * <pre>&lt;setproxy socksproxyhost=""/&gt;</pre>\n * stop using the socks server.\n * <p>\n * You can set a username and password for http with the <tt>proxyHost</tt>\n * and <tt>proxyPassword</tt> attributes. These can also be\n * used against SOCKS5 servers.\n * </p>\n * @see <a href="http://java.sun.com/j2se/1.5.0/docs/guide/net/properties.html">\n *  java 1.5 network property list</a>\n  *@since       Ant 1.5\n * @ant.task category="network"\n */\npublic class SetProxy extends Task {\n    private static final int HTTP_PORT = 80;\n    private static final int SOCKS_PORT = 1080;\n    // CheckStyle:VisibilityModifier OFF - bc\n    /**\n     * proxy details\n     */\n    protected String proxyHost = null;\n\n    /**\n     * name of proxy port\n     */\n    protected int proxyPort = HTTP_PORT;\n\n    // CheckStyle:VisibilityModifier ON\n\n    /**\n     * socks host.\n     */\n    private String socksProxyHost = null;\n\n    /**\n     * Socks proxy port. Default is 1080.\n     */\n    private int socksProxyPort = SOCKS_PORT;\n\n\n    /**\n     * list of non proxy hosts\n     */\n    private String nonProxyHosts = null;\n\n    /**\n     * user for http only\n     */\n    private String proxyUser = null;\n\n    /**\n     * password for http only\n     */\n    private String proxyPassword = null;\n\n    /**\n     * the HTTP/ftp proxy host. Set this to "" for the http proxy\n     * option to be disabled\n     *\n     * @param hostname the new proxy hostname\n     */\n    public void setProxyHost(String hostname) {\n        proxyHost = hostname;\n    }\n\n\n    /**\n     * the HTTP/ftp proxy port number; default is 80\n     *\n     * @param port port number of the proxy\n     */\n    public void setProxyPort(int port) {\n        proxyPort = port;\n    }\n\n    /**\n     * The name of a Socks server. Set to "" to turn socks\n     * proxying off.\n     *\n     * @param host The new SocksProxyHost value\n     */\n    public void setSocksProxyHost(String host) {\n        this.socksProxyHost = host;\n    }\n\n\n    /**\n     * Set the ProxyPort for socks connections. The default value is 1080\n     *\n     * @param port The new SocksProxyPort value\n     */\n    public void setSocksProxyPort(int port) {\n        this.socksProxyPort = port;\n    }\n\n\n    /**\n     * A list of hosts to bypass the proxy on. These should be separated\n     * with the vertical bar character '|'. Only in Java 1.4 does ftp use\n     * this list.\n     * e.g. fozbot.corp.sun.com|*.eng.sun.com\n     * @param nonProxyHosts lists of hosts to talk direct to\n     */\n    public void setNonProxyHosts(String nonProxyHosts) {\n        this.nonProxyHosts = nonProxyHosts;\n    }\n\n    /**\n     * set the proxy user. Probably requires a password to accompany this\n     * setting. Default=""\n     * @param proxyUser username\n     * @since Ant1.6\n     */\n    public void setProxyUser(String proxyUser) {\n        this.proxyUser = proxyUser;\n    }\n\n    /**\n     * Set the password for the proxy. Used only if the proxyUser is set.\n     * @param proxyPassword password to go with the username\n     * @since Ant1.6\n     */\n    public void setProxyPassword(String proxyPassword) {\n        this.proxyPassword = proxyPassword;\n    }\n\n    /**\n     * if the proxy port and host settings are not null, then the settings\n     * get applied these settings last beyond the life of the object and\n     * apply to all network connections\n     * Relevant docs: buglist #4183340\n     */\n\n    public void applyWebProxySettings() {\n        boolean settingsChanged = false;\n        boolean enablingProxy = false;\n        Properties sysprops = System.getProperties();\n        if (proxyHost != null) {\n            settingsChanged = true;\n            if (proxyHost.length() != 0) {\n                traceSettingInfo();\n                enablingProxy = true;\n                sysprops.put(ProxySetup.HTTP_PROXY_HOST, proxyHost);\n                String portString = Integer.toString(proxyPort);\n                sysprops.put(ProxySetup.HTTP_PROXY_PORT, portString);\n                sysprops.put(ProxySetup.HTTPS_PROXY_HOST, proxyHost);\n                sysprops.put(ProxySetup.HTTPS_PROXY_PORT, portString);\n                sysprops.put(ProxySetup.FTP_PROXY_HOST, proxyHost);\n                sysprops.put(ProxySetup.FTP_PROXY_PORT, portString);\n                if (nonProxyHosts != null) {\n                    sysprops.put(ProxySetup.HTTP_NON_PROXY_HOSTS, nonProxyHosts);\n                    sysprops.put(ProxySetup.HTTPS_NON_PROXY_HOSTS, nonProxyHosts);\n                    sysprops.put(ProxySetup.FTP_NON_PROXY_HOSTS, nonProxyHosts);\n                }\n                if (proxyUser != null) {\n                    sysprops.put(ProxySetup.HTTP_PROXY_USERNAME, proxyUser);\n                    sysprops.put(ProxySetup.HTTP_PROXY_PASSWORD, proxyPassword);\n                }\n            } else {\n                log("resetting http proxy", Project.MSG_VERBOSE);\n                sysprops.remove(ProxySetup.HTTP_PROXY_HOST);\n                sysprops.remove(ProxySetup.HTTP_PROXY_PORT);\n                sysprops.remove(ProxySetup.HTTP_PROXY_USERNAME);\n                sysprops.remove(ProxySetup.HTTP_PROXY_PASSWORD);\n                sysprops.remove(ProxySetup.HTTPS_PROXY_HOST);\n                sysprops.remove(ProxySetup.HTTPS_PROXY_PORT);\n                sysprops.remove(ProxySetup.FTP_PROXY_HOST);\n                sysprops.remove(ProxySetup.FTP_PROXY_PORT);\n            }\n        }\n\n        //socks\n        if (socksProxyHost != null) {\n            settingsChanged = true;\n            if (socksProxyHost.length() != 0) {\n                enablingProxy = true;\n                sysprops.put(ProxySetup.SOCKS_PROXY_HOST, socksProxyHost);\n                sysprops.put(ProxySetup.SOCKS_PROXY_PORT, Integer.toString(socksProxyPort));\n                if (proxyUser != null) {\n                    //this may be a java1.4 thingy only\n                    sysprops.put(ProxySetup.SOCKS_PROXY_USERNAME, proxyUser);\n                    sysprops.put(ProxySetup.SOCKS_PROXY_PASSWORD, proxyPassword);\n                }\n\n            } else {\n                log("resetting socks proxy", Project.MSG_VERBOSE);\n                sysprops.remove(ProxySetup.SOCKS_PROXY_HOST);\n                sysprops.remove(ProxySetup.SOCKS_PROXY_PORT);\n                sysprops.remove(ProxySetup.SOCKS_PROXY_USERNAME);\n                sysprops.remove(ProxySetup.SOCKS_PROXY_PASSWORD);\n            }\n        }\n\n        if (proxyUser != null) {\n            if (enablingProxy) {\n                Authenticator.setDefault(new ProxyAuth(proxyUser,\n                                                       proxyPassword));\n            } else if (settingsChanged) {\n                Authenticator.setDefault(new ProxyAuth("", ""));\n            }\n        }\n    }\n\n    /**\n     * list out what is going on\n     */\n    private void traceSettingInfo() {\n        log("Setting proxy to "\n                + (proxyHost != null ? proxyHost : "''")\n                + ":" + proxyPort,\n                Project.MSG_VERBOSE);\n    }\n\n    /**\n     * Does the work.\n     *\n     * @exception BuildException thrown in unrecoverable error.\n     */\n    public void execute() throws BuildException {\n        applyWebProxySettings();\n    }\n\n    /**\n     * @since 1.6.3\n     */\n    private static final class ProxyAuth extends Authenticator {\n        private PasswordAuthentication auth;\n\n        private ProxyAuth(String user, String pass) {\n            auth = new PasswordAuthentication(user, pass.toCharArray());\n        }\n\n        protected PasswordAuthentication getPasswordAuthentication() {\n            return auth;\n        }\n    }\n}	Feature Envy	Long Method\n	Divergent Change\n	Shotgun Surgery\n	SetProxy.java	84b29496676a8fca072ecfe34bc8f705	\N	Um método está mais interessado em outra classe do que aquela em que está realmente	NOA (Number of Operations Added), LOCC ((Lines of Concern Code), LCOM (Lack of Cohesion in Methods) 	Refatoração sugerida:Move Method	t	2
39	Identifique o Bad Smell na classe abaixo	/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.sdklib.devices;\n\nimport com.android.annotations.Nullable;\nimport com.android.dvlib.DeviceSchema;\nimport com.android.resources.Density;\nimport com.android.resources.Keyboard;\nimport com.android.resources.KeyboardState;\nimport com.android.resources.Navigation;\nimport com.android.resources.NavigationState;\nimport com.android.resources.ScreenOrientation;\nimport com.android.resources.ScreenRatio;\nimport com.android.resources.ScreenSize;\nimport com.android.resources.TouchScreen;\nimport com.android.resources.UiMode;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport java.awt.Point;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\npublic class DeviceParser {\n\n    private static class DeviceHandler extends DefaultHandler {\n        private final static String sSpaceRegex = "[\\\\s]+";\n        private final List mDevices = new ArrayList();\n        private final StringBuilder mStringAccumulator = new StringBuilder();\n        private final File mParentFolder;\n        private Meta mMeta;\n        private Hardware mHardware;\n        private Software mSoftware;\n        private State mState;\n        private Device.Builder mBuilder;\n        private Camera mCamera;\n        private Storage.Unit mUnit;\n\n        public DeviceHandler(@Nullable File parentFolder) {\n            mParentFolder = parentFolder;\n        }\n\n        public List getDevices() {\n            return mDevices;\n        }\n\n        @Override\n        public void startElement(String uri, String localName, String name, Attributes attributes)\n                throws SAXException {\n\n            if (DeviceSchema.NODE_DEVICE.equals(localName)) {\n                // Reset everything\n                mMeta = null;\n                mHardware = null;\n                mSoftware = null;\n                mState = null;\n                mCamera = null;\n                mBuilder = new Device.Builder();\n            } else if (DeviceSchema.NODE_META.equals(localName)) {\n                mMeta = new Meta();\n            } else if (DeviceSchema.NODE_HARDWARE.equals(localName)) {\n                mHardware = new Hardware();\n            } else if (DeviceSchema.NODE_SOFTWARE.equals(localName)) {\n                mSoftware = new Software();\n            } else if (DeviceSchema.NODE_STATE.equals(localName)) {\n                mState = new State();\n                // mState can embed a Hardware instance\n                mHardware = mHardware.deepCopy();\n                String defaultState = attributes.getValue(DeviceSchema.ATTR_DEFAULT);\n                if ("true".equals(defaultState) || "1".equals(defaultState)) {\n                    mState.setDefaultState(true);\n                }\n                mState.setName(attributes.getValue(DeviceSchema.ATTR_NAME).trim());\n            } else if (DeviceSchema.NODE_CAMERA.equals(localName)) {\n                mCamera = new Camera();\n            } else if (DeviceSchema.NODE_RAM.equals(localName)\n                    || DeviceSchema.NODE_INTERNAL_STORAGE.equals(localName)\n                    || DeviceSchema.NODE_REMOVABLE_STORAGE.equals(localName)) {\n                mUnit = Storage.Unit.getEnum(attributes.getValue(DeviceSchema.ATTR_UNIT));\n            } else if (DeviceSchema.NODE_FRAME.equals(localName)) {\n                mMeta.setFrameOffsetLandscape(new Point());\n                mMeta.setFrameOffsetPortrait(new Point());\n            } else if (DeviceSchema.NODE_SCREEN.equals(localName)) {\n                mHardware.setScreen(new Screen());\n            }\n            mStringAccumulator.setLength(0);\n        }\n\n        @Override\n        public void characters(char[] ch, int start, int length) {\n            mStringAccumulator.append(ch, start, length);\n        }\n\n        @Override\n        public void endElement(String uri, String localName, String name) throws SAXException {\n            if (DeviceSchema.NODE_DEVICE.equals(localName)) {\n                mDevices.add(mBuilder.build());\n            } else if (DeviceSchema.NODE_NAME.equals(localName)) {\n                mBuilder.setName(getString(mStringAccumulator));\n            } else if (DeviceSchema.NODE_MANUFACTURER.equals(localName)) {\n                mBuilder.setManufacturer(getString(mStringAccumulator));\n            } else if (DeviceSchema.NODE_META.equals(localName)) {\n                mBuilder.setMeta(mMeta);\n            } else if (DeviceSchema.NODE_SOFTWARE.equals(localName)) {\n                mBuilder.addSoftware(mSoftware);\n            } else if (DeviceSchema.NODE_STATE.equals(localName)) {\n                mState.setHardware(mHardware);\n                mBuilder.addState(mState);\n            } else if (DeviceSchema.NODE_SIXTY_FOUR.equals(localName)) {\n                mMeta.setIconSixtyFour(new File(mParentFolder, getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_SIXTEEN.equals(localName)) {\n                mMeta.setIconSixteen(new File(mParentFolder, getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_PATH.equals(localName)) {\n                mMeta.setFrame(new File(mParentFolder, mStringAccumulator.toString().trim()));\n            } else if (DeviceSchema.NODE_PORTRAIT_X_OFFSET.equals(localName)) {\n                mMeta.getFrameOffsetPortrait().x = getInteger(mStringAccumulator);\n            } else if (DeviceSchema.NODE_PORTRAIT_Y_OFFSET.equals(localName)) {\n                mMeta.getFrameOffsetPortrait().y = getInteger(mStringAccumulator);\n            } else if (DeviceSchema.NODE_LANDSCAPE_X_OFFSET.equals(localName)) {\n                mMeta.getFrameOffsetLandscape().x = getInteger(mStringAccumulator);\n            } else if (DeviceSchema.NODE_LANDSCAPE_Y_OFFSET.equals(localName)) {\n                mMeta.getFrameOffsetLandscape().y = getInteger(mStringAccumulator);\n            } else if (DeviceSchema.NODE_SCREEN_SIZE.equals(localName)) {\n                mHardware.getScreen().setSize(ScreenSize.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_DIAGONAL_LENGTH.equals(localName)) {\n                mHardware.getScreen().setDiagonalLength(getDouble(mStringAccumulator));\n            } else if (DeviceSchema.NODE_PIXEL_DENSITY.equals(localName)) {\n                mHardware.getScreen().setPixelDensity(\n                        Density.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_SCREEN_RATIO.equals(localName)) {\n                mHardware.getScreen().setRatio(\n                    ScreenRatio.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_X_DIMENSION.equals(localName)) {\n                mHardware.getScreen().setXDimension(getInteger(mStringAccumulator));\n            } else if (DeviceSchema.NODE_Y_DIMENSION.equals(localName)) {\n                mHardware.getScreen().setYDimension(getInteger(mStringAccumulator));\n            } else if (DeviceSchema.NODE_XDPI.equals(localName)) {\n                mHardware.getScreen().setXdpi(getDouble(mStringAccumulator));\n            } else if (DeviceSchema.NODE_YDPI.equals(localName)) {\n                mHardware.getScreen().setYdpi(getDouble(mStringAccumulator));\n            } else if (DeviceSchema.NODE_MULTITOUCH.equals(localName)) {\n                mHardware.getScreen().setMultitouch(\n                        Multitouch.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_MECHANISM.equals(localName)) {\n                mHardware.getScreen().setMechanism(\n                        TouchScreen.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_SCREEN_TYPE.equals(localName)) {\n                mHardware.getScreen().setScreenType(\n                        ScreenType.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_NETWORKING.equals(localName)) {\n                for (String n : getStringList(mStringAccumulator)) {\n                    Network net = Network.getEnum(n);\n                    if (net != null) {\n                        mHardware.addNetwork(net);\n                    }\n                }\n            } else if (DeviceSchema.NODE_SENSORS.equals(localName)) {\n                for (String s : getStringList(mStringAccumulator)) {\n                    Sensor sens = Sensor.getEnum(s);\n                    if (sens != null) {\n                        mHardware.addSensor(sens);\n                    }\n                }\n            } else if (DeviceSchema.NODE_MIC.equals(localName)) {\n                mHardware.setHasMic(getBool(mStringAccumulator));\n            } else if (DeviceSchema.NODE_CAMERA.equals(localName)) {\n                mHardware.addCamera(mCamera);\n                mCamera = null;\n            } else if (DeviceSchema.NODE_LOCATION.equals(localName)) {\n                mCamera.setLocation(CameraLocation.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_AUTOFOCUS.equals(localName)) {\n                mCamera.setFlash(getBool(mStringAccumulator));\n            } else if (DeviceSchema.NODE_FLASH.equals(localName)) {\n                mCamera.setFlash(getBool(mStringAccumulator));\n            } else if (DeviceSchema.NODE_KEYBOARD.equals(localName)) {\n                mHardware.setKeyboard(Keyboard.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_NAV.equals(localName)) {\n                mHardware.setNav(Navigation.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_RAM.equals(localName)) {\n                int val = getInteger(mStringAccumulator);\n                mHardware.setRam(new Storage(val, mUnit));\n            } else if (DeviceSchema.NODE_BUTTONS.equals(localName)) {\n                mHardware.setButtonType(ButtonType.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_INTERNAL_STORAGE.equals(localName)) {\n                for (String s : getStringList(mStringAccumulator)) {\n                    int val = Integer.parseInt(s);\n                    mHardware.addInternalStorage(new Storage(val, mUnit));\n                }\n            } else if (DeviceSchema.NODE_REMOVABLE_STORAGE.equals(localName)) {\n                for (String s : getStringList(mStringAccumulator)) {\n                    if (s != null && !s.isEmpty()) {\n                        int val = Integer.parseInt(s);\n                        mHardware.addRemovableStorage(new Storage(val, mUnit));\n                    }\n                }\n            } else if (DeviceSchema.NODE_CPU.equals(localName)) {\n                mHardware.setCpu(getString(mStringAccumulator));\n            } else if (DeviceSchema.NODE_GPU.equals(localName)) {\n                mHardware.setGpu(getString(mStringAccumulator));\n            } else if (DeviceSchema.NODE_ABI.equals(localName)) {\n                for (String s : getStringList(mStringAccumulator)) {\n                    Abi abi = Abi.getEnum(s);\n                    if (abi != null) {\n                        mHardware.addSupportedAbi(abi);\n                    }\n                }\n            } else if (DeviceSchema.NODE_DOCK.equals(localName)) {\n                for (String s : getStringList(mStringAccumulator)) {\n                    UiMode d = UiMode.getEnum(s);\n                    if (d != null) {\n                        mHardware.addSupportedUiMode(d);\n                    }\n                }\n            } else if (DeviceSchema.NODE_POWER_TYPE.equals(localName)) {\n                mHardware.setChargeType(PowerType.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_API_LEVEL.equals(localName)) {\n                String val = getString(mStringAccumulator);\n                // Can be one of 5 forms:\n                // 1\n                // 1-2\n                // 1-\n                // -2\n                // -\n                int index;\n                if (val.charAt(0) == '-') {\n                    if (val.length() == 1) { // -\n                        mSoftware.setMinSdkLevel(0);\n                        mSoftware.setMaxSdkLevel(Integer.MAX_VALUE);\n                    } else { // -2\n                        // Remove the front dash and any whitespace between it\n                        // and the upper bound.\n                        val = val.substring(1).trim();\n                        mSoftware.setMinSdkLevel(0);\n                        mSoftware.setMaxSdkLevel(Integer.parseInt(val));\n                    }\n                } else if ((index = val.indexOf('-')) > 0) {\n                    if (index == val.length() - 1) { // 1-\n                        // Strip the last dash and any whitespace between it and\n                        // the lower bound.\n                        val = val.substring(0, val.length() - 1).trim();\n                        mSoftware.setMinSdkLevel(Integer.parseInt(val));\n                        mSoftware.setMaxSdkLevel(Integer.MAX_VALUE);\n                    } else { // 1-2\n                        String min = val.substring(0, index).trim();\n                        String max = val.substring(index + 1);\n                        mSoftware.setMinSdkLevel(Integer.parseInt(min));\n                        mSoftware.setMaxSdkLevel(Integer.parseInt(max));\n                    }\n                } else { // 1\n                    int apiLevel = Integer.parseInt(val);\n                    mSoftware.setMinSdkLevel(apiLevel);\n                    mSoftware.setMaxSdkLevel(apiLevel);\n                }\n            } else if (DeviceSchema.NODE_LIVE_WALLPAPER_SUPPORT.equals(localName)) {\n                mSoftware.setLiveWallpaperSupport(getBool(mStringAccumulator));\n            } else if (DeviceSchema.NODE_BLUETOOTH_PROFILES.equals(localName)) {\n                for (String s : getStringList(mStringAccumulator)) {\n                    BluetoothProfile profile = BluetoothProfile.getEnum(s);\n                    if (profile != null) {\n                        mSoftware.addBluetoothProfile(profile);\n                    }\n                }\n            } else if (DeviceSchema.NODE_GL_VERSION.equals(localName)) {\n                // Guaranteed to be in the form [\\d]\\.[\\d]\n                mSoftware.setGlVersion(getString(mStringAccumulator));\n            } else if (DeviceSchema.NODE_GL_EXTENSIONS.equals(localName)) {\n                mSoftware.addAllGlExtensions(getStringList(mStringAccumulator));\n            } else if (DeviceSchema.NODE_DESCRIPTION.equals(localName)) {\n                mState.setDescription(getString(mStringAccumulator));\n            } else if (DeviceSchema.NODE_SCREEN_ORIENTATION.equals(localName)) {\n                mState.setOrientation(ScreenOrientation.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_KEYBOARD_STATE.equals(localName)) {\n                mState.setKeyState(KeyboardState.getEnum(getString(mStringAccumulator)));\n            } else if (DeviceSchema.NODE_NAV_STATE.equals(localName)) {\n                // We have an extra state in our XML for nonav that\n                // NavigationState doesn't contain\n                String navState = getString(mStringAccumulator);\n                if (navState.equals("nonav")) {\n                    mState.setNavState(NavigationState.HIDDEN);\n                } else {\n                    mState.setNavState(NavigationState.getEnum(getString(mStringAccumulator)));\n                }\n            } else if (DeviceSchema.NODE_STATUS_BAR.equals(localName)) {\n                mSoftware.setStatusBar(getBool(mStringAccumulator));\n            }\n        }\n\n        @Override\n        public void error(SAXParseException e) throws SAXParseException {\n            throw e;\n        }\n\n        private List getStringList(StringBuilder stringAccumulator) {\n            List filteredStrings = new ArrayList();\n            for (String s : getString(mStringAccumulator).split(sSpaceRegex)) {\n                if (s != null && !s.isEmpty()) {\n                    filteredStrings.add(s.trim());\n                }\n            }\n            return filteredStrings;\n        }\n\n        private Boolean getBool(StringBuilder stringAccumulator) {\n            String b = getString(stringAccumulator);\n            return b.equalsIgnoreCase("true") || b.equalsIgnoreCase("1");\n        }\n\n        private double getDouble(StringBuilder stringAccumulator) {\n            return Double.parseDouble(getString(stringAccumulator));\n        }\n\n        private String getString(StringBuilder stringAccumulator) {\n            return stringAccumulator.toString().trim();\n        }\n\n        private int getInteger(StringBuilder stringAccumulator) {\n            return Integer.parseInt(getString(stringAccumulator));\n        }\n\n    }\n\n    private final static SAXParserFactory sParserFactory;\n\n    static {\n        sParserFactory = SAXParserFactory.newInstance();\n        sParserFactory.setNamespaceAware(true);\n    }\n\n    public static List parse(File devicesFile) throws SAXException,\n            ParserConfigurationException, IOException {\n        SAXParser parser = getParser();\n        DeviceHandler dHandler = new DeviceHandler(devicesFile.getAbsoluteFile().getParentFile());\n        parser.parse(devicesFile, dHandler);\n        return dHandler.getDevices();\n    }\n\n    public static List parse(InputStream devices) throws SAXException, IOException,\n            ParserConfigurationException {\n        SAXParser parser = getParser();\n        DeviceHandler dHandler = new DeviceHandler(null);\n        parser.parse(devices, dHandler);\n        return dHandler.getDevices();\n    }\n\n    private static SAXParser getParser() throws ParserConfigurationException, SAXException {\n        sParserFactory.setSchema(DeviceSchema.getSchema());\n        return sParserFactory.newSAXParser();\n    }\n}	God Class	Long Method\n	Shotgun Surgery\n	Feature Envy\n	DeviceParser.java	a11020143047a5100ce24af8367610aa	\N	Uma classe implementando várias responsabilidades, tendo um grande número de atributos, operações e dependências com classes de dados 	LOC (Lines of Code), WMC (Weighted Method per Class), CBO (Coupling Betwenn Object Classes); LCOM (Lack of Cohesion in Methods)	Refatoração sugerida:Extract Subclass	t	2
54	Identifique o Bad Smell na classe abaixo	/*******************************************************************************\n * Copyright (c) 2000, 2009 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *     Tom Tromey - Contribution for bug 125961\n *     Tom Tromey - Contribution for bug 159641\n *     Benjamin Muskalla - Contribution for bug 239066\n *******************************************************************************/\npackage org.eclipse.jdt.internal.compiler.batch;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.core.compiler.CompilationProgress;\nimport org.eclipse.jdt.core.compiler.IProblem;\nimport org.eclipse.jdt.core.compiler.batch.BatchCompiler;\nimport org.eclipse.jdt.internal.compiler.AbstractAnnotationProcessorManager;\nimport org.eclipse.jdt.internal.compiler.ClassFile;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.Compiler;\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\nimport org.eclipse.jdt.internal.compiler.IProblemFactory;\nimport org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.env.AccessRestriction;\nimport org.eclipse.jdt.internal.compiler.env.AccessRule;\nimport org.eclipse.jdt.internal.compiler.env.AccessRuleSet;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerStats;\nimport org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\nimport org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\nimport org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;\nimport org.eclipse.jdt.internal.compiler.util.GenericXMLWriter;\nimport org.eclipse.jdt.internal.compiler.util.HashtableOfInt;\nimport org.eclipse.jdt.internal.compiler.util.HashtableOfObject;\nimport org.eclipse.jdt.internal.compiler.util.Messages;\nimport org.eclipse.jdt.internal.compiler.util.SuffixConstants;\nimport org.eclipse.jdt.internal.compiler.util.Util;\n\npublic class Main implements ProblemSeverities, SuffixConstants {\n\tpublic static class Logger {\n\t\tprivate PrintWriter err;\n\t\tprivate PrintWriter log;\n\t\tprivate Main main;\n\t\tprivate PrintWriter out;\n\t\tprivate HashMap parameters;\n\t\tint tagBits;\n\t\tprivate static final String CLASS = "class"; //$NON-NLS-1$\n\t\tprivate static final String CLASS_FILE = "classfile"; //$NON-NLS-1$\n\t\tprivate static final String CLASSPATH = "classpath"; //$NON-NLS-1$\n\t\tprivate static final String CLASSPATH_FILE = "FILE"; //$NON-NLS-1$\n\t\tprivate static final String CLASSPATH_FOLDER = "FOLDER"; //$NON-NLS-1$\n\t\tprivate static final String CLASSPATH_ID = "id"; //$NON-NLS-1$\n\t\tprivate static final String CLASSPATH_JAR = "JAR"; //$NON-NLS-1$\n\t\tprivate static final String CLASSPATHS = "classpaths"; //$NON-NLS-1$\n\t\tprivate static final String COMMAND_LINE_ARGUMENT = "argument"; //$NON-NLS-1$\n\t\tprivate static final String COMMAND_LINE_ARGUMENTS = "command_line"; //$NON-NLS-1$\n\t\tprivate static final String COMPILER = "compiler"; //$NON-NLS-1$\n\t\tprivate static final String COMPILER_COPYRIGHT = "copyright"; //$NON-NLS-1$\n\t\tprivate static final String COMPILER_NAME = "name"; //$NON-NLS-1$\n\t\tprivate static final String COMPILER_VERSION = "version"; //$NON-NLS-1$\n\t\tpublic static final int EMACS = 2;\n\t\tprivate static final String ERROR = "ERROR"; //$NON-NLS-1$\n\t\tprivate static final String ERROR_TAG = "error"; //$NON-NLS-1$\n\t\tprivate static final String EXCEPTION = "exception"; //$NON-NLS-1$\n\t\tprivate static final String EXTRA_PROBLEM_TAG = "extra_problem"; //$NON-NLS-1$\n\t\tprivate static final String EXTRA_PROBLEMS = "extra_problems"; //$NON-NLS-1$\n\t\tprivate static final HashtableOfInt FIELD_TABLE = new HashtableOfInt();\n\t\tprivate static final String KEY = "key"; //$NON-NLS-1$\n\t\tprivate static final String MESSAGE = "message"; //$NON-NLS-1$\n\t\tprivate static final String NUMBER_OF_CLASSFILES = "number_of_classfiles"; //$NON-NLS-1$\n\t\tprivate static final String NUMBER_OF_ERRORS = "errors"; //$NON-NLS-1$\n\t\tprivate static final String NUMBER_OF_LINES = "number_of_lines"; //$NON-NLS-1$\n\t\tprivate static final String NUMBER_OF_PROBLEMS = "problems"; //$NON-NLS-1$\n\t\tprivate static final String NUMBER_OF_TASKS = "tasks"; //$NON-NLS-1$\n\t\tprivate static final String NUMBER_OF_WARNINGS = "warnings"; //$NON-NLS-1$\n\t\tprivate static final String OPTION = "option"; //$NON-NLS-1$\n\t\tprivate static final String OPTIONS = "options"; //$NON-NLS-1$\n\t\tprivate static final String OUTPUT = "output"; //$NON-NLS-1$\n\t\tprivate static final String PACKAGE = "package"; //$NON-NLS-1$\n\t\tprivate static final String PATH = "path"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_ARGUMENT = "argument"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_ARGUMENT_VALUE = "value"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_ARGUMENTS = "arguments"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_CATEGORY_ID = "categoryID"; //$NON-NLS-1$\n\t\tprivate static final String ID = "id"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_ID = "problemID"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_LINE = "line"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_OPTION_KEY = "optionKey"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_MESSAGE = "message"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_SEVERITY = "severity"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_SOURCE_END = "charEnd"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_SOURCE_START = "charStart"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_SUMMARY = "problem_summary"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEM_TAG = "problem"; //$NON-NLS-1$\n\t\tprivate static final String PROBLEMS = "problems"; //$NON-NLS-1$\n\t\tprivate static final String SOURCE = "source"; //$NON-NLS-1$\n\t\tprivate static final String SOURCE_CONTEXT = "source_context"; //$NON-NLS-1$\n\t\tprivate static final String SOURCE_END = "sourceEnd"; //$NON-NLS-1$\n\t\tprivate static final String SOURCE_START = "sourceStart"; //$NON-NLS-1$\n\t\tprivate static final String SOURCES = "sources"; //$NON-NLS-1$\n\n\t\tprivate static final String STATS = "stats"; //$NON-NLS-1$\n\n\t\tprivate static final String TASK = "task"; //$NON-NLS-1$\n\t\tprivate static final String TASKS = "tasks"; //$NON-NLS-1$\n\t\tprivate static final String TIME = "time"; //$NON-NLS-1$\n\t\tprivate static final String VALUE = "value"; //$NON-NLS-1$\n\t\tprivate static final String WARNING = "WARNING"; //$NON-NLS-1$\n\t\tpublic static final int XML = 1;\n\t\tprivate static final String XML_DTD_DECLARATION = "<!DOCTYPE compiler PUBLIC \\"-//Eclipse.org//DTD Eclipse JDT 3.2.003 Compiler//EN\\" \\"http://www.eclipse.org/jdt/core/compiler_32_003.dtd\\">"; //$NON-NLS-1$\n\t\tstatic {\n\t\t\ttry {\n\t\t\t\tClass c = IProblem.class;\n\t\t\t\tField[] fields = c.getFields();\n\t\t\t\tfor (int i = 0, max = fields.length; i < max; i++) {\n\t\t\t\t\tField field = fields[i];\n\t\t\t\t\tif (field.getType().equals(Integer.TYPE)) {\n\t\t\t\t\t\tInteger value = (Integer) field.get(null);\n\t\t\t\t\t\tint key2 = value.intValue() & IProblem.IgnoreCategoriesMask;\n\t\t\t\t\t\tif (key2 == 0) {\n\t\t\t\t\t\t\tkey2 = Integer.MAX_VALUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLogger.FIELD_TABLE.put(key2, field.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (SecurityException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tpublic Logger(Main main, PrintWriter out, PrintWriter err) {\n\t\t\tthis.out = out;\n\t\t\tthis.err = err;\n\t\t\tthis.parameters = new HashMap();\n\t\t\tthis.main = main;\n\t\t}\n\n\t\tpublic String buildFileName(\n\t\t\tString outputPath,\n\t\t\tString relativeFileName) {\n\t\t\tchar fileSeparatorChar = File.separatorChar;\n\t\t\tString fileSeparator = File.separator;\n\n\t\t\toutputPath = outputPath.replace('/', fileSeparatorChar);\n\t\t\t// To be able to pass the mkdirs() method we need to remove the extra file separator at the end of the outDir name\n\t\t\tStringBuffer outDir = new StringBuffer(outputPath);\n\t\t\tif (!outputPath.endsWith(fileSeparator)) {\n\t\t\t\toutDir.append(fileSeparator);\n\t\t\t}\n\t\t\tStringTokenizer tokenizer =\n\t\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);\n\t\t\tString token = tokenizer.nextToken();\n\t\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\t\toutDir.append(token).append(fileSeparator);\n\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t}\n\t\t\t// token contains the last one\n\t\t\treturn outDir.append(token).toString();\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tif (this.log != null) {\n\t\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\t\tendTag(Logger.COMPILER);\n\t\t\t\t\tflush();\n\t\t\t\t}\n\t\t\t\tthis.log.close();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic void compiling() {\n\t\t\tprintlnOut(this.main.bind("progress.compiling")); //$NON-NLS-1$\n\t\t}\n\t\tprivate void endLoggingExtraProblems() {\n\t\t\tendTag(Logger.EXTRA_PROBLEMS);\n\t\t}\n\t\t/**\n\t\t * Used to stop logging problems.\n\t\t * Only use in xml mode.\n\t\t */\n\t\tprivate void endLoggingProblems() {\n\t\t\tendTag(Logger.PROBLEMS);\n\t\t}\n\t\tpublic void endLoggingSource() {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tendTag(Logger.SOURCE);\n\t\t\t}\n\t\t}\n\n\t\tpublic void endLoggingSources() {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tendTag(Logger.SOURCES);\n\t\t\t}\n\t\t}\n\n\t\tpublic void endLoggingTasks() {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tendTag(Logger.TASKS);\n\t\t\t}\n\t\t}\n\t\tprivate void endTag(String name) {\n\t\t\tif (this.log != null) {\n\t\t\t\t((GenericXMLWriter) this.log).endTag(name, true, true);\n\t\t\t}\n\t\t}\n\t\tprivate String errorReportSource(CategorizedProblem problem, char[] unitSource, int bits) {\n\t\t\t//extra from the source the innacurate     token\n\t\t\t//and "highlight" it using some underneath ^^^^^\n\t\t\t//put some context around too.\n\n\t\t\t//this code assumes that the font used in the console is fixed size\n\n\t\t\t//sanity .....\n\t\t\tint startPosition = problem.getSourceStart();\n\t\t\tint endPosition = problem.getSourceEnd();\n\t\t\tif (unitSource == null) {\n\t\t\t\tif (problem.getOriginatingFileName() != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tunitSource = Util.getFileCharContent(new File(new String(problem.getOriginatingFileName())), null);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// ignore;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint length = unitSource == null ? 0 : unitSource.length;\n\t\t\tif ((startPosition > endPosition)\n\t\t\t\t|| ((startPosition < 0) && (endPosition < 0))\n\t\t\t\t|| length == 0)\n\t\t\t\treturn Messages.problem_noSourceInformation;\n\n\t\t\tStringBuffer errorBuffer = new StringBuffer();\n\t\t\tif ((bits & Main.Logger.EMACS) == 0) {\n\t\t\t\terrorBuffer.append(' ').append(Messages.bind(Messages.problem_atLine, String.valueOf(problem.getSourceLineNumber())));\n\t\t\t\terrorBuffer.append(Util.LINE_SEPARATOR);\n\t\t\t}\n\t\t\terrorBuffer.append('\\t');\n\n\t\t\tchar c;\n\t\t\tfinal char SPACE = '\\u0020';\n\t\t\tfinal char MARK = '^';\n\t\t\tfinal char TAB = '\\t';\n\t\t\t//the next code tries to underline the token.....\n\t\t\t//it assumes (for a good display) that token source does not\n\t\t\t//contain any \\r \\n. This is false on statements !\n\t\t\t//(the code still works but the display is not optimal !)\n\n\t\t\t// expand to line limits\n\t\t\tint begin;\n\t\t\tint end;\n\t\t\tfor (begin = startPosition >= length ? length - 1 : startPosition; begin > 0; begin--) {\n\t\t\t\tif ((c = unitSource[begin - 1]) == '\\n' || c == '\\r') break;\n\t\t\t}\n\t\t\tfor (end = endPosition >= length ? length - 1 : endPosition ; end+1 < length; end++) {\n\t\t\t\tif ((c = unitSource[end + 1]) == '\\r' || c == '\\n') break;\n\t\t\t}\n\n\t\t\t// trim left and right spaces/tabs\n\t\t\twhile ((c = unitSource[begin]) == ' ' || c == '\\t') begin++;\n\t\t\t//while ((c = unitSource[end]) == ' ' || c == '\\t') end--; TODO (philippe) should also trim right, but all tests are to be updated\n\n\t\t\t// copy source\n\t\t\terrorBuffer.append(unitSource, begin, end-begin+1);\n\t\t\terrorBuffer.append(Util.LINE_SEPARATOR).append("\\t"); //$NON-NLS-1$\n\n\t\t\t// compute underline\n\t\t\tfor (int i = begin; i <startPosition; i++) {\n\t\t\t\terrorBuffer.append((unitSource[i] == TAB) ? TAB : SPACE);\n\t\t\t}\n\t\t\tfor (int i = startPosition; i <= (endPosition >= length ? length - 1 : endPosition); i++) {\n\t\t\t\terrorBuffer.append(MARK);\n\t\t\t}\n\t\t\treturn errorBuffer.toString();\n\t\t}\n\n\t\tprivate void extractContext(CategorizedProblem problem, char[] unitSource) {\n\t\t\t//sanity .....\n\t\t\tint startPosition = problem.getSourceStart();\n\t\t\tint endPosition = problem.getSourceEnd();\n\t\t\tif (unitSource == null) {\n\t\t\t\tif (problem.getOriginatingFileName() != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tunitSource = Util.getFileCharContent(new File(new String(problem.getOriginatingFileName())), null);\n\t\t\t\t\t} catch(IOException e) {\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint length = unitSource== null ? 0 : unitSource.length;\n\t\t\tif ((startPosition > endPosition)\n\t\t\t\t\t|| ((startPosition < 0) && (endPosition < 0))\n\t\t\t\t\t|| (length <= 0)\n\t\t\t\t\t|| (endPosition > length)) {\n\t\t\t\tthis.parameters.put(Logger.VALUE, Messages.problem_noSourceInformation);\n\t\t\t\tthis.parameters.put(Logger.SOURCE_START, "-1"); //$NON-NLS-1$\n\t\t\t\tthis.parameters.put(Logger.SOURCE_END, "-1"); //$NON-NLS-1$\n\t\t\t\tprintTag(Logger.SOURCE_CONTEXT, this.parameters, true, true);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar c;\n\t\t\t//the next code tries to underline the token.....\n\t\t\t//it assumes (for a good display) that token source does not\n\t\t\t//contain any \\r \\n. This is false on statements !\n\t\t\t//(the code still works but the display is not optimal !)\n\n\t\t\t// expand to line limits\n\t\t\tint begin, end;\n\t\t\tfor (begin = startPosition >= length ? length - 1 : startPosition; begin > 0; begin--) {\n\t\t\t\tif ((c = unitSource[begin - 1]) == '\\n' || c == '\\r') break;\n\t\t\t}\n\t\t\tfor (end = endPosition >= length ? length - 1 : endPosition ; end+1 < length; end++) {\n\t\t\t\tif ((c = unitSource[end + 1]) == '\\r' || c == '\\n') break;\n\t\t\t}\n\n\t\t\t// trim left and right spaces/tabs\n\t\t\twhile ((c = unitSource[begin]) == ' ' || c == '\\t') begin++;\n\t\t\twhile ((c = unitSource[end]) == ' ' || c == '\\t') end--;\n\n\t\t\t// copy source\n\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\tbuffer.append(unitSource, begin, end - begin + 1);\n\n\t\t\tthis.parameters.put(Logger.VALUE, String.valueOf(buffer));\n\t\t\tthis.parameters.put(Logger.SOURCE_START, Integer.toString(startPosition - begin));\n\t\t\tthis.parameters.put(Logger.SOURCE_END, Integer.toString(endPosition - begin));\n\t\t\tprintTag(Logger.SOURCE_CONTEXT, this.parameters, true, true);\n\t\t}\n\t\tpublic void flush() {\n\t\t\tthis.out.flush();\n\t\t\tthis.err.flush();\n\t\t\tif (this.log != null) {\n\t\t\t\tthis.log.flush();\n\t\t\t}\n\t\t}\n\n\t\tprivate String getFieldName(int id) {\n\t\t\tint key2 = id & IProblem.IgnoreCategoriesMask;\n\t\t\tif (key2 == 0) {\n\t\t\t\tkey2 = Integer.MAX_VALUE;\n\t\t\t}\n\t\t\treturn (String) Logger.FIELD_TABLE.get(key2);\n\t\t}\n\n\t\t// find out an option name controlling a given problemID\n\t\tprivate String getProblemOptionKey(int problemID) {\n\t\t\tint irritant = ProblemReporter.getIrritant(problemID);\n\t\t\treturn CompilerOptions.optionKeyFromIrritant(irritant);\n\t\t}\n\n\t\tpublic void logAverage() {\n\t\t\tArrays.sort(this.main.compilerStats);\n\t\t\tlong lineCount = this.main.compilerStats[0].lineCount;\n\t\t\tfinal int length = this.main.maxRepetition;\n\t\t\tlong sum = 0;\n\t\t\tlong parseSum = 0, resolveSum = 0, analyzeSum = 0, generateSum = 0;\n\t\t\tfor (int i = 1, max = length - 1; i < max; i++) {\n\t\t\t\tCompilerStats stats = this.main.compilerStats[i];\n\t\t\t\tsum += stats.elapsedTime();\n\t\t\t\tparseSum += stats.parseTime;\n\t\t\t\tresolveSum += stats.resolveTime;\n\t\t\t\tanalyzeSum += stats.analyzeTime;\n\t\t\t\tgenerateSum += stats.generateTime;\n\t\t\t}\n\t\t\tlong time = sum / (length - 2);\n\t\t\tlong parseTime = parseSum/(length - 2);\n\t\t\tlong resolveTime = resolveSum/(length - 2);\n\t\t\tlong analyzeTime = analyzeSum/(length - 2);\n\t\t\tlong generateTime = generateSum/(length - 2);\n\t\t\tprintlnOut(this.main.bind(\n\t\t\t\t"compile.averageTime", //$NON-NLS-1$\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(lineCount),\n\t\t\t\t\tString.valueOf(time),\n\t\t\t\t\tString.valueOf(((int) (lineCount * 10000.0 / time)) / 10.0),\n\t\t\t\t}));\n\t\t\tif ((this.main.timing & Main.TIMING_DETAILED) != 0) {\n\t\t\t\tprintlnOut(\n\t\t\t\t\t\tthis.main.bind("compile.detailedTime", //$NON-NLS-1$\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\tString.valueOf(parseTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (parseTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t\tString.valueOf(resolveTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (resolveTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t\tString.valueOf(analyzeTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (analyzeTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t\tString.valueOf(generateTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (generateTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t\tpublic void logClassFile(boolean generatePackagesStructure, String outputPath, String relativeFileName) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tString fileName = null;\n\t\t\t\tif (generatePackagesStructure) {\n\t\t\t\t\tfileName = buildFileName(outputPath, relativeFileName);\n\t\t\t\t} else {\n\t\t\t\t\tchar fileSeparatorChar = File.separatorChar;\n\t\t\t\t\tString fileSeparator = File.separator;\n\t\t\t\t\t// First we ensure that the outputPath exists\n\t\t\t\t\toutputPath = outputPath.replace('/', fileSeparatorChar);\n\t\t\t\t\t// To be able to pass the mkdirs() method we need to remove the extra file separator at the end of the outDir name\n\t\t\t\t\tint indexOfPackageSeparator = relativeFileName.lastIndexOf(fileSeparatorChar);\n\t\t\t\t\tif (indexOfPackageSeparator == -1) {\n\t\t\t\t\t\tif (outputPath.endsWith(fileSeparator)) {\n\t\t\t\t\t\t\tfileName = outputPath + relativeFileName;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint length = relativeFileName.length();\n\t\t\t\t\t\tif (outputPath.endsWith(fileSeparator)) {\n\t\t\t\t\t\t\tfileName = outputPath + relativeFileName.substring(indexOfPackageSeparator + 1, length);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName.substring(indexOfPackageSeparator + 1, length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFile f = new File(fileName);\n\t\t\t\ttry {\n\t\t\t\t\tthis.parameters.put(Logger.PATH, f.getCanonicalPath());\n\t\t\t\t\tprintTag(Logger.CLASS_FILE, this.parameters, true, true);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogNoClassFileCreated(outputPath, relativeFileName, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic void logClasspath(FileSystem.Classpath[] classpaths) {\n\t\t\tif (classpaths == null) return;\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tfinal int length = classpaths.length;\n\t\t\t\tif (length != 0) {\n\t\t\t\t\t// generate xml output\n\t\t\t\t\tprintTag(Logger.CLASSPATHS, null, true, false);\n\t\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\t\tString classpath = classpaths[i].getPath();\n\t\t\t\t\t\tthis.parameters.put(Logger.PATH, classpath);\n\t\t\t\t\t\tFile f = new File(classpath);\n\t\t\t\t\t\tString id = null;\n\t\t\t\t\t\tif (f.isFile()) {\n\t\t\t\t\t\t\tif (Util.isPotentialZipArchive(classpath)) {\n\t\t\t\t\t\t\t\tid = Logger.CLASSPATH_JAR;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tid = Logger.CLASSPATH_FILE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (f.isDirectory()) {\n\t\t\t\t\t\t\tid = Logger.CLASSPATH_FOLDER;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (id != null) {\n\t\t\t\t\t\t\tthis.parameters.put(Logger.CLASSPATH_ID, id);\n\t\t\t\t\t\t\tprintTag(Logger.CLASSPATH, this.parameters, true, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tendTag(Logger.CLASSPATHS);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void logCommandLineArguments(String[] commandLineArguments) {\n\t\t\tif (commandLineArguments == null) return;\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tfinal int length = commandLineArguments.length;\n\t\t\t\tif (length != 0) {\n\t\t\t\t\t// generate xml output\n\t\t\t\t\tprintTag(Logger.COMMAND_LINE_ARGUMENTS, null, true, false);\n\t\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\t\tthis.parameters.put(Logger.VALUE, commandLineArguments[i]);\n\t\t\t\t\t\tprintTag(Logger.COMMAND_LINE_ARGUMENT, this.parameters, true, true);\n\t\t\t\t\t}\n\t\t\t\t\tendTag(Logger.COMMAND_LINE_ARGUMENTS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param e the given exception to log\n\t\t */\n\t\tpublic void logException(Exception e) {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\tPrintWriter printWriter = new PrintWriter(writer);\n\t\t\te.printStackTrace(printWriter);\n\t\t\tprintWriter.flush();\n\t\t\tprintWriter.close();\n\t\t\tfinal String stackTrace = writer.toString();\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tLineNumberReader reader = new LineNumberReader(new StringReader(stackTrace));\n\t\t\t\tString line;\n\t\t\t\tint i = 0;\n\t\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\t\tString message = e.getMessage();\n\t\t\t\tif (message != null) {\n\t\t\t\t\tbuffer.append(message).append(Util.LINE_SEPARATOR);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\twhile ((line = reader.readLine()) != null && i < 4) {\n\t\t\t\t\t\tbuffer.append(line).append(Util.LINE_SEPARATOR);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\treader.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tmessage = buffer.toString();\n\t\t\t\tthis.parameters.put(Logger.MESSAGE, message);\n\t\t\t\tthis.parameters.put(Logger.CLASS, e.getClass());\n\t\t\t\tprintTag(Logger.EXCEPTION, this.parameters, true, true);\n\t\t\t}\n\t\t\tString message = e.getMessage();\n\t\t\tif (message == null) {\n\t\t\t\tthis.printlnErr(stackTrace);\n\t\t\t} else {\n\t\t\t\tthis.printlnErr(message);\n\t\t\t}\n\t\t}\n\n\t\tprivate void logExtraProblem(CategorizedProblem problem, int localErrorCount, int globalErrorCount) {\n\t\t\tchar[] originatingFileName = problem.getOriginatingFileName();\n\t\t\tString fileName =\n\t\t\t\toriginatingFileName == null\n\t\t\t\t? this.main.bind("requestor.noFileNameSpecified")//$NON-NLS-1$\n\t\t\t\t: new String(originatingFileName);\n\t\t\tif ((this.tagBits & Logger.EMACS) != 0) {\n\t\t\t\tString result = fileName\n\t\t\t\t\t\t+ ":" //$NON-NLS-1$\n\t\t\t\t\t\t+ problem.getSourceLineNumber()\n\t\t\t\t\t\t+ ": " //$NON-NLS-1$\n\t\t\t\t\t\t+ (problem.isError() ? this.main.bind("output.emacs.error") : this.main.bind("output.emacs.warning")) //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t+ ": " //$NON-NLS-1$\n\t\t\t\t\t\t+ problem.getMessage();\n\t\t\t\tthis.printlnErr(result);\n\t\t\t\tfinal String errorReportSource = errorReportSource(problem, null, this.tagBits);\n\t\t\t\tthis.printlnErr(errorReportSource);\n\t\t\t} else {\n\t\t\t\tif (localErrorCount == 0) {\n\t\t\t\t\tthis.printlnErr("----------"); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\tprintErr(problem.isError() ?\n\t\t\t\t\t\tthis.main.bind(\n\t\t\t\t\t\t\t\t"requestor.error", //$NON-NLS-1$\n\t\t\t\t\t\t\t\tInteger.toString(globalErrorCount),\n\t\t\t\t\t\t\t\tnew String(fileName))\n\t\t\t\t\t\t\t\t: this.main.bind(\n\t\t\t\t\t\t\t\t\t\t"requestor.warning", //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\tInteger.toString(globalErrorCount),\n\t\t\t\t\t\t\t\t\t\tnew String(fileName)));\n\t\t\t\tfinal String errorReportSource = errorReportSource(problem, null, 0);\n\t\t\t\tthis.printlnErr(errorReportSource);\n\t\t\t\tthis.printlnErr(problem.getMessage());\n\t\t\t\tthis.printlnErr("----------"); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\n\t\tpublic void loggingExtraProblems(Main currentMain) {\n\t\t\tArrayList problems = currentMain.extraProblems;\n\t\t\tfinal int count = problems.size();\n\t\t\tint localErrorCount = 0;\n\t\t\tint localProblemCount = 0;\n\t\t\tif (count != 0) {\n\t\t\t\tint errors = 0;\n\t\t\t\tint warnings = 0;\n\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\tCategorizedProblem problem = (CategorizedProblem) problems.get(i);\n\t\t\t\t\tif (problem != null) {\n\t\t\t\t\t\tcurrentMain.globalProblemsCount++;\n\t\t\t\t\t\tlogExtraProblem(problem, localProblemCount, currentMain.globalProblemsCount);\n\t\t\t\t\t\tlocalProblemCount++;\n\t\t\t\t\t\tif (problem.isError()) {\n\t\t\t\t\t\t\tlocalErrorCount++;\n\t\t\t\t\t\t\terrors++;\n\t\t\t\t\t\t\tcurrentMain.globalErrorsCount++;\n\t\t\t\t\t\t} else if (problem.isWarning()) {\n\t\t\t\t\t\t\tcurrentMain.globalWarningsCount++;\n\t\t\t\t\t\t\twarnings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\t\tif ((errors + warnings) != 0) {\n\t\t\t\t\t\tstartLoggingExtraProblems(count);\n\t\t\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\t\t\tCategorizedProblem problem = (CategorizedProblem) problems.get(i);\n\t\t\t\t\t\t\tif (problem!= null) {\n\t\t\t\t\t\t\t\tif (problem.getID() != IProblem.Task) {\n\t\t\t\t\t\t\t\t\tlogXmlExtraProblem(problem, localProblemCount, currentMain.globalProblemsCount);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tendLoggingExtraProblems();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void logIncorrectVMVersionForAnnotationProcessing() {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.MESSAGE, this.main.bind("configure.incorrectVMVersionforAPT")); //$NON-NLS-1$\n\t\t\t\tprintTag(Logger.ERROR_TAG, this.parameters, true, true);\n\t\t\t}\n\t\t\tthis.printlnErr(this.main.bind("configure.incorrectVMVersionforAPT")); //$NON-NLS-1$\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic void logNoClassFileCreated(String outputDir, String relativeFileName, IOException e) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.MESSAGE, this.main.bind("output.noClassFileCreated", //$NON-NLS-1$\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\toutputDir,\n\t\t\t\t\t\trelativeFileName,\n\t\t\t\t\t\te.getMessage()\n\t\t\t\t\t}));\n\t\t\t\tprintTag(Logger.ERROR_TAG, this.parameters, true, true);\n\t\t\t}\n\t\t\tthis.printlnErr(this.main.bind("output.noClassFileCreated", //$NON-NLS-1$\n\t\t\t\tnew String[] {\n\t\t\t\t\toutputDir,\n\t\t\t\t\trelativeFileName,\n\t\t\t\t\te.getMessage()\n\t\t\t\t}));\n\t\t}\n\n\t\t/**\n\t\t * @param exportedClassFilesCounter\n\t\t */\n\t\tpublic void logNumberOfClassFilesGenerated(int exportedClassFilesCounter) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.VALUE, new Integer(exportedClassFilesCounter));\n\t\t\t\tprintTag(Logger.NUMBER_OF_CLASSFILES, this.parameters, true, true);\n\t\t\t}\n\t\t\tif (exportedClassFilesCounter == 1) {\n\t\t\t\tprintlnOut(this.main.bind("compile.oneClassFileGenerated")); //$NON-NLS-1$\n\t\t\t} else {\n\t\t\t\tprintlnOut(this.main.bind("compile.severalClassFilesGenerated", //$NON-NLS-1$\n\t\t\t\t\tString.valueOf(exportedClassFilesCounter)));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param options the given compiler options\n\t\t */\n\t\tpublic void logOptions(Map options) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tprintTag(Logger.OPTIONS, null, true, false);\n\t\t\t\tfinal Set entriesSet = options.entrySet();\n\t\t\t\tObject[] entries = entriesSet.toArray();\n\t\t\t\tArrays.sort(entries, new Comparator() {\n\t\t\t\t\tpublic int compare(Object o1, Object o2) {\n\t\t\t\t\t\tMap.Entry entry1 = (Map.Entry) o1;\n\t\t\t\t\t\tMap.Entry entry2 = (Map.Entry) o2;\n\t\t\t\t\t\treturn ((String) entry1.getKey()).compareTo((String) entry2.getKey());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor (int i = 0, max = entries.length; i < max; i++) {\n\t\t\t\t\tMap.Entry entry = (Map.Entry) entries[i];\n\t\t\t\t\tString key = (String) entry.getKey();\n\t\t\t\t\tthis.parameters.put(Logger.KEY, key);\n\t\t\t\t\tthis.parameters.put(Logger.VALUE, entry.getValue());\n\t\t\t\t\tprintTag(Logger.OPTION, this.parameters, true, true);\n\t\t\t\t}\n\t\t\t\tendTag(Logger.OPTIONS);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param error the given error\n\t\t */\n\t\tpublic void logPendingError(String error) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.MESSAGE, error);\n\t\t\t\tprintTag(Logger.ERROR_TAG, this.parameters, true, true);\n\t\t\t}\n\t\t\tthis.printlnErr(error);\n\t\t}\n\n\t\tprivate void logProblem(CategorizedProblem problem, int localErrorCount,\n\t\t\tint globalErrorCount, char[] unitSource) {\n\t\t\tif ((this.tagBits & Logger.EMACS) != 0) {\n\t\t\t\tString result = (new String(problem.getOriginatingFileName())\n\t\t\t\t\t\t+ ":" //$NON-NLS-1$\n\t\t\t\t\t\t+ problem.getSourceLineNumber()\n\t\t\t\t\t\t+ ": " //$NON-NLS-1$\n\t\t\t\t\t\t+ (problem.isError() ? this.main.bind("output.emacs.error") : this.main.bind("output.emacs.warning")) //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t+ ": " //$NON-NLS-1$\n\t\t\t\t\t\t+ problem.getMessage());\n\t\t\t\tthis.printlnErr(result);\n\t\t\t\tfinal String errorReportSource = errorReportSource(problem, unitSource, this.tagBits);\n\t\t\t\tif (errorReportSource.length() != 0) this.printlnErr(errorReportSource);\n\t\t\t} else {\n\t\t\t\tif (localErrorCount == 0) {\n\t\t\t\t\tthis.printlnErr("----------"); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\tprintErr(problem.isError() ?\n\t\t\t\t\t\tthis.main.bind(\n\t\t\t\t\t\t\t\t"requestor.error", //$NON-NLS-1$\n\t\t\t\t\t\t\t\tInteger.toString(globalErrorCount),\n\t\t\t\t\t\t\t\tnew String(problem.getOriginatingFileName()))\n\t\t\t\t\t\t\t\t: this.main.bind(\n\t\t\t\t\t\t\t\t\t\t"requestor.warning", //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t\tInteger.toString(globalErrorCount),\n\t\t\t\t\t\t\t\t\t\tnew String(problem.getOriginatingFileName())));\n\t\t\t\ttry {\n\t\t\t\t\tfinal String errorReportSource = errorReportSource(problem, unitSource, 0);\n\t\t\t\t\tthis.printlnErr(errorReportSource);\n\t\t\t\t\tthis.printlnErr(problem.getMessage());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthis.printlnErr(this.main.bind(\n\t\t\t\t\t\t"requestor.notRetrieveErrorMessage", problem.toString())); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\tthis.printlnErr("----------"); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\n\t\tpublic int logProblems(CategorizedProblem[] problems, char[] unitSource, Main currentMain) {\n\t\t\tfinal int count = problems.length;\n\t\t\tint localErrorCount = 0;\n\t\t\tint localProblemCount = 0;\n\t\t\tif (count != 0) {\n\t\t\t\tint errors = 0;\n\t\t\t\tint warnings = 0;\n\t\t\t\tint tasks = 0;\n\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\tCategorizedProblem problem = problems[i];\n\t\t\t\t\tif (problem != null) {\n\t\t\t\t\t\tcurrentMain.globalProblemsCount++;\n\t\t\t\t\t\tlogProblem(problem, localProblemCount, currentMain.globalProblemsCount, unitSource);\n\t\t\t\t\t\tlocalProblemCount++;\n\t\t\t\t\t\tif (problem.isError()) {\n\t\t\t\t\t\t\tlocalErrorCount++;\n\t\t\t\t\t\t\terrors++;\n\t\t\t\t\t\t\tcurrentMain.globalErrorsCount++;\n\t\t\t\t\t\t} else if (problem.getID() == IProblem.Task) {\n\t\t\t\t\t\t\tcurrentMain.globalTasksCount++;\n\t\t\t\t\t\t\ttasks++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentMain.globalWarningsCount++;\n\t\t\t\t\t\t\twarnings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\t\tif ((errors + warnings) != 0) {\n\t\t\t\t\t\tstartLoggingProblems(errors, warnings);\n\t\t\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\t\t\tCategorizedProblem problem = problems[i];\n\t\t\t\t\t\t\tif (problem!= null) {\n\t\t\t\t\t\t\t\tif (problem.getID() != IProblem.Task) {\n\t\t\t\t\t\t\t\t\tlogXmlProblem(problem, unitSource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tendLoggingProblems();\n\t\t\t\t\t}\n\t\t\t\t\tif (tasks != 0) {\n\t\t\t\t\t\tstartLoggingTasks(tasks);\n\t\t\t\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\t\t\t\tCategorizedProblem problem = problems[i];\n\t\t\t\t\t\t\tif (problem!= null) {\n\t\t\t\t\t\t\t\tif (problem.getID() == IProblem.Task) {\n\t\t\t\t\t\t\t\t\tlogXmlTask(problem, unitSource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tendLoggingTasks();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn localErrorCount;\n\t\t}\n\n\t\t/**\n\t\t * @param globalProblemsCount\n\t\t * @param globalErrorsCount\n\t\t * @param globalWarningsCount\n\t\t */\n\t\tpublic void logProblemsSummary(int globalProblemsCount,\n\t\t\tint globalErrorsCount, int globalWarningsCount, int globalTasksCount) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\t// generate xml\n\t\t\t\tthis.parameters.put(Logger.NUMBER_OF_PROBLEMS, new Integer(globalProblemsCount));\n\t\t\t\tthis.parameters.put(Logger.NUMBER_OF_ERRORS, new Integer(globalErrorsCount));\n\t\t\t\tthis.parameters.put(Logger.NUMBER_OF_WARNINGS, new Integer(globalWarningsCount));\n\t\t\t\tthis.parameters.put(Logger.NUMBER_OF_TASKS, new Integer(globalTasksCount));\n\t\t\t\tprintTag(Logger.PROBLEM_SUMMARY, this.parameters, true, true);\n\t\t\t}\n\t\t\tif (globalProblemsCount == 1) {\n\t\t\t\tString message = null;\n\t\t\t\tif (globalErrorsCount == 1) {\n\t\t\t\t\tmessage = this.main.bind("compile.oneError"); //$NON-NLS-1$\n\t\t\t\t} else {\n\t\t\t\t\tmessage = this.main.bind("compile.oneWarning"); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\tprintErr(this.main.bind("compile.oneProblem", message)); //$NON-NLS-1$\n\t\t\t} else {\n\t\t\t\tString errorMessage = null;\n\t\t\t\tString warningMessage = null;\n\t\t\t\tif (globalErrorsCount > 0) {\n\t\t\t\t\tif (globalErrorsCount == 1) {\n\t\t\t\t\t\terrorMessage = this.main.bind("compile.oneError"); //$NON-NLS-1$\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrorMessage = this.main.bind("compile.severalErrors", String.valueOf(globalErrorsCount)); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint warningsNumber = globalWarningsCount + globalTasksCount;\n\t\t\t\tif (warningsNumber > 0) {\n\t\t\t\t\tif (warningsNumber == 1) {\n\t\t\t\t\t\twarningMessage = this.main.bind("compile.oneWarning"); //$NON-NLS-1$\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarningMessage = this.main.bind("compile.severalWarnings", String.valueOf(warningsNumber)); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errorMessage == null || warningMessage == null) {\n\t\t\t\t\tif (errorMessage == null) {\n\t\t\t\t\t\tprintErr(this.main.bind(\n\t\t\t\t\t\t\t"compile.severalProblemsErrorsOrWarnings", //$NON-NLS-1$\n\t\t\t\t\t\t\tString.valueOf(globalProblemsCount),\n\t\t\t\t\t\t\twarningMessage));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintErr(this.main.bind(\n\t\t\t\t\t\t\t"compile.severalProblemsErrorsOrWarnings", //$NON-NLS-1$\n\t\t\t\t\t\t\tString.valueOf(globalProblemsCount),\n\t\t\t\t\t\t\terrorMessage));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintErr(this.main.bind(\n\t\t\t\t\t\t"compile.severalProblemsErrorsAndWarnings", //$NON-NLS-1$\n\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\tString.valueOf(globalProblemsCount),\n\t\t\t\t\t\t\terrorMessage,\n\t\t\t\t\t\t\twarningMessage\n\t\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((this.tagBits & Logger.EMACS) != 0) {\n\t\t\t\tthis.printlnErr();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic void logProgress() {\n\t\t\tprintOut('.');\n\t\t}\n\n\t\t/**\n\t\t * @param i\n\t\t *            the current repetition number\n\t\t * @param repetitions\n\t\t *            the given number of repetitions\n\t\t */\n\t\tpublic void logRepetition(int i, int repetitions) {\n\t\t\tprintlnOut(this.main.bind("compile.repetition", //$NON-NLS-1$\n\t\t\t\tString.valueOf(i + 1), String.valueOf(repetitions)));\n\t\t}\n\t\t/**\n\t\t * @param compilerStats\n\t\t */\n\t\tpublic void logTiming(CompilerStats compilerStats) {\n\t\t\tlong time = compilerStats.elapsedTime();\n\t\t\tlong lineCount = compilerStats.lineCount;\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.VALUE, new Long(time));\n\t\t\t\tprintTag(Logger.TIME, this.parameters, true, true);\n\t\t\t\tthis.parameters.put(Logger.VALUE, new Long(lineCount));\n\t\t\t\tprintTag(Logger.NUMBER_OF_LINES, this.parameters, true, true);\n\t\t\t}\n\t\t\tif (lineCount != 0) {\n\t\t\t\tprintlnOut(\n\t\t\t\t\tthis.main.bind("compile.instantTime", //$NON-NLS-1$\n\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\tString.valueOf(lineCount),\n\t\t\t\t\t\t\tString.valueOf(time),\n\t\t\t\t\t\t\tString.valueOf(((int) (lineCount * 10000.0 / time)) / 10.0),\n\t\t\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tprintlnOut(\n\t\t\t\t\tthis.main.bind("compile.totalTime", //$NON-NLS-1$\n\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\tString.valueOf(time),\n\t\t\t\t\t\t}));\n\t\t\t}\n\t\t\tif ((this.main.timing & Main.TIMING_DETAILED) != 0) {\n\t\t\t\tprintlnOut(\n\t\t\t\t\t\tthis.main.bind("compile.detailedTime", //$NON-NLS-1$\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\tString.valueOf(compilerStats.parseTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (compilerStats.parseTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t\tString.valueOf(compilerStats.resolveTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (compilerStats.resolveTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t\tString.valueOf(compilerStats.analyzeTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (compilerStats.analyzeTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t\tString.valueOf(compilerStats.generateTime),\n\t\t\t\t\t\t\t\tString.valueOf(((int) (compilerStats.generateTime * 1000.0 / time)) / 10.0),\n\t\t\t\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Print the usage of the compiler\n\t\t * @param usage\n\t\t */\n\t\tpublic void logUsage(String usage) {\n\t\t\tprintlnOut(usage);\n\t\t}\n\n\t\t/**\n\t\t * Print the version of the compiler in the log and/or the out field\n\t\t */\n\t\tpublic void logVersion(final boolean printToOut) {\n\t\t\tif (this.log != null && (this.tagBits & Logger.XML) == 0) {\n\t\t\t\tfinal String version = this.main.bind("misc.version", //$NON-NLS-1$\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\tthis.main.bind("compiler.name"), //$NON-NLS-1$\n\t\t\t\t\t\tthis.main.bind("compiler.version"), //$NON-NLS-1$\n\t\t\t\t\t\tthis.main.bind("compiler.copyright") //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tthis.log.println("# " + version); //$NON-NLS-1$\n\t\t\t\tif (printToOut) {\n\t\t\t\t\tthis.out.println(version);\n\t\t\t\t\tthis.out.flush();\n\t\t\t\t}\n\t\t\t} else if (printToOut) {\n\t\t\t\tfinal String version = this.main.bind("misc.version", //$NON-NLS-1$\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\tthis.main.bind("compiler.name"), //$NON-NLS-1$\n\t\t\t\t\t\tthis.main.bind("compiler.version"), //$NON-NLS-1$\n\t\t\t\t\t\tthis.main.bind("compiler.copyright") //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tthis.out.println(version);\n\t\t\t\tthis.out.flush();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Print the usage of wrong JDK\n\t\t */\n\t\tpublic void logWrongJDK() {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.MESSAGE, this.main.bind("configure.requiresJDK1.2orAbove")); //$NON-NLS-1$\n\t\t\t\tprintTag(Logger.ERROR, this.parameters, true, true);\n\t\t\t}\n\t\t\tthis.printlnErr(this.main.bind("configure.requiresJDK1.2orAbove")); //$NON-NLS-1$\n\t\t}\n\n\t\tprivate void logXmlExtraProblem(CategorizedProblem problem, int globalErrorCount, int localErrorCount) {\n\t\t\tfinal int sourceStart = problem.getSourceStart();\n\t\t\tfinal int sourceEnd = problem.getSourceEnd();\n\t\t\tboolean isError = problem.isError();\n\t\t\tthis.parameters.put(Logger.PROBLEM_SEVERITY, isError ? Logger.ERROR : Logger.WARNING);\n\t\t\tthis.parameters.put(Logger.PROBLEM_LINE, new Integer(problem.getSourceLineNumber()));\n\t\t\tthis.parameters.put(Logger.PROBLEM_SOURCE_START, new Integer(sourceStart));\n\t\t\tthis.parameters.put(Logger.PROBLEM_SOURCE_END, new Integer(sourceEnd));\n\t\t\tprintTag(Logger.EXTRA_PROBLEM_TAG, this.parameters, true, false);\n\t\t\tthis.parameters.put(Logger.VALUE, problem.getMessage());\n\t\t\tprintTag(Logger.PROBLEM_MESSAGE, this.parameters, true, true);\n\t\t\textractContext(problem, null);\n\t\t\tendTag(Logger.EXTRA_PROBLEM_TAG);\n\t\t}\n\t\t/**\n\t\t * @param problem\n\t\t *            the given problem to log\n\t\t * @param unitSource\n\t\t *            the given unit source\n\t\t */\n\t\tprivate void logXmlProblem(CategorizedProblem problem, char[] unitSource) {\n\t\t\tfinal int sourceStart = problem.getSourceStart();\n\t\t\tfinal int sourceEnd = problem.getSourceEnd();\n\t\t\tfinal int id = problem.getID();\n\t\t\tthis.parameters.put(Logger.ID, getFieldName(id)); // ID as field name\n\t\t\tthis.parameters.put(Logger.PROBLEM_ID, new Integer(id)); // ID as numeric value\n\t\t\tboolean isError = problem.isError();\n\t\t\tint severity = isError ? ProblemSeverities.Error : ProblemSeverities.Warning;\n\t\t\tthis.parameters.put(Logger.PROBLEM_SEVERITY, isError ? Logger.ERROR : Logger.WARNING);\n\t\t\tthis.parameters.put(Logger.PROBLEM_LINE, new Integer(problem.getSourceLineNumber()));\n\t\t\tthis.parameters.put(Logger.PROBLEM_SOURCE_START, new Integer(sourceStart));\n\t\t\tthis.parameters.put(Logger.PROBLEM_SOURCE_END, new Integer(sourceEnd));\n\t\t\tString problemOptionKey = getProblemOptionKey(id);\n\t\t\tif (problemOptionKey != null) {\n\t\t\t\tthis.parameters.put(Logger.PROBLEM_OPTION_KEY, problemOptionKey);\n\t\t\t}\n\t\t\tint categoryID = ProblemReporter.getProblemCategory(severity, id);\n\t\t\tthis.parameters.put(Logger.PROBLEM_CATEGORY_ID, new Integer(categoryID));\n\t\t\tprintTag(Logger.PROBLEM_TAG, this.parameters, true, false);\n\t\t\tthis.parameters.put(Logger.VALUE, problem.getMessage());\n\t\t\tprintTag(Logger.PROBLEM_MESSAGE, this.parameters, true, true);\n\t\t\textractContext(problem, unitSource);\n\t\t\tString[] arguments = problem.getArguments();\n\t\t\tfinal int length = arguments.length;\n\t\t\tif (length != 0) {\n\t\t\t\tprintTag(Logger.PROBLEM_ARGUMENTS, null, true, false);\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tthis.parameters.put(Logger.PROBLEM_ARGUMENT_VALUE, arguments[i]);\n\t\t\t\t\tprintTag(Logger.PROBLEM_ARGUMENT, this.parameters, true, true);\n\t\t\t\t}\n\t\t\t\tendTag(Logger.PROBLEM_ARGUMENTS);\n\t\t\t}\n\t\t\tendTag(Logger.PROBLEM_TAG);\n\t\t}\n\t\t/**\n\t\t * @param problem\n\t\t *            the given problem to log\n\t\t * @param unitSource\n\t\t *            the given unit source\n\t\t */\n\t\tprivate void logXmlTask(CategorizedProblem problem, char[] unitSource) {\n\t\t\tthis.parameters.put(Logger.PROBLEM_LINE, new Integer(problem.getSourceLineNumber()));\n\t\t\tthis.parameters.put(Logger.PROBLEM_SOURCE_START, new Integer(problem.getSourceStart()));\n\t\t\tthis.parameters.put(Logger.PROBLEM_SOURCE_END, new Integer(problem.getSourceEnd()));\n\t\t\tString problemOptionKey = getProblemOptionKey(problem.getID());\n\t\t\tif (problemOptionKey != null) {\n\t\t\t\tthis.parameters.put(Logger.PROBLEM_OPTION_KEY, problemOptionKey);\n\t\t\t}\n\t\t\tprintTag(Logger.TASK, this.parameters, true, false);\n\t\t\tthis.parameters.put(Logger.VALUE, problem.getMessage());\n\t\t\tprintTag(Logger.PROBLEM_MESSAGE, this.parameters, true, true);\n\t\t\textractContext(problem, unitSource);\n\t\t\tendTag(Logger.TASK);\n\t\t}\n\n\t\tprivate void printErr(String s) {\n\t\t\tthis.err.print(s);\n\t\t\tif ((this.tagBits & Logger.XML) == 0 && this.log != null) {\n\t\t\t\tthis.log.print(s);\n\t\t\t}\n\t\t}\n\n\t\tprivate void printlnErr() {\n\t\t\tthis.err.println();\n\t\t\tif ((this.tagBits & Logger.XML) == 0 && this.log != null) {\n\t\t\t\tthis.log.println();\n\t\t\t}\n\t\t}\n\n\t\tprivate void printlnErr(String s) {\n\t\t\tthis.err.println(s);\n\t\t\tif ((this.tagBits & Logger.XML) == 0 && this.log != null) {\n\t\t\t\tthis.log.println(s);\n\t\t\t}\n\t\t}\n\n\t\tprivate void printlnOut(String s) {\n\t\t\tthis.out.println(s);\n\t\t\tif ((this.tagBits & Logger.XML) == 0 && this.log != null) {\n\t\t\t\tthis.log.println(s);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic void printNewLine() {\n\t\t\tthis.out.println();\n\t\t}\n\n\t\tprivate void printOut(char c) {\n\t\t\tthis.out.print(c);\n\t\t}\n\n\t\tpublic void printStats() {\n\t\t\tfinal boolean isTimed = (this.main.timing & TIMING_ENABLED) != 0;\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tprintTag(Logger.STATS, null, true, false);\n\t\t\t}\n\t\t\tif (isTimed) {\n\t\t\t\tCompilerStats compilerStats = this.main.batchCompiler.stats;\n\t\t\t\tcompilerStats.startTime = this.main.startTime; // also include batch initialization times\n\t\t\t\tcompilerStats.endTime = System.currentTimeMillis(); // also include batch output times\n\t\t\t\tlogTiming(compilerStats);\n\t\t\t}\n\t\t\tif (this.main.globalProblemsCount > 0) {\n\t\t\t\tlogProblemsSummary(this.main.globalProblemsCount, this.main.globalErrorsCount, this.main.globalWarningsCount, this.main.globalTasksCount);\n\t\t\t}\n\t\t\tif (this.main.exportedClassFilesCounter != 0\n\t\t\t\t\t&& (this.main.showProgress || isTimed || this.main.verbose)) {\n\t\t\t\tlogNumberOfClassFilesGenerated(this.main.exportedClassFilesCounter);\n\t\t\t}\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tendTag(Logger.STATS);\n\t\t\t}\n\t\t}\n\n\t\tprivate void printTag(String name, HashMap params, boolean insertNewLine, boolean closeTag) {\n\t\t\tif (this.log != null) {\n\t\t\t\t((GenericXMLWriter) this.log).printTag(name, this.parameters, true, insertNewLine, closeTag);\n\t\t\t}\n\t\t\tthis.parameters.clear();\n\t\t}\n\n\t\tpublic void setEmacs() {\n\t\t\tthis.tagBits |= Logger.EMACS;\n\t\t}\n\t\tpublic void setLog(String logFileName) {\n\t\t\tfinal Date date = new Date();\n\t\t\tfinal DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, Locale.getDefault());\n\t\t\ttry {\n\t\t\t\tint index = logFileName.lastIndexOf('.');\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tif (logFileName.substring(index).toLowerCase().equals(".xml")) { //$NON-NLS-1$\n\t\t\t\t\t\tthis.log = new GenericXMLWriter(new OutputStreamWriter(new FileOutputStream(logFileName, false), Util.UTF_8), Util.LINE_SEPARATOR, true);\n\t\t\t\t\t\tthis.tagBits |= Logger.XML;\n\t\t\t\t\t\t// insert time stamp as comment\n\t\t\t\t\t\tthis.log.println("<!-- " + dateFormat.format(date) + " -->");//$NON-NLS-1$//$NON-NLS-2$\n\t\t\t\t\t\tthis.log.println(Logger.XML_DTD_DECLARATION);\n\t\t\t\t\t\tthis.parameters.put(Logger.COMPILER_NAME, this.main.bind("compiler.name")); //$NON-NLS-1$\n\t\t\t\t\t\tthis.parameters.put(Logger.COMPILER_VERSION, this.main.bind("compiler.version")); //$NON-NLS-1$\n\t\t\t\t\t\tthis.parameters.put(Logger.COMPILER_COPYRIGHT, this.main.bind("compiler.copyright")); //$NON-NLS-1$\n\t\t\t\t\t\tprintTag(Logger.COMPILER, this.parameters, true, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.log = new PrintWriter(new FileOutputStream(logFileName, false));\n\t\t\t\t\t\tthis.log.println("# " + dateFormat.format(date));//$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.log = new PrintWriter(new FileOutputStream(logFileName, false));\n\t\t\t\t\tthis.log.println("# " + dateFormat.format(date));//$NON-NLS-1$\n\t\t\t\t}\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new IllegalArgumentException(this.main.bind("configure.cannotOpenLog", logFileName)); //$NON-NLS-1$\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IllegalArgumentException(this.main.bind("configure.cannotOpenLogInvalidEncoding", logFileName)); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tprivate void startLoggingExtraProblems(int count) {\n\t\t\tthis.parameters.put(Logger.NUMBER_OF_PROBLEMS, new Integer(count));\n\t\t\tprintTag(Logger.EXTRA_PROBLEMS, this.parameters, true, false);\n\t\t}\n\n\t\t/**\n\t\t * Used to start logging problems.\n\t\t * Only use in xml mode.\n\t\t */\n\t\tprivate void startLoggingProblems(int errors, int warnings) {\n\t\t\tthis.parameters.put(Logger.NUMBER_OF_PROBLEMS, new Integer(errors + warnings));\n\t\t\tthis.parameters.put(Logger.NUMBER_OF_ERRORS, new Integer(errors));\n\t\t\tthis.parameters.put(Logger.NUMBER_OF_WARNINGS, new Integer(warnings));\n\t\t\tprintTag(Logger.PROBLEMS, this.parameters, true, false);\n\t\t}\n\n\t\tpublic void startLoggingSource(CompilationResult compilationResult) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tICompilationUnit compilationUnit = compilationResult.compilationUnit;\n\t\t\t\tif (compilationUnit != null) {\n    \t\t\t\tchar[] fileName = compilationUnit.getFileName();\n    \t\t\t\tFile f = new File(new String(fileName));\n    \t\t\t\tif (fileName != null) {\n    \t\t\t\t\tthis.parameters.put(Logger.PATH, f.getAbsolutePath());\n    \t\t\t\t}\n    \t\t\t\tchar[][] packageName = compilationResult.packageName;\n    \t\t\t\tif (packageName != null) {\n    \t\t\t\t\tthis.parameters.put(\n    \t\t\t\t\t\t\tLogger.PACKAGE,\n    \t\t\t\t\t\t\tnew String(CharOperation.concatWith(packageName, File.separatorChar)));\n    \t\t\t\t}\n    \t\t\t\tCompilationUnit unit = (CompilationUnit) compilationUnit;\n    \t\t\t\tString destinationPath = unit.destinationPath;\n\t\t\t\t\tif (destinationPath == null) {\n\t\t\t\t\t\tdestinationPath = this.main.destinationPath;\n\t\t\t\t\t}\n\t\t\t\t\tif (destinationPath != null && destinationPath != NONE) {\n\t\t\t\t\t\tif (File.separatorChar == '/') {\n\t\t\t\t\t\t\tthis.parameters.put(Logger.OUTPUT, destinationPath);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.parameters.put(Logger.OUTPUT, destinationPath.replace('/', File.separatorChar));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintTag(Logger.SOURCE, this.parameters, true, false);\n\t\t\t}\n\t\t}\n\n\t\tpublic void startLoggingSources() {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tprintTag(Logger.SOURCES, null, true, false);\n\t\t\t}\n\t\t}\n\n\t\tpublic void startLoggingTasks(int tasks) {\n\t\t\tif ((this.tagBits & Logger.XML) != 0) {\n\t\t\t\tthis.parameters.put(Logger.NUMBER_OF_TASKS, new Integer(tasks));\n\t\t\t\tprintTag(Logger.TASKS, this.parameters, true, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resource bundle factory to share bundles for the same locale\n\t */\n\tpublic static class ResourceBundleFactory {\n\t\tprivate static HashMap Cache = new HashMap();\n\t\tpublic static synchronized ResourceBundle getBundle(Locale locale) {\n\t\t\tResourceBundle bundle = (ResourceBundle) Cache.get(locale);\n\t\t\tif (bundle == null) {\n\t\t\t\tbundle = ResourceBundle.getBundle(Main.bundleName, locale);\n\t\t\t\tCache.put(locale, bundle);\n\t\t\t}\n\t\t\treturn bundle;\n\t\t}\n\t}\n\t// javadoc analysis tuning\n\tboolean enableJavadocOn;\n\n\tboolean warnJavadocOn;\n\tboolean warnAllJavadocOn;\n\n\tpublic Compiler batchCompiler;\n\t/* Bundle containing messages */\n\tpublic ResourceBundle bundle;\n\tprotected FileSystem.Classpath[] checkedClasspaths;\n\n\tpublic Locale compilerLocale;\n\tpublic CompilerOptions compilerOptions; // read-only\n\tpublic CompilationProgress progress;\n\tpublic String destinationPath;\n\tpublic String[] destinationPaths;\n\t// destination path for compilation units that get no more specific\n\t// one (through directory arguments or various classpath options);\n\t// coding is:\n\t// == null: unspecified, write class files close to their respective\n\t//          source files;\n\t// == Main.NONE: absorbent element, do not output class files;\n\t// else: use as the path of the directory into which class files must\n\t//       be written.\n\tprivate boolean didSpecifySource;\n\tprivate boolean didSpecifyTarget;\n\tpublic String[] encodings;\n\tpublic int exportedClassFilesCounter;\n\tpublic String[] filenames;\n\tpublic String[] classNames;\n\t// overrides of destinationPath on a directory argument basis\n\tpublic int globalErrorsCount;\n\tpublic int globalProblemsCount;\n\tpublic int globalTasksCount;\n\tpublic int globalWarningsCount;\n\n\tprivate File javaHomeCache;\n\n\tprivate boolean javaHomeChecked = false;\n\tpublic long lineCount0;\n\n\tpublic String log;\n\n\tpublic Logger logger;\n\tpublic int maxProblems;\n\tpublic Map options;\n\tprotected PrintWriter out;\n\tpublic boolean proceed = true;\n\tpublic boolean proceedOnError = false;\n\tpublic boolean produceRefInfo = false;\n\tpublic int currentRepetition, maxRepetition;\n\tpublic boolean showProgress = false;\n\tpublic long startTime;\n\tpublic ArrayList pendingErrors;\n\tpublic boolean systemExitWhenFinished = true;\n\n\tpublic static final int TIMING_DISABLED = 0;\n\tpublic static final int TIMING_ENABLED = 1;\n\tpublic static final int TIMING_DETAILED = 2;\n\n\tpublic int timing = TIMING_DISABLED;\n\tpublic CompilerStats[] compilerStats;\n\tpublic boolean verbose = false;\n\tprivate String[] expandedCommandLine;\n\n\tprivate PrintWriter err;\n\n\tArrayList extraProblems;\n\tpublic final static String bundleName = "org.eclipse.jdt.internal.compiler.batch.messages"; //$NON-NLS-1$\n\t// two uses: recognize 'none' in options; code the singleton none\n\t// for the '-d none' option (wherever it may be found)\n\tpublic static final int DEFAULT_SIZE_CLASSPATH = 4;\n\n\tpublic static final String NONE = "none"; //$NON-NLS-1$\n\n/**\n * @deprecated - use {@link BatchCompiler#compile(String, PrintWriter, PrintWriter, CompilationProgress)} instead\n * \t\t\t\t\t\t  e.g. BatchCompiler.compile(commandLine, new PrintWriter(System.out), new PrintWriter(System.err), null);\n */\npublic static boolean compile(String commandLine) {\n\treturn new Main(new PrintWriter(System.out), new PrintWriter(System.err), false /* systemExit */, null /* options */, null /* progress */).compile(tokenize(commandLine));\n}\n\n/**\n * @deprecated - use {@link BatchCompiler#compile(String, PrintWriter, PrintWriter, CompilationProgress)} instead\n *                       e.g. BatchCompiler.compile(commandLine, outWriter, errWriter, null);\n */\npublic static boolean compile(String commandLine, PrintWriter outWriter, PrintWriter errWriter) {\n\treturn new Main(outWriter, errWriter, false /* systemExit */, null /* options */, null /* progress */).compile(tokenize(commandLine));\n}\n\n/*\n * Internal API for public API BatchCompiler#compile(String[], PrintWriter, PrintWriter, CompilationProgress)\n */\npublic static boolean compile(String[] commandLineArguments, PrintWriter outWriter, PrintWriter errWriter, CompilationProgress progress) {\n\treturn new Main(outWriter, errWriter, false /* systemExit */, null /* options */, progress).compile(commandLineArguments);\n}\npublic static File[][] getLibrariesFiles(File[] files) {\n\tFilenameFilter filter = new FilenameFilter() {\n\t\tpublic boolean accept(File dir, String name) {\n\t\t\treturn Util.isPotentialZipArchive(name);\n\t\t}\n\t};\n\tfinal int filesLength = files.length;\n\tFile[][] result = new File[filesLength][];\n\tfor (int i = 0; i < filesLength; i++) {\n\t\tFile currentFile = files[i];\n\t\tif (currentFile.exists() && currentFile.isDirectory()) {\n\t\t\tresult[i] = currentFile.listFiles(filter);\n\t\t}\n\t}\n\treturn result;\n}\n\npublic static void main(String[] argv) {\n\tnew Main(new PrintWriter(System.out), new PrintWriter(System.err), true/*systemExit*/, null/*options*/, null/*progress*/).compile(argv);\n}\n\npublic static String[] tokenize(String commandLine) {\n\n\tint count = 0;\n\tString[] arguments = new String[10];\n\tStringTokenizer tokenizer = new StringTokenizer(commandLine, " \\"", true); //$NON-NLS-1$\n\tString token = Util.EMPTY_STRING;\n\tboolean insideQuotes = false;\n\tboolean startNewToken = true;\n\n\t// take care to quotes on the command line\n\t// 'xxx "aaa bbb";ccc yyy' --->  {"xxx", "aaa bbb;ccc", "yyy" }\n\t// 'xxx "aaa bbb;ccc" yyy' --->  {"xxx", "aaa bbb;ccc", "yyy" }\n\t// 'xxx "aaa bbb";"ccc" yyy' --->  {"xxx", "aaa bbb;ccc", "yyy" }\n\t// 'xxx/"aaa bbb";"ccc" yyy' --->  {"xxx/aaa bbb;ccc", "yyy" }\n\twhile (tokenizer.hasMoreTokens()) {\n\t\ttoken = tokenizer.nextToken();\n\n\t\tif (token.equals(" ")) { //$NON-NLS-1$\n\t\t\tif (insideQuotes) {\n\t\t\t\targuments[count - 1] += token;\n\t\t\t\tstartNewToken = false;\n\t\t\t} else {\n\t\t\t\tstartNewToken = true;\n\t\t\t}\n\t\t} else if (token.equals("\\"")) { //$NON-NLS-1$\n\t\t\tif (!insideQuotes && startNewToken) {\n\t\t\t\tif (count == arguments.length)\n\t\t\t\t\tSystem.arraycopy(arguments, 0, (arguments = new String[count * 2]), 0, count);\n\t\t\t\targuments[count++] = Util.EMPTY_STRING;\n\t\t\t}\n\t\t\tinsideQuotes = !insideQuotes;\n\t\t\tstartNewToken = false;\n\t\t} else {\n\t\t\tif (insideQuotes) {\n\t\t\t\targuments[count - 1] += token;\n\t\t\t} else {\n\t\t\t\tif (token.length() > 0 && !startNewToken) {\n\t\t\t\t\targuments[count - 1] += token;\n\t\t\t\t} else {\n\t\t\t\t\tif (count == arguments.length)\n\t\t\t\t\t\tSystem.arraycopy(arguments, 0, (arguments = new String[count * 2]), 0, count);\n\t\t\t\t\tString trimmedToken = token.trim();\n\t\t\t\t\tif (trimmedToken.length() != 0) {\n\t\t\t\t\t\targuments[count++] = trimmedToken;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstartNewToken = false;\n\t\t}\n\t}\n\tSystem.arraycopy(arguments, 0, arguments = new String[count], 0, count);\n\treturn arguments;\n}\n\n/**\n * @deprecated - use {@link #Main(PrintWriter, PrintWriter, boolean, Map, CompilationProgress)} instead\n *                       e.g. Main(outWriter, errWriter, systemExitWhenFinished, null, null)\n */\npublic Main(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished) {\n\tthis(outWriter, errWriter, systemExitWhenFinished, null /* options */, null /* progress */);\n}\n\n/**\n * @deprecated - use {@link #Main(PrintWriter, PrintWriter, boolean, Map, CompilationProgress)} instead\n *                       e.g. Main(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, null)\n */\npublic Main(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished, Map customDefaultOptions) {\n\tthis(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, null /* progress */);\n}\n\npublic Main(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished, Map customDefaultOptions, CompilationProgress compilationProgress) {\n\tthis.initialize(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, compilationProgress);\n\tthis.relocalize();\n}\n\npublic void addExtraProblems(CategorizedProblem problem) {\n\tif (this.extraProblems == null) {\n\t\tthis.extraProblems = new ArrayList();\n\t}\n\tthis.extraProblems.add(problem);\n}\nprotected void addNewEntry(ArrayList paths, String currentClasspathName,\n\t\tArrayList currentRuleSpecs, String customEncoding,\n\t\tString destPath, boolean isSourceOnly,\n\t\tboolean rejectDestinationPathOnJars) {\n\n\tint rulesSpecsSize = currentRuleSpecs.size();\n\tAccessRuleSet accessRuleSet = null;\n\tif (rulesSpecsSize != 0) {\n\t\tAccessRule[] accessRules = new AccessRule[currentRuleSpecs.size()];\n\t\tboolean rulesOK = true;\n\t\tIterator i = currentRuleSpecs.iterator();\n\t\tint j = 0;\n\t\twhile (i.hasNext()) {\n\t\t\tString ruleSpec = (String) i.next();\n\t\t\tchar key = ruleSpec.charAt(0);\n\t\t\tString pattern = ruleSpec.substring(1);\n\t\t\tif (pattern.length() > 0) {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern\n\t\t\t\t\t\t\t\t.toCharArray(), 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '~':\n\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern\n\t\t\t\t\t\t\t\t.toCharArray(),\n\t\t\t\t\t\t\t\tIProblem.DiscouragedReference);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern\n\t\t\t\t\t\t\t\t.toCharArray(),\n\t\t\t\t\t\t\t\tIProblem.ForbiddenReference);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern\n\t\t\t\t\t\t\t\t.toCharArray(),\n\t\t\t\t\t\t\t\tIProblem.ForbiddenReference, true/*keep looking for accessible type*/);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\trulesOK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trulesOK = false;\n\t\t\t}\n\t\t}\n\t\tif (rulesOK) {\n    \t\taccessRuleSet = new AccessRuleSet(accessRules, AccessRestriction.COMMAND_LINE, currentClasspathName);\n\t\t} else {\n\t\t\tif (currentClasspathName.length() != 0) {\n\t\t\t\t// we go on anyway\n\t\t\t\taddPendingErrors(this.bind("configure.incorrectClasspath", currentClasspathName));//$NON-NLS-1$\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (NONE.equals(destPath)) {\n\t\tdestPath = NONE; // keep == comparison valid\n\t}\n\tif (rejectDestinationPathOnJars && destPath != null &&\n\t\t\tUtil.isPotentialZipArchive(currentClasspathName)) {\n\t\tthrow new IllegalArgumentException(\n\t\t\tthis.bind("configure.unexpectedDestinationPathEntryFile", //$NON-NLS-1$\n\t\t\t\t\t\tcurrentClasspathName));\n\t}\n\tFileSystem.Classpath currentClasspath = FileSystem.getClasspath(\n\t\t\tcurrentClasspathName,\n\t\t\tcustomEncoding,\n\t\t\tisSourceOnly,\n\t\t\taccessRuleSet,\n\t\t\tdestPath);\n\tif (currentClasspath != null) {\n\t\tpaths.add(currentClasspath);\n\t} else if (currentClasspathName.length() != 0) {\n\t\t// we go on anyway\n\t\taddPendingErrors(this.bind("configure.incorrectClasspath", currentClasspathName));//$NON-NLS-1$\n\t}\n}\nvoid addPendingErrors(String message) {\n\tif (this.pendingErrors == null) {\n\t\tthis.pendingErrors = new ArrayList();\n\t}\n\tthis.pendingErrors.add(message);\n}\n/*\n * Lookup the message with the given ID in this catalog\n */\npublic String bind(String id) {\n\treturn bind(id, (String[]) null);\n}\n/*\n * Lookup the message with the given ID in this catalog and bind its\n * substitution locations with the given string.\n */\npublic String bind(String id, String binding) {\n\treturn bind(id, new String[] { binding });\n}\n\n/*\n * Lookup the message with the given ID in this catalog and bind its\n * substitution locations with the given strings.\n */\npublic String bind(String id, String binding1, String binding2) {\n\treturn bind(id, new String[] { binding1, binding2 });\n}\n\n/*\n * Lookup the message with the given ID in this catalog and bind its\n * substitution locations with the given string values.\n */\npublic String bind(String id, String[] arguments) {\n\tif (id == null)\n\t\treturn "No message available"; //$NON-NLS-1$\n\tString message = null;\n\ttry {\n\t\tmessage = this.bundle.getString(id);\n\t} catch (MissingResourceException e) {\n\t\t// If we got an exception looking for the message, fail gracefully by just returning\n\t\t// the id we were looking for.  In most cases this is semi-informative so is not too bad.\n\t\treturn "Missing message: " + id + " in: " + Main.bundleName; //$NON-NLS-2$ //$NON-NLS-1$\n\t}\n\treturn MessageFormat.format(message, arguments);\n}\n/**\n * Return true if and only if the running VM supports the given minimal version.\n *\n * <p>This only checks the major version, since the minor version is always 0 (at least for the useful cases).</p>\n * <p>The given minimalSupportedVersion is one of the constants:</p>\n * <ul>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_1</code></li>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_2</code></li>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_3</code></li>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_4</code></li>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_5</code></li>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_6</code></li>\n * <li><code>org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants.JDK1_7</code></li>\n * </ul>\n * @param minimalSupportedVersion the given minimal version\n * @return true if and only if the running VM supports the given minimal version, false otherwise\n */\nprivate boolean checkVMVersion(long minimalSupportedVersion) {\n\t// the format of this property is supposed to be xx.x where x are digits.\n\tString classFileVersion = System.getProperty("java.class.version"); //$NON-NLS-1$\n\tif (classFileVersion == null) {\n\t\t// by default we don't support a class file version we cannot recognize\n\t\treturn false;\n\t}\n\tint index = classFileVersion.indexOf('.');\n\tif (index == -1) {\n\t\t// by default we don't support a class file version we cannot recognize\n\t\treturn false;\n\t}\n\tint majorVersion;\n\ttry {\n\t\tmajorVersion = Integer.parseInt(classFileVersion.substring(0, index));\n\t} catch (NumberFormatException e) {\n\t\t// by default we don't support a class file version we cannot recognize\n\t\treturn false;\n\t}\n\tswitch(majorVersion) {\n\t\tcase 45 : // 1.0 and 1.1\n\t\t\treturn ClassFileConstants.JDK1_1 >= minimalSupportedVersion;\n\t\tcase 46 : // 1.2\n\t\t\treturn ClassFileConstants.JDK1_2 >= minimalSupportedVersion;\n\t\tcase 47 : // 1.3\n\t\t\treturn ClassFileConstants.JDK1_3 >= minimalSupportedVersion;\n\t\tcase 48 : // 1.4\n\t\t\treturn ClassFileConstants.JDK1_4 >= minimalSupportedVersion;\n\t\tcase 49 : // 1.5\n\t\t\treturn ClassFileConstants.JDK1_5 >= minimalSupportedVersion;\n\t\tcase 50 : // 1.6\n\t\t\treturn ClassFileConstants.JDK1_6 >= minimalSupportedVersion;\n\t\tcase 51 : // 1.7\n\t\t\treturn ClassFileConstants.JDK1_7 >= minimalSupportedVersion;\n\t}\n\t// unknown version\n\treturn false;\n}\n/*\n *  Low-level API performing the actual compilation\n */\npublic boolean compile(String[] argv) {\n\n\t// decode command line arguments\n\ttry {\n\t\tconfigure(argv);\n\t\tif (this.progress != null)\n\t\t\tthis.progress.begin(this.filenames == null ? 0 : this.filenames.length * this.maxRepetition);\n\t\tif (this.proceed) {\n//\t\t\t\tif (this.verbose) {\n//\t\t\t\t\tSystem.out.println(new CompilerOptions(this.options));\n//\t\t\t\t}\n\t\t\tif (this.showProgress) this.logger.compiling();\n\t\t\tfor (this.currentRepetition = 0; this.currentRepetition < this.maxRepetition; this.currentRepetition++) {\n\t\t\t\tthis.globalProblemsCount = 0;\n\t\t\t\tthis.globalErrorsCount = 0;\n\t\t\t\tthis.globalWarningsCount = 0;\n\t\t\t\tthis.globalTasksCount = 0;\n\t\t\t\tthis.exportedClassFilesCounter = 0;\n\n\t\t\t\tif (this.maxRepetition > 1) {\n\t\t\t\t\tthis.logger.flush();\n\t\t\t\t\tthis.logger.logRepetition(this.currentRepetition, this.maxRepetition);\n\t\t\t\t}\n\t\t\t\t// request compilation\n\t\t\t\tperformCompilation();\n\t\t\t}\n\t\t\tif (this.compilerStats != null) {\n\t\t\t\tthis.logger.logAverage();\n\t\t\t}\n\t\t\tif (this.showProgress) this.logger.printNewLine();\n\t\t}\n\t\tif (this.systemExitWhenFinished) {\n\t\t\tthis.logger.flush();\n\t\t\tthis.logger.close();\n\t\t\tSystem.exit(this.globalErrorsCount > 0 ? -1 : 0);\n\t\t}\n\t} catch (IllegalArgumentException e) {\n\t\tthis.logger.logException(e);\n\t\tif (this.systemExitWhenFinished) {\n\t\t\tthis.logger.flush();\n\t\t\tthis.logger.close();\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\treturn false;\n\t} catch (RuntimeException e) { // internal compiler failure\n\t\tthis.logger.logException(e);\n\t\tif (this.systemExitWhenFinished) {\n\t\t\tthis.logger.flush();\n\t\t\tthis.logger.close();\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\treturn false;\n\t} finally {\n\t\tthis.logger.flush();\n\t\tthis.logger.close();\n\t\tif (this.progress != null)\n\t\t\tthis.progress.done();\n\t}\n\tif (this.globalErrorsCount == 0 && (this.progress == null || !this.progress.isCanceled()))\n\t\treturn true;\n\treturn false;\n}\n\n/*\nDecode the command line arguments\n */\npublic void configure(String[] argv) {\n\n\tif ((argv == null) || (argv.length == 0)) {\n\t\tprintUsage();\n\t\treturn;\n\t}\n\n\tfinal int INSIDE_CLASSPATH_start = 1;\n\tfinal int INSIDE_DESTINATION_PATH = 3;\n\tfinal int INSIDE_TARGET = 4;\n\tfinal int INSIDE_LOG = 5;\n\tfinal int INSIDE_REPETITION = 6;\n\tfinal int INSIDE_SOURCE = 7;\n\tfinal int INSIDE_DEFAULT_ENCODING = 8;\n\tfinal int INSIDE_BOOTCLASSPATH_start = 9;\n\tfinal int INSIDE_MAX_PROBLEMS = 11;\n\tfinal int INSIDE_EXT_DIRS = 12;\n\tfinal int INSIDE_SOURCE_PATH_start = 13;\n\tfinal int INSIDE_ENDORSED_DIRS = 15;\n\tfinal int INSIDE_SOURCE_DIRECTORY_DESTINATION_PATH = 16;\n\tfinal int INSIDE_PROCESSOR_PATH_start = 17;\n\tfinal int INSIDE_PROCESSOR_start = 18;\n\tfinal int INSIDE_S_start = 19;\n\tfinal int INSIDE_CLASS_NAMES = 20;\n\n\tfinal int DEFAULT = 0;\n\tArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);\n\tString sourcepathClasspathArg = null;\n\tArrayList sourcepathClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);\n\tArrayList classpaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);\n\tArrayList extdirsClasspaths = null;\n\tArrayList endorsedDirClasspaths = null;\n\n\tint index = -1;\n\tint filesCount = 0;\n\tint classCount = 0;\n\tint argCount = argv.length;\n\tint mode = DEFAULT;\n\tthis.maxRepetition = 0;\n\tboolean printUsageRequired = false;\n\tString usageSection = null;\n\tboolean printVersionRequired = false;\n\n\tboolean didSpecifyDefaultEncoding = false;\n\tboolean didSpecifyDeprecation = false;\n\tboolean didSpecifyCompliance = false;\n\tboolean didSpecifyDisabledAnnotationProcessing = false;\n\n\tString customEncoding = null;\n\tString customDestinationPath = null;\n\tString currentSourceDirectory = null;\n\tString currentArg = Util.EMPTY_STRING;\n\n\t// expand the command line if necessary\n\tboolean needExpansion = false;\n\tloop: for (int i = 0; i < argCount; i++) {\n\t\t\tif (argv[i].startsWith("@")) { //$NON-NLS-1$\n\t\t\t\tneedExpansion = true;\n\t\t\t\tbreak loop;\n\t\t\t}\n\t}\n\n\tString[] newCommandLineArgs = null;\n\tif (needExpansion) {\n\t\tnewCommandLineArgs = new String[argCount];\n\t\tindex = 0;\n\t\tfor (int i = 0; i < argCount; i++) {\n\t\t\tString[] newArgs = null;\n\t\t\tString arg = argv[i].trim();\n\t\t\tif (arg.startsWith("@")) { //$NON-NLS-1$\n\t\t\t\ttry {\n\t\t\t\t\tLineNumberReader reader = new LineNumberReader(new StringReader(new String(Util.getFileCharContent(new File(arg.substring(1)), null))));\n\t\t\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\t\t\tString line;\n\t\t\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\t\t\tline = line.trim();\n\t\t\t\t\t\tif (!line.startsWith("#")) { //$NON-NLS-1$\n\t\t\t\t\t\t\tbuffer.append(line).append(" "); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnewArgs = tokenize(buffer.toString());\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\tthis.bind("configure.invalidexpansionargumentname", arg)); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newArgs != null) {\n\t\t\t\tint newCommandLineArgsLength = newCommandLineArgs.length;\n\t\t\t\tint newArgsLength = newArgs.length;\n\t\t\t\tSystem.arraycopy(newCommandLineArgs, 0, (newCommandLineArgs = new String[newCommandLineArgsLength + newArgsLength - 1]), 0, index);\n\t\t\t\tSystem	Divergent Change	Shotgun Surgery\n	God Class\n	Long Method	Main.java	9aa0a177fe1900bc8c86e3295a20f74c	\N	Oocorre quando uma classe é alterada de maneiras diferentes por diferentes razões.	WMC (Weighted Method per Class), NCC (Number Concerns per Component), LCOM (Lack of Cohesion in Methods)	Refatoração sugerida: Extract Class	t	3
36	Identifique o Bad Smell na classe abaixo	/* Copyright (c) 2001-2005, The HSQL Development Group\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * Neither the name of the HSQL Development Group nor the names of its\n * contributors may be used to endorse or promote products derived from this\n * software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG,\n * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\npackage org.hsqldb;\n\nimport org.hsqldb.HsqlNameManager.HsqlName;\nimport org.hsqldb.lib.HsqlArrayList;\nimport org.hsqldb.lib.Iterator;\n\n// fredt@users 20020420 - patch523880 by leptipre@users - VIEW support - modified\n// fredt@users 20031227 - remimplementated as compiled query\n\n/**\n * Represents an SQL VIEW based on a SELECT statement.\n *\n * @author leptipre@users\n * @author fredt@users\n * @version 1.8.0\n * @since 1.7.0\n */\nclass View extends Table {\n\n    Select             viewSelect;\n    SubQuery           viewSubQuery;\n    private String     statement;\n    private HsqlName[] colList;\n\n    /** schema at the time of compilation */\n    HsqlName compileTimeSchema;\n\n    /**\n     * List of subqueries in this view in order of materialization. Last\n     * element is the view itself.\n     */\n    SubQuery[] viewSubqueries;\n\n    /**\n     * Constructor.\n     * @param Session\n     * @param db database\n     * @param name HsqlName of the view\n     * @param definition SELECT statement of the view\n     * @param columns array of HsqlName column names\n     * @throws HsqlException\n     */\n    View(Session session, Database db, HsqlName name, String definition,\n            HsqlName[] columns) throws HsqlException {\n\n        super(db, name, VIEW);\n\n        isReadOnly        = true;\n        colList           = columns;\n        statement         = trimStatement(definition);\n        compileTimeSchema = session.getSchemaHsqlName(null);\n\n        compile(session);\n        replaceAsterisksInStatement();\n\n        HsqlName[] schemas = getSchemas();\n\n        for (int i = 0; i < schemas.length; i++) {\n            if (db.schemaManager.isSystemSchema(schemas[i])) {\n                continue;\n            }\n\n            if (!schemas[i].equals(name.schema)) {\n                throw Trace.error(Trace.INVALID_SCHEMA_NAME_NO_SUBCLASS);\n            }\n        }\n    }\n\n    /**\n     * Returns the SELECT statement trimmed of any terminating SQL\n     * whitespace, separators or SQL comments.\n     */\n    static String trimStatement(String s) throws HsqlException {\n\n        int       position;\n        String    str;\n        Tokenizer tokenizer = new Tokenizer(s);\n\n        // fredt@users - this establishes the end of the actual statement\n        // to get rid of any end semicolon or comment line after the end\n        // of statement\n        do {\n            position = tokenizer.getPosition();\n            str      = tokenizer.getString();\n        } while (str.length() != 0 || tokenizer.wasValue());\n\n        return s.substring(0, position).trim();\n    }\n\n    /**\n     * Compiles the SELECT statement and sets up the columns.\n     */\n    void compile(Session session) throws HsqlException {\n\n        // create the working table\n        Parser p = new Parser(session, this.database,\n                              new Tokenizer(statement));\n\n        p.setCompilingView();\n\n        int brackets = p.parseOpenBracketsSelect();\n\n        viewSubQuery = p.parseSubquery(brackets, colList, true,\n                                       Expression.VIEW);\n\n        p.setAsView(this);\n\n        viewSubqueries = p.getSortedSubqueries();\n        viewSelect     = viewSubQuery.select;\n\n        viewSelect.prepareResult(session);\n\n        Result.ResultMetaData metadata = viewSelect.resultMetaData;\n        int                   columns  = viewSelect.iResultLen;\n\n        if (super.columnCount == 0) {\n\n            // do not add columns at recompile time\n            super.addColumns(metadata, columns);\n        }\n    }\n\n    /**\n     * Returns the SELECT statement for the view.\n     */\n    String getStatement() {\n        return statement;\n    }\n\n    /**\n     *  is a private helper for replaceAsterisksInStatement, to avoid some code duplication\n     */\n    private void collectAsteriskPos(final Select select,\n                                    HsqlArrayList asteriskPositions) {\n\n        if (select.asteriskPositions == null) {\n            return;\n        }\n\n        Iterator asterisks = select.asteriskPositions.keySet().iterator();\n\n        while (asterisks.hasNext()) {\n            int pos = asterisks.nextInt();\n\n            asteriskPositions.set(pos, select.asteriskPositions.get(pos));\n        }\n    }\n\n    /**\n     *  replaces all asterisks in our statement with the actual column list\n     *\n     *  This way, we ensure what is required by the standard: a view returns a result\n     *  which reflects the structure of the underlying tables at the *time of the definition\n     *  of the view.\n     */\n    private void replaceAsterisksInStatement() {\n\n        HsqlArrayList asteriskPositions = new HsqlArrayList();\n\n        asteriskPositions.setSize(statement.length());\n\n        // asterisk positions in sub queries\n        for (int i = 0; i < viewSubqueries.length; ++i) {\n\n            // collect the occurances of asterisks in the statement\n            Select subSelect = viewSubqueries[i].select;\n\n            collectAsteriskPos(subSelect, asteriskPositions);\n\n            // the same for all (possible) UNION SELECTs of the sub select\n            if (subSelect.unionArray != null) {\n\n                // start with index 1, not 0 - the first select is the one already covered by subSelect\n                for (int u = 1; u < subSelect.unionArray.length; ++u) {\n                    collectAsteriskPos(subSelect.unionArray[u],\n                                       asteriskPositions);\n                }\n            }\n        }\n\n        StringBuffer expandedStatement = new StringBuffer(statement);\n\n        for (int pos = asteriskPositions.size() - 1; pos >= 0; --pos) {\n            String colList = (String) asteriskPositions.get(pos);\n\n            if (colList == null) {\n                continue;\n            }\n\n            expandedStatement.replace(pos,\n                                      expandedStatement.indexOf("*", pos) + 1,\n                                      colList);\n        }\n\n        statement = expandedStatement.toString();\n    }\n\n    /**\n     * Overridden to disable SET TABLE READONLY DDL for View objects.\n     */\n    void setDataReadOnly(boolean value) throws HsqlException {\n        throw Trace.error(Trace.NOT_A_TABLE);\n    }\n\n    /**\n     * Returns list of schemas\n     */\n    HsqlName[] getSchemas() {\n\n        HsqlArrayList list = new HsqlArrayList();\n\n        for (int i = 0; i < viewSubqueries.length; i++) {\n            Select select = viewSubqueries[i].select;\n\n            for (; select != null; select = select.unionSelect) {\n                TableFilter[] tfilter = select.tFilter;\n\n                for (int j = 0; j < tfilter.length; j++) {\n                    list.add(tfilter[j].filterTable.tableName.schema);\n                }\n            }\n        }\n\n        return (HsqlName[]) list.toArray(new HsqlName[list.size()]);\n    }\n\n    boolean hasView(View view) {\n\n        if (view == this) {\n            return false;\n        }\n\n        for (int i = 0; i < viewSubqueries.length; i++) {\n            if (viewSubqueries[i].view == view) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the view references any column of the named table.\n     */\n    boolean hasTable(Table table) {\n\n        for (int i = 0; i < viewSubqueries.length; i++) {\n            Select select = viewSubqueries[i].select;\n\n            for (; select != null; select = select.unionSelect) {\n                TableFilter[] tfilter = select.tFilter;\n\n                for (int j = 0; j < tfilter.length; j++) {\n                    if (table.equals(tfilter[j].filterTable.tableName)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the view references the named column of the named table,\n     * otherwise false.\n     */\n    boolean hasColumn(Table table, String colname) {\n\n        if (hasTable(table)) {\n            Expression.Collector coll = new Expression.Collector();\n\n            coll.addAll(viewSubqueries[viewSubqueries.length - 1].select,\n                        Expression.COLUMN);\n\n            Iterator it = coll.iterator();\n\n            for (; it.hasNext(); ) {\n                Expression e = (Expression) it.next();\n\n                if (colname.equals(e.getBaseColumnName())\n                        && table.equals(e.getTableHsqlName())) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the view references the named SEQUENCE,\n     * otherwise false.\n     */\n    boolean hasSequence(NumberSequence sequence) {\n\n        Expression.Collector coll = new Expression.Collector();\n\n        coll.addAll(viewSubqueries[viewSubqueries.length - 1].select,\n                    Expression.SEQUENCE);\n\n        Iterator it = coll.iterator();\n\n        for (; it.hasNext(); ) {\n            Expression e = (Expression) it.next();\n\n            if (e.valueData == sequence) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}	God Class	Shotgun Surgery\n	Feature Envy\n	Long Method\n	View.java	a11020143047a5100ce24af8367610aa	\N	Uma classe implementando várias responsabilidades, tendo um grande número de atributos, operações e dependências com classes de dados 	LOC (Lines of Code), WMC (Weighted Method per Class), CBO (Coupling Betwenn Object Classes); LCOM (Lack of Cohesion in Methods)	Refatoração sugerida:Extract Subclass	t	2
37	Identifique o Bad Smell na classe abaixo	package org.apache.tools.ant.util;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Vector;\n\nimport org.apache.tools.ant.taskdefs.condition.Os;\n\n\npublic final class JavaEnvUtils {\n\n    private JavaEnvUtils() {\n    }\n\n    /// Are we on a DOS-based system ///\n    private static final boolean IS_DOS = Os.isFamily("dos");\n    /// Are we on Novell NetWare ///\n    private static final boolean IS_NETWARE = Os.isName("netware");\n    /// Are we on AIX ///\n    private static final boolean IS_AIX = Os.isName("aix");\n\n    /// shortcut for System.getProperty("java.home") ///\n    private static final String JAVA_HOME = System.getProperty("java.home");\n\n    /// FileUtils instance for path normalization ///\n    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();\n\n    /// Version of currently running VM. ///\n    private static String javaVersion;\n\n    /// floating version of the JVM ///\n    private static int javaVersionNumber;\n\n    /// Version constant for Java 1.0 ///\n    public static final String JAVA_1_0 = "1.0";\n    /// Number Version constant for Java 1.0 ///\n    public static final int VERSION_1_0 = 10;\n\n    /// Version constant for Java 1.1 ///\n    public static final String JAVA_1_1 = "1.1";\n    /// Number Version constant for Java 1.1 ///\n    public static final int VERSION_1_1 = 11;\n\n    /// Version constant for Java 1.2 ///\n    public static final String JAVA_1_2 = "1.2";\n    /// Number Version constant for Java 1.2 ///\n    public static final int VERSION_1_2 = 12;\n\n    /// Version constant for Java 1.3 ///\n    public static final String JAVA_1_3 = "1.3";\n    /// Number Version constant for Java 1.3 ///\n    public static final int VERSION_1_3 = 13;\n\n    /// Version constant for Java 1.4 ///\n    public static final String JAVA_1_4 = "1.4";\n    /// Number Version constant for Java 1.4 ///\n    public static final int VERSION_1_4 = 14;\n\n    /// Version constant for Java 1.5 ///\n    public static final String JAVA_1_5 = "1.5";\n    /// Number Version constant for Java 1.5 ///\n    public static final int VERSION_1_5 = 15;\n\n    /// Version constant for Java 1.6 ///\n    public static final String JAVA_1_6 = "1.6";\n    /// Number Version constant for Java 1.6 ///\n    public static final int VERSION_1_6 = 16;\n\n    /// Version constant for Java 1.7 ///\n    public static final String JAVA_1_7 = "1.7";\n    /// Number Version constant for Java 1.7 ///\n    public static final int VERSION_1_7 = 17;\n\n    /// Version constant for Java 1.8 ///\n    public static final String JAVA_1_8 = "1.8";\n    /// Number Version constant for Java 1.8 ///\n    public static final int VERSION_1_8 = 18;\n\n    /// Version constant for Java 1.9 ///\n    public static final String JAVA_1_9 = "1.9";\n    /// Number Version constant for Java 1.9 ///\n    public static final int VERSION_1_9 = 19;\n\n    /// Whether this is the Kaffe VM ///\n    private static boolean kaffeDetected;\n\n    /// Wheter this is a GNU Classpath based VM ///\n    private static boolean classpathDetected;\n\n    /// Whether this is the GNU VM (gcj/gij) ///\n    private static boolean gijDetected;\n\n    /// Whether this is Apache Harmony ///\n    private static boolean harmonyDetected;\n\n    /// array of packages in the runtime ///\n    private static Vector<String> jrePackages;\n\n\n    static {\n\n        // Determine the Java version by looking at available classes\n        // java.net.Proxy was introduced in JDK 1.5\n        // java.lang.CharSequence was introduced in JDK 1.4\n        // java.lang.StrictMath was introduced in JDK 1.3\n        // java.lang.ThreadLocal was introduced in JDK 1.2\n        // java.lang.Void was introduced in JDK 1.1\n        // Count up version until a NoClassDefFoundError ends the try\n\n        try {\n            javaVersion = JAVA_1_0;\n            javaVersionNumber = VERSION_1_0;\n            Class.forName("java.lang.Void");\n            javaVersion = JAVA_1_1;\n            javaVersionNumber++;\n            Class.forName("java.lang.ThreadLocal");\n            javaVersion = JAVA_1_2;\n            javaVersionNumber++;\n            Class.forName("java.lang.StrictMath");\n            javaVersion = JAVA_1_3;\n            javaVersionNumber++;\n            Class.forName("java.lang.CharSequence");\n            javaVersion = JAVA_1_4;\n            javaVersionNumber++;\n            Class.forName("java.net.Proxy");\n            javaVersion = JAVA_1_5;\n            javaVersionNumber++;\n            Class.forName("java.net.CookieStore");\n            javaVersion = JAVA_1_6;\n            javaVersionNumber++;\n            Class.forName("java.nio.file.FileSystem");\n            javaVersion = JAVA_1_7;\n            javaVersionNumber++;\n            Class.forName("java.lang.reflect.Executable");\n            javaVersion = JAVA_1_8;\n            javaVersionNumber++;\n            checkForJava9();\n            javaVersion = JAVA_1_9;\n            javaVersionNumber++;\n        } catch (Throwable t) {\n            // swallow as we've hit the max class version that\n            // we have\n        }\n        kaffeDetected = false;\n        try {\n            Class.forName("kaffe.util.NotImplemented");\n            kaffeDetected = true;\n        } catch (Throwable t) {\n            // swallow as this simply doesn't seem to be Kaffe\n        }\n        classpathDetected = false;\n        try {\n            Class.forName("gnu.classpath.Configuration");\n            classpathDetected = true;\n        } catch (Throwable t) {\n            // swallow as this simply doesn't seem to be GNU classpath based.\n        }\n        gijDetected = false;\n        try {\n            Class.forName("gnu.gcj.Core");\n            gijDetected = true;\n        } catch (Throwable t) {\n            // swallow as this simply doesn't seem to be gcj/gij\n        }\n        harmonyDetected = false;\n        try {\n            Class.forName("org.apache.harmony.luni.util.Base64");\n            harmonyDetected = true;\n        } catch (Throwable t) {\n            // swallow as this simply doesn't seem to be Apache Harmony\n        }\n    }\n\n    ///\n     // Returns the version of Java this class is running under.\n     // @return the version of Java as a String, e.g. "1.6"\n     ///\n    public static String getJavaVersion() {\n        return javaVersion;\n    }\n\n\n    ///\n     // Checks for a give Java 9 runtime.\n     // At the time of writing the actual version of the JDK was 1.9.0_b06.\n     // Searching for new classes gave no hits, so we need another aproach.\n     // Searching for changes (grep -r -i -n "@since 1.9" .) in the sources gave\n     // only one hit: a new constant in the class SourceVersion.\n     // So we have to check that ...\n     //\n     // @throws Exception if we can't load the class or don't find the new constant.\n     //    This is the behavior when searching for new features on older versions.\n     // @since Ant 1.9.4\n     ///\n    private static void checkForJava9() throws Exception {\n    \tClass<?> clazz = Class.forName("javax.lang.model.SourceVersion");\n    \tclazz.getDeclaredField("RELEASE_9");\n    }\n\n\n    ///\n     // Returns the version of Java this class is running under.\n     // This number can be used for comparisons; it will always be\n     // @return the version of Java as a number 10x the major/minor,\n     // e.g Java1.5 has a value of 15\n     ///\n    public static int getJavaVersionNumber() {\n        return javaVersionNumber;\n    }\n\n    ///\n     // Compares the current Java version to the passed in String -\n     // assumes the argument is one of the constants defined in this\n     // class.\n     // Note that Ant now requires JDK 1.5+ so {@link #JAVA_1_0} through\n     // {@link #JAVA_1_4} need no longer be tested for.\n     // @param version the version to check against the current version.\n     // @return true if the version of Java is the same as the given version.\n     // @since Ant 1.5\n     ///\n    public static boolean isJavaVersion(String version) {\n        return javaVersion.equals(version);\n    }\n\n    ///\n     // Compares the current Java version to the passed in String -\n     // assumes the argument is one of the constants defined in this\n     // class.\n     // Note that Ant now requires JDK 1.5+ so {@link #JAVA_1_0} through\n     // {@link #JAVA_1_4} need no longer be tested for.\n     // @param version the version to check against the current version.\n     // @return true if the version of Java is the same or higher than the\n     // given version.\n     // @since Ant 1.7\n     ///\n    public static boolean isAtLeastJavaVersion(String version) {\n        return javaVersion.compareTo(version) >= 0;\n    }\n\n    ///\n     // Checks whether the current Java VM is Kaffe.\n     // @return true if the current Java VM is Kaffe.\n     // @since Ant 1.6.3\n     // @see <a href="http://www.kaffe.org/">http://www.kaffe.org/</a>\n     ///\n    public static boolean isKaffe() {\n        return kaffeDetected;\n    }\n\n    ///\n     // Checks whether the current Java VM is GNU Classpath\n     // @since Ant 1.9.1\n     // @return true if the version of Java is GNU Classpath\n     ///\n    public static boolean isClasspathBased() {\n        return classpathDetected;\n    }\n\n    ///\n     // Checks whether the current Java VM is the GNU interpreter gij\n     // or we are running in a gcj precompiled binary.\n     // @since Ant 1.8.2\n     // @return true if the current Java VM is gcj/gij.\n     ///\n    public static boolean isGij() {\n        return gijDetected;\n    }\n\n    ///\n     // Checks whether the current VM is Apache Harmony.\n     // @since Ant 1.8.2\n     // @return true if the current VM is Apache Harmony.\n     ///\n    public static boolean isApacheHarmony() {\n        return harmonyDetected;\n    }\n\n    ///\n     // Finds an executable that is part of a JRE installation based on\n     // the java.home system property.\n     //\n     // <p><code>java</code>, <code>keytool</code>,\n     // <code>policytool</code>, <code>orbd</code>, <code>rmid</code>,\n     // <code>rmiregistry</code>, <code>servertool</code> and\n     // <code>tnameserv</code> are JRE executables on Sun based\n     // JRE's.</p>\n     //\n     // <p>You typically find them in <code>JAVA_HOME/jre/bin</code> if\n     // <code>JAVA_HOME</code> points to your JDK installation.  JDK\n     // &lt; 1.2 has them in the same directory as the JDK\n     // executables.</p>\n     // @param command the java executable to find.\n     // @return the path to the command.\n     // @since Ant 1.5\n     ///\n    public static String getJreExecutable(String command) {\n        if (IS_NETWARE) {\n            // Extrapolating from:\n            // "NetWare may have a "java" in that directory, but 99% of\n            // the time, you don't want to execute it" -- Jeff Tulley\n            // <JTULLEY@novell.com>\n            return command;\n        }\n\n        File jExecutable = null;\n\n        if (IS_AIX) {\n            // On IBM's JDK 1.2 the directory layout is different, 1.3 follows\n            // Sun's layout.\n            jExecutable = findInDir(JAVA_HOME + "/sh", command);\n        }\n\n        if (jExecutable == null) {\n            jExecutable = findInDir(JAVA_HOME + "/bin", command);\n        }\n\n        if (jExecutable != null) {\n            return jExecutable.getAbsolutePath();\n        } else {\n            // Unfortunately on Windows java.home doesn't always refer\n            // to the correct location, so we need to fall back to\n            // assuming java is somewhere on the PATH.\n            return addExtension(command);\n        }\n    }\n\n    ///\n     // Finds an executable that is part of a JDK installation based on\n     // the java.home system property.\n     //\n     // <p>You typically find them in <code>JAVA_HOME/bin</code> if\n     // <code>JAVA_HOME</code> points to your JDK installation.</p>\n     // @param command the java executable to find.\n     // @return the path to the command.\n     // @since Ant 1.5\n     ///\n    public static String getJdkExecutable(String command) {\n        if (IS_NETWARE) {\n            // Extrapolating from:\n            // "NetWare may have a "java" in that directory, but 99% of\n            // the time, you don't want to execute it" -- Jeff Tulley\n            // <JTULLEY@novell.com>\n            return command;\n        }\n\n        File jExecutable = null;\n\n        if (IS_AIX) {\n            // On IBM's JDK 1.2 the directory layout is different, 1.3 follows\n            // Sun's layout.\n            jExecutable = findInDir(JAVA_HOME + "/../sh", command);\n        }\n\n        if (jExecutable == null) {\n            jExecutable = findInDir(JAVA_HOME + "/../bin", command);\n        }\n\n        if (jExecutable != null) {\n            return jExecutable.getAbsolutePath();\n        } else {\n            // fall back to JRE bin directory, also catches JDK 1.0 and 1.1\n            // where java.home points to the root of the JDK and Mac OS X where\n            // the whole directory layout is different from Sun's\n            // and also catches JDK 1.9 (and probably later) which\n            // merged JDK and JRE dirs\n            return getJreExecutable(command);\n        }\n    }\n\n    ///\n     // Adds a system specific extension to the name of an executable.\n     //\n     // @since Ant 1.5\n     ///\n    private static String addExtension(String command) {\n        // This is the most common extension case - exe for windows and OS/2,\n        // nothing for //nix.\n        return command + (IS_DOS ? ".exe" : "");\n    }\n\n    ///\n     // Look for an executable in a given directory.\n     //\n     // @return null if the executable cannot be found.\n     ///\n    private static File findInDir(String dirName, String commandName) {\n        File dir = FILE_UTILS.normalize(dirName);\n        File executable = null;\n        if (dir.exists()) {\n            executable = new File(dir, addExtension(commandName));\n            if (!executable.exists()) {\n                executable = null;\n            }\n        }\n        return executable;\n    }\n\n    ///\n     // demand creation of the package list.\n     // When you add a new package, add a new test below.\n     ///\n\n    private static void buildJrePackages() {\n        jrePackages = new Vector<String>();\n        switch(javaVersionNumber) {\n            case VERSION_1_9:\n            case VERSION_1_8:\n            case VERSION_1_7:\n            case VERSION_1_6:\n            case VERSION_1_5:\n                //In Java1.5, the apache stuff moved.\n                jrePackages.addElement("com.sun.org.apache");\n                //fall through.\n            case VERSION_1_4:\n                if (javaVersionNumber == VERSION_1_4) {\n                    jrePackages.addElement("org.apache.crimson");\n                    jrePackages.addElement("org.apache.xalan");\n                    jrePackages.addElement("org.apache.xml");\n                    jrePackages.addElement("org.apache.xpath");\n                }\n                jrePackages.addElement("org.ietf.jgss");\n                jrePackages.addElement("org.w3c.dom");\n                jrePackages.addElement("org.xml.sax");\n                // fall through\n            case VERSION_1_3:\n                jrePackages.addElement("org.omg");\n                jrePackages.addElement("com.sun.corba");\n                jrePackages.addElement("com.sun.jndi");\n                jrePackages.addElement("com.sun.media");\n                jrePackages.addElement("com.sun.naming");\n                jrePackages.addElement("com.sun.org.omg");\n                jrePackages.addElement("com.sun.rmi");\n                jrePackages.addElement("sunw.io");\n                jrePackages.addElement("sunw.util");\n                // fall through\n            case VERSION_1_2:\n                jrePackages.addElement("com.sun.java");\n                jrePackages.addElement("com.sun.image");\n                // are there any here that we forgot?\n                // fall through\n            case VERSION_1_1:\n            default:\n                //things like sun.reflection, sun.misc, sun.net\n                jrePackages.addElement("sun");\n                jrePackages.addElement("java");\n                jrePackages.addElement("javax");\n                break;\n        }\n    }\n\n    ///\n     // Testing helper method; kept here for unification of changes.\n     // @return a list of test classes depending on the java version.\n     ///\n    public static Vector<String> getJrePackageTestCases() {\n        Vector<String> tests = new Vector<String>();\n        tests.addElement("java.lang.Object");\n        switch(javaVersionNumber) {\n            case VERSION_1_9:\n            case VERSION_1_8:\n            case VERSION_1_7:\n            case VERSION_1_6:\n            case VERSION_1_5:\n                tests.addElement(\n                    "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl ");\n                // Fall through\n            case VERSION_1_4:\n                tests.addElement("sun.audio.AudioPlayer");\n                if (javaVersionNumber == VERSION_1_4) {\n                \t// only for 1.4, not for higher versions which fall through\n                    tests.addElement("org.apache.crimson.parser.ContentModel");\n                    tests.addElement("org.apache.xalan.processor.ProcessorImport");\n                    tests.addElement("org.apache.xml.utils.URI");\n                    tests.addElement("org.apache.xpath.XPathFactory");\n                }\n                tests.addElement("org.ietf.jgss.Oid");\n                tests.addElement("org.w3c.dom.Attr");\n                tests.addElement("org.xml.sax.XMLReader");\n                // fall through\n            case VERSION_1_3:\n                tests.addElement("org.omg.CORBA.Any");\n                tests.addElement("com.sun.corba.se.internal.corba.AnyImpl");\n                tests.addElement("com.sun.jndi.ldap.LdapURL");\n                tests.addElement("com.sun.media.sound.Printer");\n                tests.addElement("com.sun.naming.internal.VersionHelper");\n                tests.addElement("com.sun.org.omg.CORBA.Initializer");\n                tests.addElement("sunw.io.Serializable");\n                tests.addElement("sunw.util.EventListener");\n                // fall through\n            case VERSION_1_2:\n                tests.addElement("javax.accessibility.Accessible");\n                tests.addElement("sun.misc.BASE64Encoder");\n                tests.addElement("com.sun.image.codec.jpeg.JPEGCodec");\n                // fall through\n            case VERSION_1_1:\n            default:\n                //things like sun.reflection, sun.misc, sun.net\n                tests.addElement("sun.reflect.SerializationConstructorAccessorImpl");\n                tests.addElement("sun.net.www.http.HttpClient");\n                tests.addElement("sun.audio.AudioPlayer");\n                break;\n        }\n        return tests;\n    }\n    ///\n     // get a vector of strings of packages built into\n     // that platforms runtime jar(s)\n     // @return list of packages.\n     ///\n    public static Vector<String> getJrePackages() {\n        if (jrePackages == null) {\n            buildJrePackages();\n        }\n        return jrePackages;\n    }\n\n    ///\n     //\n     // Writes the command into a temporary DCL script and returns the\n     // corresponding File object.\n     // It is the job of the caller to delete the file on exit.\n     // @param cmd the command.\n     // @return the file containing the command.\n     // @throws IOException if there is an error writing to the file.\n     ///\n    public static File createVmsJavaOptionFile(String[] cmd)\n            throws IOException {\n        File script = FILE_UTILS.createTempFile("ANT", ".JAVA_OPTS", null, false, true);\n        BufferedWriter out = null;\n        try {\n            out = new BufferedWriter(new FileWriter(script));\n            for (int i = 0; i < cmd.length; i++) {\n                out.write(cmd[i]);\n                out.newLine();\n            }\n        } finally {\n            FileUtils.close(out);\n        }\n        return script;\n    }\n\n    ///\n     // Return the value of ${java.home}\n     // @return the java home value.\n     ///\n    public static String getJavaHome() {\n        return JAVA_HOME;\n    }\n}	Feature Envy	Divergent Change\n	God Class\n	Shotgun Surgery\n	JavaEnvUtils.java	84b29496676a8fca072ecfe34bc8f705	\N	Um método está mais interessado em outra classe do que aquela em que está realmente	NOA (Number of Operations Added), LOCC ((Lines of Concern Code), LCOM (Lack of Cohesion in Methods) 	Refatoração sugerida:Move Method	t	2
38	Identifique o Bad Smell na classe abaixo	/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.ddmlib.testrunner;\n\nimport com.android.ddmlib.IShellOutputReceiver;\nimport com.android.ddmlib.Log;\nimport com.android.ddmlib.MultiLineReceiver;\n\n/**\n * Parses the 'raw output mode' results of an instrumentation test run from shell and informs a \n * ITestRunListener of the results.\n * \n * \nExpects the following output:\n * \n * \n\nIf fatal error occurred when attempted to run the tests:\n * \n\n * INSTRUMENTATION_STATUS: Error=error Message\n * INSTRUMENTATION_FAILED: \n * \n\n * \nor\n * \n\n * INSTRUMENTATION_RESULT: shortMsg=error Message\n * \n\n * \n * \nOtherwise, expect a series of test results, each one containing a set of status key/value\n * pairs, delimited by a start(1)/pass(0)/fail(-2)/error(-1) status code result. At end of test \n * run, expects that the elapsed test time in seconds will be displayed  \n * \n * \n\nFor example:\n * \n\n * INSTRUMENTATION_STATUS_CODE: 1\n * INSTRUMENTATION_STATUS: class=com.foo.FooTest\n * INSTRUMENTATION_STATUS: test=testFoo\n * INSTRUMENTATION_STATUS: numtests=2\n * INSTRUMENTATION_STATUS: stack=com.foo.FooTest#testFoo:312\n *    com.foo.X\n * INSTRUMENTATION_STATUS_CODE: -2   \n * ... \n * \n * Time: X\n * \n\n * \nNote that the "value" portion of the key-value pair may wrap over several text lines\n */\npublic class InstrumentationResultParser extends MultiLineReceiver {\n    \n    /** Relevant test status keys. */\n    private static class StatusKeys {\n        private static final String TEST = "test";\n        private static final String CLASS = "class";\n        private static final String STACK = "stack";\n        private static final String NUMTESTS = "numtests";\n        private static final String ERROR = "Error";\n        private static final String SHORTMSG = "shortMsg";\n    }\n    \n    /** Test result status codes. */\n    private static class StatusCodes {\n        private static final int FAILURE = -2;\n        private static final int START = 1;\n        private static final int ERROR = -1;\n        private static final int OK = 0;\n    }\n\n    /** Prefixes used to identify output. */\n    private static class Prefixes {\n        private static final String STATUS = "INSTRUMENTATION_STATUS: ";\n        private static final String STATUS_CODE = "INSTRUMENTATION_STATUS_CODE: ";\n        private static final String STATUS_FAILED = "INSTRUMENTATION_FAILED: ";\n        private static final String CODE = "INSTRUMENTATION_CODE: ";\n        private static final String RESULT = "INSTRUMENTATION_RESULT: ";\n        private static final String TIME_REPORT = "Time: ";\n    }\n    \n    private final ITestRunListener mTestListener;\n\n    /** \n     * Test result data\n     */\n    private static class TestResult {\n        private Integer mCode = null;\n        private String mTestName = null;\n        private String mTestClass = null;\n        private String mStackTrace = null;\n        private Integer mNumTests = null;\n        \n        /** Returns true if all expected values have been parsed */\n        boolean isComplete() {\n            return mCode != null && mTestName != null && mTestClass != null;\n        }\n        \n        /** Provides a more user readable string for TestResult, if possible */\n        @Override\n        public String toString() {\n            StringBuilder output = new StringBuilder();\n            if (mTestClass != null ) {\n                output.append(mTestClass);\n                output.append('#');\n            }    \n            if (mTestName != null) {\n                output.append(mTestName);\n            }\n            if (output.length() > 0) {\n                return output.toString();\n            }    \n            return "unknown result";\n        }\n    }\n    \n    /** Stores the status values for the test result currently being parsed */\n    private TestResult mCurrentTestResult = null;\n    \n    /** Stores the current "key" portion of the status key-value being parsed. */\n    private String mCurrentKey = null;\n    \n    /** Stores the current "value" portion of the status key-value being parsed. */\n    private StringBuilder mCurrentValue = null;\n    \n    /** True if start of test has already been reported to listener. */\n    private boolean mTestStartReported = false;\n    \n    /** The elapsed time of the test run, in milliseconds. */\n    private long mTestTime = 0;\n    \n    /** True if current test run has been canceled by user. */\n    private boolean mIsCancelled = false;\n    \n    private static final String LOG_TAG = "InstrumentationResultParser";\n    \n    /**\n     * Creates the InstrumentationResultParser.\n     * \n     * @param listener informed of test results as the tests are executing\n     */\n    public InstrumentationResultParser(ITestRunListener listener) {\n        mTestListener = listener;\n    }\n    \n    /**\n     * Processes the instrumentation test output from shell.\n     * \n     * @see MultiLineReceiver#processNewLines\n     */\n    @Override\n    public void processNewLines(String[] lines) {\n        for (String line : lines) {\n            parse(line);\n            // in verbose mode, dump all adb output to log\n            Log.v(LOG_TAG, line);\n        }\n    }\n    \n    /**\n     * Parse an individual output line. Expects a line that is one of:\n     * \n\n\n     * \n \n     * The start of a new status line (starts with Prefixes.STATUS or Prefixes.STATUS_CODE), \n     * and thus there is a new key=value pair to parse, and the previous key-value pair is \n     * finished. \n     * \n\n     * \n\n     * A continuation of the previous status (the "value" portion of the key has wrapped\n     * to the next line).\n     * \n  \n     * \n A line reporting a fatal error in the test run (Prefixes.STATUS_FAILED) \n\n     * \n A line reporting the total elapsed time of the test run. (Prefixes.TIME_REPORT) \n  \n     * \n\n     *    \n     * @param line  Text output line\n     */\n    private void parse(String line) {\n        if (line.startsWith(Prefixes.STATUS_CODE)) {\n            // Previous status key-value has been collected. Store it.\n            submitCurrentKeyValue();\n            parseStatusCode(line);\n        } else if (line.startsWith(Prefixes.STATUS)) {\n            // Previous status key-value has been collected. Store it.\n            submitCurrentKeyValue();\n            parseKey(line, Prefixes.STATUS.length());\n        } else if (line.startsWith(Prefixes.RESULT)) {\n            // Previous status key-value has been collected. Store it.\n            submitCurrentKeyValue();\n            parseKey(line, Prefixes.RESULT.length());  \n        } else if (line.startsWith(Prefixes.STATUS_FAILED) || \n                   line.startsWith(Prefixes.CODE)) {\n            // Previous status key-value has been collected. Store it.\n            submitCurrentKeyValue();\n            // just ignore the remaining data on this line            \n        } else if (line.startsWith(Prefixes.TIME_REPORT)) {\n            parseTime(line, Prefixes.TIME_REPORT.length());\n        } else {\n            if (mCurrentValue != null) {\n                // this is a value that has wrapped to next line. \n                mCurrentValue.append("\\r\\n");\n                mCurrentValue.append(line);\n            } else {\n                Log.w(LOG_TAG, "unrecognized line " + line);\n            }\n        }\n    }\n    \n    /**\n     * Stores the currently parsed key-value pair into mCurrentTestInfo.\n     */\n    private void submitCurrentKeyValue() {\n        if (mCurrentKey != null && mCurrentValue != null) {\n            TestResult testInfo = getCurrentTestInfo();\n            String statusValue = mCurrentValue.toString();\n\n            if (mCurrentKey.equals(StatusKeys.CLASS)) {\n                testInfo.mTestClass = statusValue.trim();\n            } else if (mCurrentKey.equals(StatusKeys.TEST)) {\n                testInfo.mTestName = statusValue.trim();\n            } else if (mCurrentKey.equals(StatusKeys.NUMTESTS)) {\n                try {\n                    testInfo.mNumTests = Integer.parseInt(statusValue);\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, "Unexpected integer number of tests, received " + statusValue);\n                }\n            } else if (mCurrentKey.equals(StatusKeys.ERROR) || \n                    mCurrentKey.equals(StatusKeys.SHORTMSG)) {\n                // test run must have failed\n                handleTestRunFailed(statusValue); \n            } else if (mCurrentKey.equals(StatusKeys.STACK)) {\n                testInfo.mStackTrace = statusValue;\n            }\n\n            mCurrentKey = null;\n            mCurrentValue = null;\n        }\n    }\n    \n    private TestResult getCurrentTestInfo() {\n        if (mCurrentTestResult == null) {\n            mCurrentTestResult = new TestResult();\n        }\n        return mCurrentTestResult;\n    }\n    \n    private void clearCurrentTestInfo() {\n        mCurrentTestResult = null;\n    }\n    \n    /**\n     * Parses the key from the current line.\n     * Expects format of "key=value".\n     *  \n     * @param line full line of text to parse \n     * @param keyStartPos the starting position of the key in the given line\n     */\n    private void parseKey(String line, int keyStartPos) {\n        int endKeyPos = line.indexOf('=', keyStartPos);\n        if (endKeyPos != -1) {\n            mCurrentKey = line.substring(keyStartPos, endKeyPos).trim();\n            parseValue(line, endKeyPos + 1);\n        }\n    }\n    \n    /**\n     * Parses the start of a key=value pair.\n     *  \n     * @param line - full line of text to parse \n     * @param valueStartPos - the starting position of the value in the given line\n     */\n    private void parseValue(String line, int valueStartPos) {\n        mCurrentValue = new StringBuilder();\n        mCurrentValue.append(line.substring(valueStartPos));\n    }\n    \n    /**\n     * Parses out a status code result. \n     */\n    private void parseStatusCode(String line) {\n        String value = line.substring(Prefixes.STATUS_CODE.length()).trim();\n        TestResult testInfo = getCurrentTestInfo();\n        try {\n            testInfo.mCode = Integer.parseInt(value);    \n        } catch (NumberFormatException e) {\n            Log.e(LOG_TAG, "Expected integer status code, received: " + value);\n        }\n        \n        // this means we're done with current test result bundle\n        reportResult(testInfo);\n        clearCurrentTestInfo();\n    }\n    \n    /**\n     * Returns true if test run canceled.\n     * \n     * @see IShellOutputReceiver#isCancelled()\n     */\n    public boolean isCancelled() {\n        return mIsCancelled;\n    }\n    \n    /**\n     * Requests cancellation of test run.\n     */\n    public void cancel() {\n        mIsCancelled = true;\n    }\n    \n    /**\n     * Reports a test result to the test run listener. Must be called when a individual test\n     * result has been fully parsed. \n     * \n     * @param statusMap key-value status pairs of test result\n     */\n    private void reportResult(TestResult testInfo) {\n        if (!testInfo.isComplete()) {\n            Log.w(LOG_TAG, "invalid instrumentation status bundle " + testInfo.toString());\n            return;\n        }\n        reportTestRunStarted(testInfo);\n        TestIdentifier testId = new TestIdentifier(testInfo.mTestClass, testInfo.mTestName);\n\n        switch (testInfo.mCode) {\n            case StatusCodes.START:\n                mTestListener.testStarted(testId);\n                break;\n            case StatusCodes.FAILURE:\n                mTestListener.testFailed(ITestRunListener.TestFailure.FAILURE, testId, \n                        getTrace(testInfo));\n                mTestListener.testEnded(testId);\n                break;\n            case StatusCodes.ERROR:\n                mTestListener.testFailed(ITestRunListener.TestFailure.ERROR, testId, \n                        getTrace(testInfo));\n                mTestListener.testEnded(testId);\n                break;\n            case StatusCodes.OK:\n                mTestListener.testEnded(testId);\n                break;\n            default:\n                Log.e(LOG_TAG, "Unknown status code received: " + testInfo.mCode);\n                mTestListener.testEnded(testId);\n            break;\n        }\n\n    }\n    \n    /**\n     * Reports the start of a test run, and the total test count, if it has not been previously \n     * reported.\n     * \n     * @param testInfo current test status values\n     */\n    private void reportTestRunStarted(TestResult testInfo) {\n        // if start test run not reported yet\n        if (!mTestStartReported && testInfo.mNumTests != null) {\n            mTestListener.testRunStarted(testInfo.mNumTests);\n            mTestStartReported = true;\n        }\n    }\n    \n    /**\n     * Returns the stack trace of the current failed test, from the provided testInfo.\n     */\n    private String getTrace(TestResult testInfo) {\n        if (testInfo.mStackTrace != null) {\n            return testInfo.mStackTrace;    \n        } else {\n            Log.e(LOG_TAG, "Could not find stack trace for failed test ");\n            return new Throwable("Unknown failure").toString();\n        }\n    }\n    \n    /**\n     * Parses out and store the elapsed time.\n     */\n    private void parseTime(String line, int startPos) {\n        String timeString = line.substring(startPos);\n        try {\n            float timeSeconds = Float.parseFloat(timeString);\n            mTestTime = (long) (timeSeconds * 1000); \n        } catch (NumberFormatException e) {\n            Log.e(LOG_TAG, "Unexpected time format " + timeString);\n        }\n    }\n    \n    /**\n     * Process a instrumentation run failure\n     */\n    private void handleTestRunFailed(String errorMsg) {\n        mTestListener.testRunFailed(errorMsg == null ? "Unknown error" : errorMsg);\n    }\n    \n    /**\n     * Called by parent when adb session is complete. \n     */\n    @Override\n    public void done() {\n        super.done();\n        mTestListener.testRunEnded(mTestTime);\n    }\n}	God Class	Divergent Change\n	Shotgun Surgery\n	Feature Envy\n	InstrumentationResultParser.java	a11020143047a5100ce24af8367610aa	\N	Uma classe implementando várias responsabilidades, tendo um grande número de atributos, operações e dependências com classes de dados 	LOC (Lines of Code), WMC (Weighted Method per Class), CBO (Coupling Betwenn Object Classes); LCOM (Lack of Cohesion in Methods)	Refatoração sugerida:Extract Subclass	t	2
40	Identifique o Bad Smell na classe abaixo	// MongoResultSet.java\n\n/**\n *      Copyright (C) 2008 10gen Inc.\n *\n *   Licensed under the Apache License, Version 2.0 (the "License");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an "AS IS" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\npackage com.mongodb.jdbc;\n\nimport java.io.*;\nimport java.net.*;\nimport java.sql.*;\nimport java.util.*;\nimport java.sql.Date;\nimport java.math.*;\n\nimport com.mongodb.*;\n\npublic class MongoResultSet implements ResultSet {\n\n    MongoResultSet( DBCursor cursor ){\n        _cursor = cursor;\n        _fields.init( cursor.getKeysWanted() );\n    }\n\n    public void clearWarnings(){\n        // NO-OP\n    }\n\n    public void close(){\n        _closed = true;\n    }\n\n    public boolean isClosed(){\n        return _closed;\n    }\n\n    //  meta data\n    \n    public int getConcurrency(){\n        return CONCUR_READ_ONLY;\n    }\n\n    public int getType(){\n        return TYPE_FORWARD_ONLY;\n    }\n\n    public void setFetchDirection(int direction){\n        if ( direction == getFetchDirection() )\n            return;\n        throw new UnsupportedOperationException();\n    }\n\n    public int getFetchDirection(){\n        return 1;\n    }\n\n    public String getCursorName(){\n        return "MongoResultSet: " + _cursor.toString();\n    }\n\n    public ResultSetMetaData getMetaData(){\n        throw new UnsupportedOperationException();\n    }\n\n    public SQLWarning getWarnings(){\n        throw new UnsupportedOperationException();\n    }\n\n    public void setFetchSize(int rows){\n        throw new UnsupportedOperationException();        \n    }\n\n    public int getFetchSize(){\n        throw new UnsupportedOperationException();        \n    }\n\n\n    public Statement getStatement(){\n        throw new UnsupportedOperationException();       \n    }\n    \n    public int getHoldability(){\n        return ResultSet.HOLD_CURSORS_OVER_COMMIT;\n    }\n\n    // cursor moving methods\n\n    public boolean absolute(int row){\n        throw new UnsupportedOperationException();\n    }\n\n    public void afterLast(){\n        throw new UnsupportedOperationException();\n    }\n\n    public void beforeFirst(){\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean first(){\n        throw new UnsupportedOperationException();\n    }\n\n    public int getRow(){\n        return _row;\n    }\n\n    public boolean isAfterLast(){\n        throw new UnsupportedOperationException();\n    }\n    \n    public boolean isBeforeFirst(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean isFirst(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean isLast(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean last(){\n        throw new UnsupportedOperationException();\n    }\n    public void moveToCurrentRow(){\n        throw new UnsupportedOperationException();\n    }\n    public void moveToInsertRow(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean previous(){\n        throw new UnsupportedOperationException();\n    }\n    public void refreshRow(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean relative(int rows){\n        throw new UnsupportedOperationException();\n    }\n    public boolean rowDeleted(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean rowInserted(){\n        throw new UnsupportedOperationException();\n    }\n    public boolean rowUpdated(){\n        throw new UnsupportedOperationException();\n    }\n\n    // modifications\n\n    public void insertRow(){\n        throw new UnsupportedOperationException();\n    }\n    \n    public void cancelRowUpdates(){\n        throw new UnsupportedOperationException();\n    }\n    \n    public void deleteRow(){\n        throw new UnsupportedOperationException();        \n    }\n\n    public void updateRow(){\n        throw new UnsupportedOperationException();\n    }\n    \n    // field updates\n\n    public void updateArray(int columnIndex, Array x){\n        throw new UnsupportedOperationException(); }\n    public void updateArray(String columnName, Array x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateAsciiStream(int columnIndex, InputStream x, int length){\n        throw new UnsupportedOperationException(); }\n    public void updateAsciiStream(String columnName, InputStream x, int length){\n        throw new UnsupportedOperationException(); }\n    public void updateAsciiStream(int columnIndex, InputStream x, long length){\n        throw new UnsupportedOperationException(); }\n    public void updateAsciiStream(String columnName, InputStream x, long length){\n        throw new UnsupportedOperationException(); }\n    public void updateAsciiStream(int columnIndex, InputStream x ){\n        throw new UnsupportedOperationException(); }\n    public void updateAsciiStream(String columnName, InputStream x ){\n        throw new UnsupportedOperationException(); }\n\n    public void updateBigDecimal(int columnIndex, BigDecimal x){\n        throw new UnsupportedOperationException(); }\n    public void updateBigDecimal(String columnName, BigDecimal x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateBinaryStream(int columnIndex, InputStream x, int length){\n        throw new UnsupportedOperationException(); }\n    public void updateBinaryStream(String columnName, InputStream x, int length){\n        throw new UnsupportedOperationException(); }\n    public void updateBinaryStream(int columnIndex, InputStream x, long length){\n        throw new UnsupportedOperationException(); }\n    public void updateBinaryStream(String columnName, InputStream x, long length){\n        throw new UnsupportedOperationException(); }\n    public void updateBinaryStream(int columnIndex, InputStream x ){\n        throw new UnsupportedOperationException(); }\n    public void updateBinaryStream(String columnName, InputStream x ){\n        throw new UnsupportedOperationException(); }\n\n    public void updateBlob(int columnIndex, Blob x){\n        throw new UnsupportedOperationException(); }\n    public void updateBlob(String columnName, Blob x){\n        throw new UnsupportedOperationException(); }\n    public void updateBlob(int columnIndex, InputStream x){\n        throw new UnsupportedOperationException(); }\n    public void updateBlob(String columnName, InputStream x){\n        throw new UnsupportedOperationException(); }\n    public void updateBlob(int columnIndex, InputStream x, long l){\n        throw new UnsupportedOperationException(); }\n    public void updateBlob(String columnName, InputStream x, long l){\n        throw new UnsupportedOperationException(); }\n\n    public void updateBoolean(int columnIndex, boolean x){\n        throw new UnsupportedOperationException(); }\n    public void updateBoolean(String columnName, boolean x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateByte(int columnIndex, byte x){\n        throw new UnsupportedOperationException(); }\n    public void updateByte(String columnName, byte x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateBytes(int columnIndex, byte[] x){\n        throw new UnsupportedOperationException(); }\n    public void updateBytes(String columnName, byte[] x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateCharacterStream(int columnIndex, Reader x, int length){\n        throw new UnsupportedOperationException(); }\n    public void updateCharacterStream(String columnName, Reader reader, int length){\n        throw new UnsupportedOperationException(); }\n    public void updateCharacterStream(int columnIndex, Reader x, long  length){\n        throw new UnsupportedOperationException(); }\n    public void updateCharacterStream(String columnName, Reader reader, long length){\n        throw new UnsupportedOperationException(); }\n    public void updateCharacterStream(int columnIndex, Reader x ){\n        throw new UnsupportedOperationException(); }\n    public void updateCharacterStream(String columnName, Reader reader ){\n        throw new UnsupportedOperationException(); }\n\n    public void updateClob(int columnIndex, Clob x){\n        throw new UnsupportedOperationException(); }\n    public void updateClob(String columnName, Clob x){\n        throw new UnsupportedOperationException(); }\n    public void updateClob(int columnIndex, Reader x){\n        throw new UnsupportedOperationException(); }\n    public void updateClob(String columnName, Reader x){\n        throw new UnsupportedOperationException(); }\n    public void updateClob(int columnIndex, Reader x, long l ){\n        throw new UnsupportedOperationException(); }\n    public void updateClob(String columnName, Reader x, long l ){\n        throw new UnsupportedOperationException(); }\n\n    public void updateDate(int columnIndex, Date x){\n        throw new UnsupportedOperationException(); }\n    public void updateDate(String columnName, Date x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateDouble(int columnIndex, double x){\n        throw new UnsupportedOperationException(); }\n    public void updateDouble(String columnName, double x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateFloat(int columnIndex, float x){\n        throw new UnsupportedOperationException(); }\n    public void updateFloat(String columnName, float x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateInt(int columnIndex, int x){\n        throw new UnsupportedOperationException(); }\n    public void updateInt(String columnName, int x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateLong(int columnIndex, long x){\n        throw new UnsupportedOperationException(); }\n    public void updateLong(String columnName, long x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateNull(int columnIndex){\n        throw new UnsupportedOperationException(); }\n    public void updateNull(String columnName){\n        throw new UnsupportedOperationException(); }\n\n    public void updateObject(int columnIndex, Object x){\n        throw new UnsupportedOperationException(); }\n    public void updateObject(int columnIndex, Object x, int scale){\n        throw new UnsupportedOperationException(); }\n    public void updateObject(String columnName, Object x){\n        throw new UnsupportedOperationException(); }\n    public void updateObject(String columnName, Object x, int scale){\n        throw new UnsupportedOperationException(); }\n\n    public void updateRef(int columnIndex, Ref x){\n        throw new UnsupportedOperationException(); }\n    public void updateRef(String columnName, Ref x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateRowId(int columnIndex, RowId x){\n        throw new UnsupportedOperationException(); }\n    public void updateRowId(String columnName, RowId x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateShort(int columnIndex, short x){\n        throw new UnsupportedOperationException(); }\n    public void updateShort(String columnName, short x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateSQLXML(int columnIndex, SQLXML xmlObject){\n        throw new UnsupportedOperationException(); }\n    public void updateSQLXML(String columnName, SQLXML xmlObject){\n        throw new UnsupportedOperationException(); }\n\n    public void updateString(int columnIndex, String x){\n        throw new UnsupportedOperationException(); }\n    public void updateString(String columnName, String x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateTime(int columnIndex, Time x){\n        throw new UnsupportedOperationException(); }\n    public void updateTime(String columnName, Time x){\n        throw new UnsupportedOperationException(); }\n\n    public void updateTimestamp(int columnIndex, Timestamp x){\n        throw new UnsupportedOperationException(); }\n    public void updateTimestamp(String columnName, Timestamp x){\n        throw new UnsupportedOperationException(); }\n\n    // accessors\n    public Array getArray(int i){\n        return getArray( _find( i ) );\n    }\n    public Array getArray(String colName){\n        throw new UnsupportedOperationException();\n    }\n    \n    public InputStream getAsciiStream(int columnIndex){\n        return getAsciiStream( _find( columnIndex ) );\n    }\n    public InputStream getAsciiStream(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public BigDecimal getBigDecimal(int columnIndex){\n        return getBigDecimal( _find( columnIndex ) );\n    }\n    public BigDecimal getBigDecimal(int columnIndex, int scale){\n        return getBigDecimal( _find( columnIndex ) , scale );\n    }\n    public BigDecimal getBigDecimal(String columnName){\n        throw new UnsupportedOperationException();\n    }\n    public BigDecimal getBigDecimal(String columnName, int scale){\n        throw new UnsupportedOperationException();\n    }\n\n    public InputStream getBinaryStream(int columnIndex){\n        return getBinaryStream( _find( columnIndex ) );\n    }\n    public InputStream getBinaryStream(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public Blob getBlob(int i){\n        return getBlob( _find( i ) );\n    }\n    public Blob getBlob(String colName){\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean getBoolean(int columnIndex){\n        return getBoolean( _find( columnIndex ) );\n    }\n    public boolean getBoolean(String columnName){\n        Object x = _cur.get( columnName );\n        if ( x == null )\n            return false;\n        return (Boolean)x;\n    }\n\n    public byte getByte(int columnIndex){\n        return getByte( _find( columnIndex ) );\n    }\n    public byte getByte(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public byte[] getBytes(int columnIndex){\n        return getBytes( _find( columnIndex ) );\n    }\n    public byte[] getBytes(String columnName){\n        return (byte[])_cur.get( columnName );\n    }\n\n    public Reader getCharacterStream(int columnIndex){\n        return getCharacterStream( _find( columnIndex ) );\n    }\n    public Reader getCharacterStream(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public Clob getClob(int i){\n        return getClob( _find( i ) );\n    }\n    public Clob getClob(String colName){\n        throw new UnsupportedOperationException();\n    }\n\n    public Date getDate(int columnIndex){\n        return getDate( _find( columnIndex ) );\n    }\n    public Date getDate(int columnIndex, Calendar cal){\n        return getDate( _find( columnIndex ) , cal );\n    }\n    public Date getDate(String columnName){\n        return (Date)_cur.get( columnName );\n    }\n    public Date getDate(String columnName, Calendar cal){\n        throw new UnsupportedOperationException();        \n    }\n    \n    public double getDouble(int columnIndex){\n        return getDouble( _find( columnIndex ) );\n    }\n    public double getDouble(String columnName){\n        return _getNumber( columnName ).doubleValue();\n    }\n    \n    public float getFloat(int columnIndex){\n        return getFloat( _find( columnIndex ) );\n    }\n    public float getFloat(String columnName){\n        return _getNumber( columnName ).floatValue();\n    }\n    \n    public int getInt(int columnIndex){\n        return getInt( _find( columnIndex ) );\n    }\n    public int getInt(String columnName){\n        return _getNumber( columnName ).intValue();\n    }\n    \n    public long getLong(int columnIndex){\n        return getLong( _find( columnIndex ) );\n    }\n    public long getLong(String columnName){\n        return _getNumber( columnName ).longValue();\n    }\n\n    public short getShort(int columnIndex){\n        return getShort( _find( columnIndex ) );\n    }\n    public short getShort(String columnName){\n        return _getNumber( columnName ).shortValue();\n    }\n\n\n    Number _getNumber( String n ){\n        Number x = (Number)(_cur.get(n ) );\n        if ( x == null )\n            return 0;\n        return x;\n    }\n\n\n    public Object getObject(int columnIndex){\n        if ( columnIndex == 0 )\n            return _cur;\n        return getObject( _find( columnIndex ) );\n    }\n    public Object getObject(int i, Map map){\n        if ( i == 0 )\n            return _cur;\n        return getObject( _find( i ) , map );\n    }\n    public Object getObject(String columnName){\n        return _cur.get( columnName );\n    }\n    public Object getObject(String colName, Map map){\n        throw new UnsupportedOperationException();\n    }\n        \n    public Ref getRef(int i){\n        return getRef( _find( i ) );\n    }\n    public Ref getRef(String colName){\n        throw new UnsupportedOperationException();\n    }\n\n    public RowId getRowId( int i ){\n        return getRowId( _find( i ) );\n    }\n    public RowId getRowId( String name ){\n        throw new UnsupportedOperationException();\n    }\n        \n\n    public SQLXML getSQLXML(int columnIndex){\n        return getSQLXML( _find( columnIndex ) );\n    }\n    public SQLXML getSQLXML(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public String getString(int columnIndex){\n        return getString( _find( columnIndex ) );\n    }\n    public String getString(String columnName){\n        Object x = _cur.get( columnName );\n        if ( x == null )\n            return null;\n        return x.toString();\n    }\n\n    public Time getTime(int columnIndex){\n        return getTime( _find( columnIndex ) );\n    }\n    public Time getTime(int columnIndex, Calendar cal){\n        return getTime( _find( columnIndex ) , cal );\n    }\n    public Time getTime(String columnName){\n        throw new UnsupportedOperationException();\n    }\n    public Time getTime(String columnName, Calendar cal){\n        throw new UnsupportedOperationException();\n    }\n\n    public Timestamp getTimestamp(int columnIndex){\n        return getTimestamp( _find( columnIndex ) );\n    }\n    public Timestamp getTimestamp(int columnIndex, Calendar cal){\n        return getTimestamp( _find( columnIndex ) , cal );\n    }\n    public Timestamp getTimestamp(String columnName){\n        throw new UnsupportedOperationException();\n    }\n    public Timestamp getTimestamp(String columnName, Calendar cal){\n        throw new UnsupportedOperationException();\n    }\n\n    public InputStream getUnicodeStream(int columnIndex){\n        return getUnicodeStream( _find( columnIndex ) );\n    }\n    public InputStream getUnicodeStream(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public URL getURL(int columnIndex)\n        throws SQLException {\n        return getURL( _find( columnIndex ) );\n    }\n    public URL getURL(String columnName)\n        throws SQLException {\n        try {\n            return new URL( getString( columnName ) );\n        }\n        catch ( java.net.MalformedURLException m ){\n            throw new SQLException( "bad url [" + getString( columnName ) + "]" );\n        }\n    }\n\n    // N stuff\n\n    public String getNString(int columnIndex){\n        return getNString( _find( columnIndex ) );\n    }\n    public String getNString(String columnName){\n        throw new UnsupportedOperationException();\n    }\n    public NClob getNClob(int columnIndex){\n        return getNClob( _find( columnIndex ) );\n    }\n    public NClob getNClob(String columnName){\n        throw new UnsupportedOperationException();\n    }\n    public Reader getNCharacterStream(int columnIndex){\n        return getNCharacterStream( _find( columnIndex ) );\n    }\n    public Reader getNCharacterStream(String columnName){\n        throw new UnsupportedOperationException();\n    }\n\n    public void updateNCharacterStream(int columnIndex, Reader x){ throw new UnsupportedOperationException(); }\n    public void updateNCharacterStream(int columnIndex, Reader x, long length){ throw new UnsupportedOperationException(); }\n    public void updateNCharacterStream(String columnLabel, Reader reader){ throw new UnsupportedOperationException(); }\n    public void updateNCharacterStream(String columnLabel, Reader reader, long length){ throw new UnsupportedOperationException(); }\n    public void updateNClob(int columnIndex, NClob nClob){ throw new UnsupportedOperationException(); }\n    public void updateNClob(int columnIndex, Reader reader){ throw new UnsupportedOperationException(); }\n    public void updateNClob(int columnIndex, Reader reader, long length){ throw new UnsupportedOperationException(); }\n    public void updateNClob(String columnLabel, NClob nClob){ throw new UnsupportedOperationException(); }\n    public void updateNClob(String columnLabel, Reader reader){ throw new UnsupportedOperationException(); }\n    public void updateNClob(String columnLabel, Reader reader, long length){ throw new UnsupportedOperationException(); }\n    public void updateNString(int columnIndex, String nString){ throw new UnsupportedOperationException(); }\n    public void updateNString(String columnLabel, String nString){ throw new UnsupportedOperationException(); }\n\n    public boolean wasNull(){\n        throw new UnsupportedOperationException();\n    }\n\n    // column <-> int mapping\n    \n    public int findColumn( String columnName ){\n        return _fields.get( columnName );\n    }\n    public String _find( int i ){\n        return _fields.get( i );\n    }\n\n    // random stuff\n\n    public  T unwrap(Class iface)\n        throws SQLException {\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean isWrapperFor(Class iface)\n        throws SQLException {\n        throw new UnsupportedOperationException();\n    }\n\n    // moving throgh cursor\n    \n    public boolean next(){\n        if ( ! _cursor.hasNext() ){\n            return false;\n        }\n        _cur = _cursor.next();\n        return true;\n    }\n\n    // members\n\n    final DBCursor _cursor;\n    final FieldLookup _fields = new FieldLookup();\n    DBObject _cur;\n    int _row = 0;\n    boolean _closed = false;\n\n    class FieldLookup {\n\n        void init( DBObject o ){\n            if ( o == null )\n                return;\n            for ( String key : o.keySet() )\n                get( key );\n        }\n        \n        int get( String s ){\n            Integer i = _strings.get(s);\n            if ( i == null ){\n                i = _strings.size() + 1;\n                _store( i , s );\n            }\n            return i;\n        }\n        \n        String get( int i ){\n            String s = _ids.get(i);\n            if ( s != null )\n                return s;\n            \n            init( _cur );\n            \n            s = _ids.get(i);\n            if ( s != null )\n                return s;\n            throw new IllegalArgumentException( i + " is not a valid column id" );\n        }\n        \n        void _store( Integer i , String s ){\n            _ids.put( i , s );\n            _strings.put( s , i );\n        }\n\n        final Map _ids = new HashMap();\n        final Map _strings = new HashMap();\n    }\n\n\n}	God Class	Feature Envy\n	Long Method\n	Shotgun Surgery\n	MongoResultSet	a11020143047a5100ce24af8367610aa	\N	Uma classe implementando várias responsabilidades, tendo um grande número de atributos, operações e dependências com classes de dados 	LOC (Lines of Code), WMC (Weighted Method per Class), CBO (Coupling Betwenn Object Classes); LCOM (Lack of Cohesion in Methods)	Refatoração sugerida:Extract Subclass	t	2
41	Identifique o Bad Smell na classe abaixo	/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the "License"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.taskdefs.optional.j2ee;\n\nimport java.io.File;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.taskdefs.Java;\nimport org.apache.tools.ant.types.Path;\n\n/**\n *  An Ant wrapper task for the weblogic.deploy tool. This is used\n *  to hot-deploy J2EE applications to a running WebLogic server.\n *  This is <b>not</b> the same as creating the application\n *  archive. This task assumes the archive (EAR, JAR, or WAR) file\n *  has been assembled and is supplied as the "source" attribute.\n *  <p>\n *\n *  In the end, this task assembles the commandline parameters and\n *  runs the weblogic.deploy tool in a separate JVM.\n *\n *@see org.apache.tools.ant.taskdefs.optional.j2ee.HotDeploymentTool\n *@see org.apache.tools.ant.taskdefs.optional.j2ee.AbstractHotDeploymentTool\n *@see org.apache.tools.ant.taskdefs.optional.j2ee.ServerDeploy\n */\npublic class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool {\n\n    /**\n     *  Description of the Field\n     */\n    protected static final String DEFAULT_ORB = "RMI";\n\n    /**\n     *  The classname of the tool to run *\n     */\n    private static final String JONAS_DEPLOY_CLASS_NAME = "org.objectweb.jonas.adm.JonasAdmin";\n\n    /**\n     *  All the valid actions that weblogic.deploy permits *\n     */\n    private static final String[] VALID_ACTIONS\n        = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};\n\n    /**\n     *  Description of the Field\n     */\n    private File jonasroot;\n\n    /**\n     *  Description of the Field\n     */\n    private String orb = null;\n\n    /**\n     *  Description of the Field\n     */\n    private String davidHost;\n\n    /**\n     *  Description of the Field\n     */\n    private int davidPort;\n\n\n    /**\n     *  Set the host for the David ORB; required if\n     *  ORB==david.\n     *\n     *@param  inValue  The new davidhost value\n     */\n    public void setDavidhost(final String inValue) {\n        davidHost = inValue;\n    }\n\n\n    /**\n     *  Set the port for the David ORB; required if\n     *  ORB==david.\n     *\n     *@param  inValue  The new davidport value\n     */\n    public void setDavidport(final int inValue) {\n        davidPort = inValue;\n    }\n\n\n    /**\n     *  set the jonas root directory (-Dinstall.root=). This\n     *  element is required.\n     *\n     *@param  inValue  The new jonasroot value\n     */\n    public void setJonasroot(final File inValue) {\n        jonasroot = inValue;\n    }\n\n\n    /**\n     *\n     * Choose your ORB : RMI, JEREMIE, DAVID, ...; optional.\n     * If omitted, it defaults\n     * to the one present in classpath. The corresponding JOnAS JAR is\n     * automatically added to the classpath. If your orb is DAVID (RMI/IIOP) you must\n     * specify davidhost and davidport properties.\n     *\n     *@param  inValue  RMI, JEREMIE, DAVID,...\n     */\n    public void setOrb(final String inValue) {\n        orb = inValue;\n    }\n\n\n    /**\n     *  gets the classpath field.\n     *\n     *@return    A Path representing the "classpath" attribute.\n     */\n    public Path getClasspath() {\n\n        Path aClassPath = super.getClasspath();\n\n        if (aClassPath == null) {\n            aClassPath = new Path(getTask().getProject());\n        }\n        if (orb != null) {\n            String aOrbJar = new File(jonasroot, "lib/" + orb + "_jonas.jar").toString();\n            String aConfigDir = new File(jonasroot, "config/").toString();\n            Path aJOnASOrbPath = new Path(aClassPath.getProject(),\n                    aOrbJar + File.pathSeparator + aConfigDir);\n            aClassPath.append(aJOnASOrbPath);\n        }\n        return aClassPath;\n    }\n\n\n    /**\n     *  Validates the passed in attributes. <p>\n     *\n     *  The rules are:\n     *  <ol>\n     *    <li> If action is "deploy" or "update" the "application"\n     *    and "source" attributes must be supplied.\n     *    <li> If action is "delete" or "undeploy" the\n     *    "application" attribute must be supplied.\n     *\n     *@exception  BuildException                       Description\n     *      of Exception\n     */\n    public void validateAttributes() throws BuildException {\n        // super.validateAttributes(); // don't want to call this method\n\n        Java java = getJava();\n\n        String action = getTask().getAction();\n        if (action == null) {\n            throw new BuildException("The \\"action\\" attribute must be set");\n        }\n\n        if (!isActionValid()) {\n            throw new BuildException("Invalid action \\"" + action + "\\" passed");\n        }\n\n        if (getClassName() == null) {\n            setClassName(JONAS_DEPLOY_CLASS_NAME);\n        }\n\n        if (jonasroot == null || jonasroot.isDirectory()) {\n            java.createJvmarg().setValue("-Dinstall.root=" + jonasroot);\n            java.createJvmarg().setValue("-Djava.security.policy=" + jonasroot\n                + "/config/java.policy");\n\n            if ("DAVID".equals(orb)) {\n                java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBClass"\n                    + "=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB");\n                java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBSingletonClass="\n                    + "org.objectweb.david.libs.binding.orbs.ORBSingletonClass");\n                java.createJvmarg().setValue("-Djavax.rmi.CORBA.StubClass="\n                    + "org.objectweb.david.libs.stub_factories.rmi.StubDelegate");\n                java.createJvmarg().setValue("-Djavax.rmi.CORBA.PortableRemoteObjectClass="\n                    + "org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate");\n                java.createJvmarg().setValue("-Djavax.rmi.CORBA.UtilClass="\n                    + "org.objectweb.david.libs.helpers.RMIUtilDelegate");\n                java.createJvmarg().setValue("-Ddavid.CosNaming.default_method=0");\n                java.createJvmarg().setValue("-Ddavid.rmi.ValueHandlerClass="\n                    + "com.sun.corba.se.internal.io.ValueHandlerImpl");\n                if (davidHost != null) {\n                    java.createJvmarg().setValue("-Ddavid.CosNaming.default_host="\n                        + davidHost);\n                }\n                if (davidPort != 0) {\n                    java.createJvmarg().setValue("-Ddavid.CosNaming.default_port="\n                        + davidPort);\n                }\n            }\n        }\n\n        if (getServer() != null) {\n            java.createArg().setLine("-n " + getServer());\n        }\n\n        if (action.equals(ACTION_DEPLOY)\n            || action.equals(ACTION_UPDATE)\n            || action.equals("redeploy")) {\n            java.createArg().setLine("-a " + getTask().getSource());\n        } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {\n            java.createArg().setLine("-r " + getTask().getSource());\n        } else if (action.equals(ACTION_LIST)) {\n            java.createArg().setValue("-l");\n        }\n    }\n\n\n    /**\n     *  Determines if the action supplied is valid. <p>\n     *\n     *  Valid actions are contained in the static array\n     *  VALID_ACTIONS\n     *\n     *@return    true if the action attribute is valid, false if\n     *      not.\n     */\n    protected boolean isActionValid() {\n        boolean valid = false;\n\n        String action = getTask().getAction();\n\n        for (int i = 0; i < VALID_ACTIONS.length; i++) {\n            if (action.equals(VALID_ACTIONS[i])) {\n                valid = true;\n                break;\n            }\n        }\n\n        return valid;\n    }\n}	Feature Envy	God Class\n	Shotgun Surgery\n	Long Method	JonasHotDeploymentTool.java	84b29496676a8fca072ecfe34bc8f705	\N	Um método está mais interessado em outra classe do que aquela em que está realmente	NOA (Number of Operations Added), LOCC ((Lines of Concern Code), LCOM (Lack of Cohesion in Methods) 	Refatoração sugerida:Move Method	t	2
42	Identifique o Bad Smell na classe abaixo	// The following code was generated by JFlex 1.5.0-SNAPSHOT on 9/30/11 1:23 PM * */\npackage org.apache.lucene.analysis.wikipedia;\n\n/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n ***/////\n\nimport org.apache.lucene.analysis.tokenattributes.CharTermAttribute;\n\n\n/**\n * This class is a scanner generated by \n * <a href="http://www.jflex.de/">JFlex</a> 1.5.0-SNAPSHOT\n * on 9/30/11 1:23 PM from the specification file\n * <tt>/lucene/3x/lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/wikipedia/WikipediaTokenizerImpl.jflex</tt>\n */\nclass WikipediaTokenizerImpl {\n\n  /** This character denotes the end of file */\n  public static final int YYEOF = -1;\n\n  /** initial size of the lookahead buffer */\n  private static final int ZZ_BUFFERSIZE = 16384;\n\n  /** lexical states */\n  public static final int THREE_SINGLE_QUOTES_STATE = 10;\n  public static final int EXTERNAL_LINK_STATE = 6;\n  public static final int DOUBLE_EQUALS_STATE = 14;\n  public static final int INTERNAL_LINK_STATE = 4;\n  public static final int DOUBLE_BRACE_STATE = 16;\n  public static final int CATEGORY_STATE = 2;\n  public static final int YYINITIAL = 0;\n  public static final int STRING = 18;\n  public static final int FIVE_SINGLE_QUOTES_STATE = 12;\n  public static final int TWO_SINGLE_QUOTES_STATE = 8;\n\n  /**\n   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l\n   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l\n   *                  at the beginning of a line\n   * l is of the form l = 2*k, k a non negative integer\n   */\n  private static final int ZZ_LEXSTATE[] = { \n     0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7, \n     8,  8,  9, 9\n  };\n\n  /** \n   * Translates characters to character classes\n   */\n  private static final String ZZ_CMAP_PACKED = \n    "\\11\\0\\1\\24\\1\\23\\1\\0\\1\\24\\1\\22\\22\\0\\1\\24\\1\\0\\1\\12"+\n    "\\1\\53\\2\\0\\1\\3\\1\\1\\4\\0\\1\\14\\1\\5\\1\\2\\1\\10\\12\\16"+\n    "\\1\\27\\1\\0\\1\\7\\1\\11\\1\\13\\1\\53\\1\\4\\2\\15\\1\\30\\5\\15"+\n    "\\1\\41\\21\\15\\1\\25\\1\\0\\1\\26\\1\\0\\1\\6\\1\\0\\1\\31\\1\\43"+\n    "\\2\\15\\1\\33\\1\\40\\1\\34\\1\\50\\1\\41\\4\\15\\1\\42\\1\\35\\1\\51"+\n    "\\1\\15\\1\\36\\1\\52\\1\\32\\3\\15\\1\\44\\1\\37\\1\\15\\1\\45\\1\\47"+\n    "\\1\\46\\102\\0\\27\\15\\1\\0\\37\\15\\1\\0\\u0568\\15\\12\\17\\206\\15\\12\\17"+\n    "\\u026c\\15\\12\\17\\166\\15\\12\\17\\166\\15\\12\\17\\166\\15\\12\\17\\166\\15\\12\\17"+\n    "\\167\\15\\11\\17\\166\\15\\12\\17\\166\\15\\12\\17\\166\\15\\12\\17\\340\\15\\12\\17"+\n    "\\166\\15\\12\\17\\u0166\\15\\12\\17\\266\\15\\u0100\\15\\u0e00\\15\\u1040\\0\\u0150\\21\\140\\0"+\n    "\\20\\21\\u0100\\0\\200\\21\\200\\0\\u19c0\\21\\100\\0\\u5200\\21\\u0c00\\0\\u2bb0\\20\\u2150\\0"+\n    "\\u0200\\21\\u0465\\0\\73\\21\\75\\15\\43\\0";\n\n  /** \n   * Translates characters to character classes\n   */\n  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);\n\n  /** \n   * Translates DFA states to action switch labels.\n   */\n  private static final int [] ZZ_ACTION = zzUnpackAction();\n\n  private static final String ZZ_ACTION_PACKED_0 =\n    "\\12\\0\\4\\1\\4\\2\\1\\3\\1\\1\\1\\4\\1\\1\\2\\5"+\n    "\\1\\6\\2\\5\\1\\7\\1\\5\\2\\10\\1\\11\\1\\12\\1\\11"+\n    "\\1\\13\\1\\14\\1\\10\\1\\15\\1\\16\\1\\15\\1\\17\\1\\20"+\n    "\\1\\10\\1\\21\\1\\10\\4\\22\\1\\23\\1\\22\\1\\24\\1\\25"+\n    "\\1\\26\\3\\0\\1\\27\\14\\0\\1\\30\\1\\31\\1\\32\\1\\33"+\n    "\\1\\11\\1\\0\\1\\34\\1\\35\\1\\36\\1\\0\\1\\37\\1\\0"+\n    "\\1\\40\\3\\0\\1\\41\\1\\42\\2\\43\\1\\42\\2\\44\\2\\0"+\n    "\\1\\43\\1\\0\\14\\43\\1\\42\\3\\0\\1\\11\\1\\45\\3\\0"+\n    "\\1\\46\\1\\47\\5\\0\\1\\50\\4\\0\\1\\50\\2\\0\\2\\50"+\n    "\\2\\0\\1\\11\\5\\0\\1\\31\\1\\42\\1\\43\\1\\51\\3\\0"+\n    "\\1\\11\\2\\0\\1\\52\\30\\0\\1\\53\\2\\0\\1\\54\\1\\55"+\n    "\\1\\56";\n\n  private static int [] zzUnpackAction() {\n    int [] result = new int[184];\n    int offset = 0;\n    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackAction(String packed, int offset, int [] result) {\n    int i = 0;       /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      do result[j++] = value; while (--count > 0);\n    }\n    return j;\n  }\n\n\n  /** \n   * Translates a state to a row index in the transition table\n   */\n  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();\n\n  private static final String ZZ_ROWMAP_PACKED_0 =\n    "\\0\\0\\0\\54\\0\\130\\0\\204\\0\\260\\0\\334\\0\\u0108\\0\\u0134"+\n    "\\0\\u0160\\0\\u018c\\0\\u01b8\\0\\u01e4\\0\\u0210\\0\\u023c\\0\\u0268\\0\\u0294"+\n    "\\0\\u02c0\\0\\u02ec\\0\\u01b8\\0\\u0318\\0\\u0344\\0\\u0370\\0\\u01b8\\0\\u039c"+\n    "\\0\\u03c8\\0\\u03f4\\0\\u0420\\0\\u044c\\0\\u0478\\0\\u01b8\\0\\u039c\\0\\u04a4"+\n    "\\0\\u01b8\\0\\u04d0\\0\\u04fc\\0\\u0528\\0\\u0554\\0\\u0580\\0\\u05ac\\0\\u05d8"+\n    "\\0\\u0604\\0\\u0630\\0\\u065c\\0\\u0688\\0\\u06b4\\0\\u01b8\\0\\u06e0\\0\\u039c"+\n    "\\0\\u070c\\0\\u0738\\0\\u0764\\0\\u0790\\0\\u01b8\\0\\u01b8\\0\\u07bc\\0\\u07e8"+\n    "\\0\\u0814\\0\\u01b8\\0\\u0840\\0\\u086c\\0\\u0898\\0\\u08c4\\0\\u08f0\\0\\u091c"+\n    "\\0\\u0948\\0\\u0974\\0\\u09a0\\0\\u09cc\\0\\u09f8\\0\\u0a24\\0\\u0a50\\0\\u0a7c"+\n    "\\0\\u01b8\\0\\u01b8\\0\\u0aa8\\0\\u0ad4\\0\\u0b00\\0\\u0b00\\0\\u01b8\\0\\u0b2c"+\n    "\\0\\u0b58\\0\\u0b84\\0\\u0bb0\\0\\u0bdc\\0\\u0c08\\0\\u0c34\\0\\u0c60\\0\\u0c8c"+\n    "\\0\\u0cb8\\0\\u0ce4\\0\\u0d10\\0\\u0898\\0\\u0d3c\\0\\u0d68\\0\\u0d94\\0\\u0dc0"+\n    "\\0\\u0dec\\0\\u0e18\\0\\u0e44\\0\\u0e70\\0\\u0e9c\\0\\u0ec8\\0\\u0ef4\\0\\u0f20"+\n    "\\0\\u0f4c\\0\\u0f78\\0\\u0fa4\\0\\u0fd0\\0\\u0ffc\\0\\u1028\\0\\u1054\\0\\u1080"+\n    "\\0\\u10ac\\0\\u10d8\\0\\u01b8\\0\\u1104\\0\\u1130\\0\\u115c\\0\\u1188\\0\\u01b8"+\n    "\\0\\u11b4\\0\\u11e0\\0\\u120c\\0\\u1238\\0\\u1264\\0\\u1290\\0\\u12bc\\0\\u12e8"+\n    "\\0\\u1314\\0\\u1340\\0\\u136c\\0\\u1398\\0\\u13c4\\0\\u086c\\0\\u09f8\\0\\u13f0"+\n    "\\0\\u141c\\0\\u1448\\0\\u1474\\0\\u14a0\\0\\u14cc\\0\\u14f8\\0\\u1524\\0\\u01b8"+\n    "\\0\\u1550\\0\\u157c\\0\\u15a8\\0\\u15d4\\0\\u1600\\0\\u162c\\0\\u1658\\0\\u1684"+\n    "\\0\\u16b0\\0\\u01b8\\0\\u16dc\\0\\u1708\\0\\u1734\\0\\u1760\\0\\u178c\\0\\u17b8"+\n    "\\0\\u17e4\\0\\u1810\\0\\u183c\\0\\u1868\\0\\u1894\\0\\u18c0\\0\\u18ec\\0\\u1918"+\n    "\\0\\u1944\\0\\u1970\\0\\u199c\\0\\u19c8\\0\\u19f4\\0\\u1a20\\0\\u1a4c\\0\\u1a78"+\n    "\\0\\u1aa4\\0\\u1ad0\\0\\u1afc\\0\\u1b28\\0\\u1b54\\0\\u01b8\\0\\u01b8\\0\\u01b8";\n\n  private static int [] zzUnpackRowMap() {\n    int [] result = new int[184];\n    int offset = 0;\n    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackRowMap(String packed, int offset, int [] result) {\n    int i = 0;  /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int high = packed.charAt(i++) << 16;\n      result[j++] = high | packed.charAt(i++);\n    }\n    return j;\n  }\n\n  /** \n   * The transition table of the DFA\n   */\n  private static final int [] ZZ_TRANS = zzUnpackTrans();\n\n  private static final String ZZ_TRANS_PACKED_0 =\n    "\\1\\13\\1\\14\\5\\13\\1\\15\\1\\13\\1\\16\\3\\13\\1\\17"+\n    "\\1\\20\\1\\21\\1\\22\\1\\23\\1\\24\\2\\13\\1\\25\\2\\13"+\n    "\\15\\17\\1\\26\\2\\13\\3\\17\\1\\13\\7\\27\\1\\30\\5\\27"+\n    "\\4\\31\\1\\27\\1\\32\\3\\27\\1\\33\\1\\27\\15\\31\\3\\27"+\n    "\\3\\31\\10\\27\\1\\30\\5\\27\\4\\34\\1\\27\\1\\32\\3\\27"+\n    "\\1\\35\\1\\27\\15\\34\\3\\27\\3\\34\\1\\27\\7\\36\\1\\37"+\n    "\\5\\36\\4\\40\\1\\36\\1\\32\\2\\27\\1\\36\\1\\41\\1\\36"+\n    "\\15\\40\\3\\36\\1\\42\\2\\40\\2\\36\\1\\43\\5\\36\\1\\37"+\n    "\\5\\36\\4\\44\\1\\36\\1\\45\\2\\36\\1\\46\\2\\36\\15\\44"+\n    "\\3\\36\\3\\44\\10\\36\\1\\37\\5\\36\\4\\47\\1\\36\\1\\45"+\n    "\\2\\36\\1\\46\\2\\36\\15\\47\\3\\36\\3\\47\\10\\36\\1\\37"+\n    "\\5\\36\\4\\47\\1\\36\\1\\45\\2\\36\\1\\50\\2\\36\\15\\47"+\n    "\\3\\36\\3\\47\\10\\36\\1\\37\\1\\36\\1\\51\\3\\36\\4\\52"+\n    "\\1\\36\\1\\45\\5\\36\\15\\52\\3\\36\\3\\52\\10\\36\\1\\53"+\n    "\\5\\36\\4\\54\\1\\36\\1\\45\\5\\36\\15\\54\\1\\36\\1\\55"+\n    "\\1\\36\\3\\54\\1\\36\\1\\56\\1\\57\\5\\56\\1\\60\\1\\56"+\n    "\\1\\61\\3\\56\\4\\62\\1\\56\\1\\63\\2\\56\\1\\64\\2\\56"+\n    "\\15\\62\\2\\56\\1\\65\\3\\62\\1\\56\\55\\0\\1\\66\\62\\0"+\n    "\\1\\67\\4\\0\\4\\70\\7\\0\\6\\70\\1\\71\\6\\70\\3\\0"+\n    "\\3\\70\\12\\0\\1\\72\\43\\0\\1\\73\\1\\74\\1\\75\\1\\76"+\n    "\\2\\77\\1\\0\\1\\100\\3\\0\\1\\100\\1\\17\\1\\20\\1\\21"+\n    "\\1\\22\\7\\0\\15\\17\\3\\0\\3\\17\\3\\0\\1\\101\\1\\0"+\n    "\\1\\102\\2\\103\\1\\0\\1\\104\\3\\0\\1\\104\\3\\20\\1\\22"+\n    "\\7\\0\\15\\20\\3\\0\\3\\20\\2\\0\\1\\73\\1\\105\\1\\75"+\n    "\\1\\76\\2\\103\\1\\0\\1\\104\\3\\0\\1\\104\\1\\21\\1\\20"+\n    "\\1\\21\\1\\22\\7\\0\\15\\21\\3\\0\\3\\21\\3\\0\\1\\106"+\n    "\\1\\0\\1\\102\\2\\77\\1\\0\\1\\100\\3\\0\\1\\100\\4\\22"+\n    "\\7\\0\\15\\22\\3\\0\\3\\22\\24\\0\\1\\13\\55\\0\\1\\107"+\n    "\\73\\0\\1\\110\\16\\0\\1\\67\\4\\0\\4\\70\\7\\0\\15\\70"+\n    "\\3\\0\\3\\70\\16\\0\\4\\31\\7\\0\\15\\31\\3\\0\\3\\31"+\n    "\\24\\0\\1\\27\\56\\0\\1\\111\\42\\0\\4\\34\\7\\0\\15\\34"+\n    "\\3\\0\\3\\34\\27\\0\\1\\112\\42\\0\\4\\40\\7\\0\\15\\40"+\n    "\\3\\0\\3\\40\\16\\0\\4\\40\\7\\0\\2\\40\\1\\113\\12\\40"+\n    "\\3\\0\\3\\40\\2\\0\\1\\114\\67\\0\\4\\44\\7\\0\\15\\44"+\n    "\\3\\0\\3\\44\\24\\0\\1\\36\\55\\0\\1\\115\\43\\0\\4\\47"+\n    "\\7\\0\\15\\47\\3\\0\\3\\47\\26\\0\\1\\116\\37\\0\\1\\117"+\n    "\\57\\0\\4\\52\\7\\0\\15\\52\\3\\0\\3\\52\\11\\0\\1\\120"+\n    "\\4\\0\\4\\70\\7\\0\\15\\70\\3\\0\\3\\70\\16\\0\\4\\54"+\n    "\\7\\0\\15\\54\\3\\0\\3\\54\\47\\0\\1\\117\\6\\0\\1\\121"+\n    "\\63\\0\\1\\122\\57\\0\\4\\62\\7\\0\\15\\62\\3\\0\\3\\62"+\n    "\\24\\0\\1\\56\\55\\0\\1\\123\\43\\0\\4\\70\\7\\0\\15\\70"+\n    "\\3\\0\\3\\70\\14\\0\\1\\36\\1\\0\\4\\124\\1\\0\\3\\125"+\n    "\\3\\0\\15\\124\\3\\0\\3\\124\\14\\0\\1\\36\\1\\0\\4\\124"+\n    "\\1\\0\\3\\125\\3\\0\\3\\124\\1\\126\\11\\124\\3\\0\\3\\124"+\n    "\\16\\0\\1\\127\\1\\0\\1\\127\\10\\0\\15\\127\\3\\0\\3\\127"+\n    "\\16\\0\\1\\130\\1\\131\\1\\132\\1\\133\\7\\0\\15\\130\\3\\0"+\n    "\\3\\130\\16\\0\\1\\134\\1\\0\\1\\134\\10\\0\\15\\134\\3\\0"+\n    "\\3\\134\\16\\0\\1\\135\\1\\136\\1\\135\\1\\136\\7\\0\\15\\135"+\n    "\\3\\0\\3\\135\\16\\0\\1\\137\\2\\140\\1\\141\\7\\0\\15\\137"+\n    "\\3\\0\\3\\137\\16\\0\\1\\100\\2\\142\\10\\0\\15\\100\\3\\0"+\n    "\\3\\100\\16\\0\\1\\143\\2\\144\\1\\145\\7\\0\\15\\143\\3\\0"+\n    "\\3\\143\\16\\0\\4\\136\\7\\0\\15\\136\\3\\0\\3\\136\\16\\0"+\n    "\\1\\146\\2\\147\\1\\150\\7\\0\\15\\146\\3\\0\\3\\146\\16\\0"+\n    "\\1\\151\\2\\152\\1\\153\\7\\0\\15\\151\\3\\0\\3\\151\\16\\0"+\n    "\\1\\154\\1\\144\\1\\155\\1\\145\\7\\0\\15\\154\\3\\0\\3\\154"+\n    "\\16\\0\\1\\156\\2\\131\\1\\133\\7\\0\\15\\156\\3\\0\\3\\156"+\n    "\\30\\0\\1\\157\\1\\160\\64\\0\\1\\161\\27\\0\\4\\40\\7\\0"+\n    "\\2\\40\\1\\162\\12\\40\\3\\0\\3\\40\\2\\0\\1\\163\\101\\0"+\n    "\\1\\164\\1\\165\\40\\0\\4\\70\\7\\0\\6\\70\\1\\166\\6\\70"+\n    "\\3\\0\\3\\70\\2\\0\\1\\167\\63\\0\\1\\170\\71\\0\\1\\171"+\n    "\\1\\172\\34\\0\\1\\173\\1\\0\\1\\36\\1\\0\\4\\124\\1\\0"+\n    "\\3\\125\\3\\0\\15\\124\\3\\0\\3\\124\\16\\0\\4\\174\\1\\0"+\n    "\\3\\125\\3\\0\\15\\174\\3\\0\\3\\174\\12\\0\\1\\173\\1\\0"+\n    "\\1\\36\\1\\0\\4\\124\\1\\0\\3\\125\\3\\0\\10\\124\\1\\175"+\n    "\\4\\124\\3\\0\\3\\124\\2\\0\\1\\73\\13\\0\\1\\127\\1\\0"+\n    "\\1\\127\\10\\0\\15\\127\\3\\0\\3\\127\\3\\0\\1\\176\\1\\0"+\n    "\\1\\102\\2\\177\\6\\0\\1\\130\\1\\131\\1\\132\\1\\133\\7\\0"+\n    "\\15\\130\\3\\0\\3\\130\\3\\0\\1\\200\\1\\0\\1\\102\\2\\201"+\n    "\\1\\0\\1\\202\\3\\0\\1\\202\\3\\131\\1\\133\\7\\0\\15\\131"+\n    "\\3\\0\\3\\131\\3\\0\\1\\203\\1\\0\\1\\102\\2\\201\\1\\0"+\n    "\\1\\202\\3\\0\\1\\202\\1\\132\\1\\131\\1\\132\\1\\133\\7\\0"+\n    "\\15\\132\\3\\0\\3\\132\\3\\0\\1\\204\\1\\0\\1\\102\\2\\177"+\n    "\\6\\0\\4\\133\\7\\0\\15\\133\\3\\0\\3\\133\\3\\0\\1\\205"+\n    "\\2\\0\\1\\205\\7\\0\\1\\135\\1\\136\\1\\135\\1\\136\\7\\0"+\n    "\\15\\135\\3\\0\\3\\135\\3\\0\\1\\205\\2\\0\\1\\205\\7\\0"+\n    "\\4\\136\\7\\0\\15\\136\\3\\0\\3\\136\\3\\0\\1\\177\\1\\0"+\n    "\\1\\102\\2\\177\\6\\0\\1\\137\\2\\140\\1\\141\\7\\0\\15\\137"+\n    "\\3\\0\\3\\137\\3\\0\\1\\201\\1\\0\\1\\102\\2\\201\\1\\0"+\n    "\\1\\202\\3\\0\\1\\202\\3\\140\\1\\141\\7\\0\\15\\140\\3\\0"+\n    "\\3\\140\\3\\0\\1\\177\\1\\0\\1\\102\\2\\177\\6\\0\\4\\141"+\n    "\\7\\0\\15\\141\\3\\0\\3\\141\\3\\0\\1\\202\\2\\0\\2\\202"+\n    "\\1\\0\\1\\202\\3\\0\\1\\202\\3\\142\\10\\0\\15\\142\\3\\0"+\n    "\\3\\142\\3\\0\\1\\106\\1\\0\\1\\102\\2\\77\\1\\0\\1\\100"+\n    "\\3\\0\\1\\100\\1\\143\\2\\144\\1\\145\\7\\0\\15\\143\\3\\0"+\n    "\\3\\143\\3\\0\\1\\101\\1\\0\\1\\102\\2\\103\\1\\0\\1\\104"+\n    "\\3\\0\\1\\104\\3\\144\\1\\145\\7\\0\\15\\144\\3\\0\\3\\144"+\n    "\\3\\0\\1\\106\\1\\0\\1\\102\\2\\77\\1\\0\\1\\100\\3\\0"+\n    "\\1\\100\\4\\145\\7\\0\\15\\145\\3\\0\\3\\145\\3\\0\\1\\77"+\n    "\\1\\0\\1\\102\\2\\77\\1\\0\\1\\100\\3\\0\\1\\100\\1\\146"+\n    "\\2\\147\\1\\150\\7\\0\\15\\146\\3\\0\\3\\146\\3\\0\\1\\103"+\n    "\\1\\0\\1\\102\\2\\103\\1\\0\\1\\104\\3\\0\\1\\104\\3\\147"+\n    "\\1\\150\\7\\0\\15\\147\\3\\0\\3\\147\\3\\0\\1\\77\\1\\0"+\n    "\\1\\102\\2\\77\\1\\0\\1\\100\\3\\0\\1\\100\\4\\150\\7\\0"+\n    "\\15\\150\\3\\0\\3\\150\\3\\0\\1\\100\\2\\0\\2\\100\\1\\0"+\n    "\\1\\100\\3\\0\\1\\100\\1\\151\\2\\152\\1\\153\\7\\0\\15\\151"+\n    "\\3\\0\\3\\151\\3\\0\\1\\104\\2\\0\\2\\104\\1\\0\\1\\104"+\n    "\\3\\0\\1\\104\\3\\152\\1\\153\\7\\0\\15\\152\\3\\0\\3\\152"+\n    "\\3\\0\\1\\100\\2\\0\\2\\100\\1\\0\\1\\100\\3\\0\\1\\100"+\n    "\\4\\153\\7\\0\\15\\153\\3\\0\\3\\153\\3\\0\\1\\206\\1\\0"+\n    "\\1\\102\\2\\77\\1\\0\\1\\100\\3\\0\\1\\100\\1\\154\\1\\144"+\n    "\\1\\155\\1\\145\\7\\0\\15\\154\\3\\0\\3\\154\\3\\0\\1\\207"+\n    "\\1\\0\\1\\102\\2\\103\\1\\0\\1\\104\\3\\0\\1\\104\\1\\155"+\n    "\\1\\144\\1\\155\\1\\145\\7\\0\\15\\155\\3\\0\\3\\155\\3\\0"+\n    "\\1\\204\\1\\0\\1\\102\\2\\177\\6\\0\\1\\156\\2\\131\\1\\133"+\n    "\\7\\0\\15\\156\\3\\0\\3\\156\\31\\0\\1\\160\\54\\0\\1\\210"+\n    "\\64\\0\\1\\211\\26\\0\\4\\40\\7\\0\\15\\40\\3\\0\\1\\40"+\n    "\\1\\212\\1\\40\\31\\0\\1\\165\\54\\0\\1\\213\\35\\0\\1\\36"+\n    "\\1\\0\\4\\124\\1\\0\\3\\125\\3\\0\\3\\124\\1\\214\\11\\124"+\n    "\\3\\0\\3\\124\\2\\0\\1\\215\\102\\0\\1\\172\\54\\0\\1\\216"+\n    "\\34\\0\\1\\217\\52\\0\\1\\173\\3\\0\\4\\174\\7\\0\\15\\174"+\n    "\\3\\0\\3\\174\\12\\0\\1\\173\\1\\0\\1\\220\\1\\0\\4\\124"+\n    "\\1\\0\\3\\125\\3\\0\\15\\124\\3\\0\\3\\124\\16\\0\\1\\221"+\n    "\\1\\133\\1\\221\\1\\133\\7\\0\\15\\221\\3\\0\\3\\221\\16\\0"+\n    "\\4\\141\\7\\0\\15\\141\\3\\0\\3\\141\\16\\0\\4\\145\\7\\0"+\n    "\\15\\145\\3\\0\\3\\145\\16\\0\\4\\150\\7\\0\\15\\150\\3\\0"+\n    "\\3\\150\\16\\0\\4\\153\\7\\0\\15\\153\\3\\0\\3\\153\\16\\0"+\n    "\\1\\222\\1\\145\\1\\222\\1\\145\\7\\0\\15\\222\\3\\0\\3\\222"+\n    "\\16\\0\\4\\133\\7\\0\\15\\133\\3\\0\\3\\133\\16\\0\\4\\223"+\n    "\\7\\0\\15\\223\\3\\0\\3\\223\\33\\0\\1\\224\\61\\0\\1\\225"+\n    "\\30\\0\\4\\40\\6\\0\\1\\226\\15\\40\\3\\0\\2\\40\\1\\227"+\n    "\\33\\0\\1\\230\\32\\0\\1\\173\\1\\0\\1\\36\\1\\0\\4\\124"+\n    "\\1\\0\\3\\125\\3\\0\\10\\124\\1\\231\\4\\124\\3\\0\\3\\124"+\n    "\\2\\0\\1\\232\\104\\0\\1\\233\\36\\0\\4\\234\\7\\0\\15\\234"+\n    "\\3\\0\\3\\234\\3\\0\\1\\176\\1\\0\\1\\102\\2\\177\\6\\0"+\n    "\\1\\221\\1\\133\\1\\221\\1\\133\\7\\0\\15\\221\\3\\0\\3\\221"+\n    "\\3\\0\\1\\206\\1\\0\\1\\102\\2\\77\\1\\0\\1\\100\\3\\0"+\n    "\\1\\100\\1\\222\\1\\145\\1\\222\\1\\145\\7\\0\\15\\222\\3\\0"+\n    "\\3\\222\\3\\0\\1\\205\\2\\0\\1\\205\\7\\0\\4\\223\\7\\0"+\n    "\\15\\223\\3\\0\\3\\223\\34\\0\\1\\235\\55\\0\\1\\236\\26\\0"+\n    "\\1\\237\\60\\0\\4\\40\\6\\0\\1\\226\\15\\40\\3\\0\\3\\40"+\n    "\\34\\0\\1\\240\\31\\0\\1\\173\\1\\0\\1\\117\\1\\0\\4\\124"+\n    "\\1\\0\\3\\125\\3\\0\\15\\124\\3\\0\\3\\124\\34\\0\\1\\241"+\n    "\\32\\0\\1\\242\\2\\0\\4\\234\\7\\0\\15\\234\\3\\0\\3\\234"+\n    "\\35\\0\\1\\243\\62\\0\\1\\244\\20\\0\\1\\245\\77\\0\\1\\246"+\n    "\\53\\0\\1\\247\\32\\0\\1\\36\\1\\0\\4\\174\\1\\0\\3\\125"+\n    "\\3\\0\\15\\174\\3\\0\\3\\174\\36\\0\\1\\250\\53\\0\\1\\251"+\n    "\\33\\0\\4\\252\\7\\0\\15\\252\\3\\0\\3\\252\\36\\0\\1\\253"+\n    "\\53\\0\\1\\254\\54\\0\\1\\255\\61\\0\\1\\256\\11\\0\\1\\257"+\n    "\\12\\0\\4\\252\\7\\0\\15\\252\\3\\0\\3\\252\\37\\0\\1\\260"+\n    "\\53\\0\\1\\261\\54\\0\\1\\262\\22\\0\\1\\13\\62\\0\\4\\263"+\n    "\\7\\0\\15\\263\\3\\0\\3\\263\\40\\0\\1\\264\\53\\0\\1\\265"+\n    "\\43\\0\\1\\266\\26\\0\\2\\263\\1\\0\\2\\263\\1\\0\\2\\263"+\n    "\\2\\0\\5\\263\\7\\0\\15\\263\\3\\0\\4\\263\\27\\0\\1\\267"+\n    "\\53\\0\\1\\270\\24\\0";\n\n  private static int [] zzUnpackTrans() {\n    int [] result = new int[7040];\n    int offset = 0;\n    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackTrans(String packed, int offset, int [] result) {\n    int i = 0;       /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      value--;\n      do result[j++] = value; while (--count > 0);\n    }\n    return j;\n  }\n\n\n  /* error codes */\n  private static final int ZZ_UNKNOWN_ERROR = 0;\n  private static final int ZZ_NO_MATCH = 1;\n  private static final int ZZ_PUSHBACK_2BIG = 2;\n\n  /* error messages for the codes above */\n  private static final String ZZ_ERROR_MSG[] = {\n    "Unkown internal scanner error",\n    "Error: could not match input",\n    "Error: pushback value was too large"\n  };\n\n  /**\n   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>\n   */\n  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();\n\n  private static final String ZZ_ATTRIBUTE_PACKED_0 =\n    "\\12\\0\\1\\11\\7\\1\\1\\11\\3\\1\\1\\11\\6\\1\\1\\11"+\n    "\\2\\1\\1\\11\\14\\1\\1\\11\\6\\1\\2\\11\\3\\0\\1\\11"+\n    "\\14\\0\\2\\1\\2\\11\\1\\1\\1\\0\\2\\1\\1\\11\\1\\0"+\n    "\\1\\1\\1\\0\\1\\1\\3\\0\\7\\1\\2\\0\\1\\1\\1\\0"+\n    "\\15\\1\\3\\0\\1\\1\\1\\11\\3\\0\\1\\1\\1\\11\\5\\0"+\n    "\\1\\1\\4\\0\\1\\1\\2\\0\\2\\1\\2\\0\\1\\1\\5\\0"+\n    "\\1\\11\\3\\1\\3\\0\\1\\1\\2\\0\\1\\11\\30\\0\\1\\1"+\n    "\\2\\0\\3\\11";\n\n  private static int [] zzUnpackAttribute() {\n    int [] result = new int[184];\n    int offset = 0;\n    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);\n    return result;\n  }\n\n  private static int zzUnpackAttribute(String packed, int offset, int [] result) {\n    int i = 0;       /* index in packed string  */\n    int j = offset;  /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      do result[j++] = value; while (--count > 0);\n    }\n    return j;\n  }\n\n  /** the input device */\n  private java.io.Reader zzReader;\n\n  /** the current state of the DFA */\n  private int zzState;\n\n  /** the current lexical state */\n  private int zzLexicalState = YYINITIAL;\n\n  /** this buffer contains the current text to be matched and is\n      the source of the yytext() string */\n  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];\n\n  /** the textposition at the last accepting state */\n  private int zzMarkedPos;\n\n  /** the current text position in the buffer */\n  private int zzCurrentPos;\n\n  /** startRead marks the beginning of the yytext() string in the buffer */\n  private int zzStartRead;\n\n  /** endRead marks the last character in the buffer, that has been read\n      from input */\n  private int zzEndRead;\n\n  /** number of newlines encountered up to the start of the matched text */\n  private int yyline;\n\n  /** the number of characters up to the start of the matched text */\n  private int yychar;\n\n  /**\n   * the number of characters from the last newline up to the start of the \n   * matched text\n   */\n  private int yycolumn;\n\n  /** \n   * zzAtBOL == true <=> the scanner is currently at the beginning of a line\n   */\n  private boolean zzAtBOL = true;\n\n  /** zzAtEOF == true <=> the scanner is at the EOF */\n  private boolean zzAtEOF;\n\n  /** denotes if the user-EOF-code has already been executed */\n  private boolean zzEOFDone;\n\n  /* user code: */\n\npublic static final int ALPHANUM          = WikipediaTokenizer.ALPHANUM_ID;\npublic static final int APOSTROPHE        = WikipediaTokenizer.APOSTROPHE_ID;\npublic static final int ACRONYM           = WikipediaTokenizer.ACRONYM_ID;\npublic static final int COMPANY           = WikipediaTokenizer.COMPANY_ID;\npublic static final int EMAIL             = WikipediaTokenizer.EMAIL_ID;\npublic static final int HOST              = WikipediaTokenizer.HOST_ID;\npublic static final int NUM               = WikipediaTokenizer.NUM_ID;\npublic static final int CJ                = WikipediaTokenizer.CJ_ID;\npublic static final int INTERNAL_LINK     = WikipediaTokenizer.INTERNAL_LINK_ID;\npublic static final int EXTERNAL_LINK     = WikipediaTokenizer.EXTERNAL_LINK_ID;\npublic static final int CITATION          = WikipediaTokenizer.CITATION_ID;\npublic static final int CATEGORY          = WikipediaTokenizer.CATEGORY_ID;\npublic static final int BOLD              = WikipediaTokenizer.BOLD_ID;\npublic static final int ITALICS           = WikipediaTokenizer.ITALICS_ID;\npublic static final int BOLD_ITALICS      = WikipediaTokenizer.BOLD_ITALICS_ID;\npublic static final int HEADING           = WikipediaTokenizer.HEADING_ID;\npublic static final int SUB_HEADING       = WikipediaTokenizer.SUB_HEADING_ID;\npublic static final int EXTERNAL_LINK_URL = WikipediaTokenizer.EXTERNAL_LINK_URL_ID;\n\n\nprivate int currentTokType;\nprivate int numBalanced = 0;\nprivate int positionInc = 1;\nprivate int numLinkToks = 0;\n//Anytime we start a new on a Wiki reserved token (category, link, etc.) this value will be 0, otherwise it will be the number of tokens seen\n//this can be useful for detecting when a new reserved token is encountered\n//see https://issues.apache.org/jira/browse/LUCENE-1133\nprivate int numWikiTokensSeen = 0;\n\npublic static final String [] TOKEN_TYPES = WikipediaTokenizer.TOKEN_TYPES;\n\n/**\nReturns the number of tokens seen inside a category or link, etc.\n@return the number of tokens seen inside the context of wiki syntax.\n**/\npublic final int getNumWikiTokensSeen(){\n  return numWikiTokensSeen;\n}\n\npublic final int yychar()\n{\n    return yychar;\n}\n\npublic final int getPositionIncrement(){\n  return positionInc;\n}\n\n/**\n * Fills Lucene token with the current token text.\n */\nfinal void getText(CharTermAttribute t) {\n  t.copyBuffer(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);\n}\n\nfinal int setText(StringBuilder buffer){\n  int length = zzMarkedPos - zzStartRead;\n  buffer.append(zzBuffer, zzStartRead, length);\n  return length;\n}\n\n\n\n\n  /**\n   * Creates a new scanner\n   * There is also a java.io.InputStream version of this constructor.\n   *\n   * @param   in  the java.io.Reader to read input from.\n   */\n  WikipediaTokenizerImpl(java.io.Reader in) {\n    this.zzReader = in;\n  }\n\n  /**\n   * Creates a new scanner.\n   * There is also java.io.Reader version of this constructor.\n   *\n   * @param   in  the java.io.Inputstream to read input from.\n   */\n  WikipediaTokenizerImpl(java.io.InputStream in) {\n    this(new java.io.InputStreamReader(in));\n  }\n\n  /** \n   * Unpacks the compressed character translation table.\n   *\n   * @param packed   the packed character translation table\n   * @return         the unpacked character translation table\n   */\n  private static char [] zzUnpackCMap(String packed) {\n    char [] map = new char[0x10000];\n    int i = 0;  /* index in packed string  */\n    int j = 0;  /* index in unpacked array */\n    while (i < 230) {\n      int  count = packed.charAt(i++);\n      char value = packed.charAt(i++);\n      do map[j++] = value; while (--count > 0);\n    }\n    return map;\n  }\n\n\n  /**\n   * Refills the input buffer.\n   *\n   * @return      <code>false</code>, iff there was new input.\n   * \n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private boolean zzRefill() throws java.io.IOException {\n\n    /* first: make room (if you can) */\n    if (zzStartRead > 0) {\n      System.arraycopy(zzBuffer, zzStartRead,\n                       zzBuffer, 0,\n                       zzEndRead-zzStartRead);\n\n      /* translate stored positions */\n      zzEndRead-= zzStartRead;\n      zzCurrentPos-= zzStartRead;\n      zzMarkedPos-= zzStartRead;\n      zzStartRead = 0;\n    }\n\n    /* is the buffer big enough? */\n    if (zzCurrentPos >= zzBuffer.length) {\n      /* if not: blow it up */\n      char newBuffer[] = new char[zzCurrentPos*2];\n      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);\n      zzBuffer = newBuffer;\n    }\n\n    /* finally: fill the buffer with new input */\n    int numRead = zzReader.read(zzBuffer, zzEndRead,\n                                            zzBuffer.length-zzEndRead);\n\n    if (numRead > 0) {\n      zzEndRead+= numRead;\n      return false;\n    }\n    // unlikely but not impossible: read 0 characters, but not at end of stream    \n    if (numRead == 0) {\n      int c = zzReader.read();\n      if (c == -1) {\n        return true;\n      } else {\n        zzBuffer[zzEndRead++] = (char) c;\n        return false;\n      }     \n    }\n\n\t// numRead < 0\n    return true;\n  }\n\n    \n  /**\n   * Closes the input stream.\n   */\n  public final void yyclose() throws java.io.IOException {\n    zzAtEOF = true;            /* indicate end of file */\n    zzEndRead = zzStartRead;  /* invalidate buffer    */\n\n    if (zzReader != null)\n      zzReader.close();\n  }\n\n\n  /**\n   * Resets the scanner to read from a new input stream.\n   * Does not close the old reader.\n   *\n   * All internal variables are reset, the old input stream \n   * <b>cannot</b> be reused (internal buffer is discarded and lost).\n   * Lexical state is set to <tt>ZZ_INITIAL</tt>.\n   *\n   * Internal scan buffer is resized down to its initial length, if it has grown.\n   *\n   * @param reader   the new input stream \n   */\n  public final void yyreset(java.io.Reader reader) {\n    zzReader = reader;\n    zzAtBOL  = true;\n    zzAtEOF  = false;\n    zzEOFDone = false;\n    zzEndRead = zzStartRead = 0;\n    zzCurrentPos = zzMarkedPos = 0;\n    yyline = yychar = yycolumn = 0;\n    zzLexicalState = YYINITIAL;\n    if (zzBuffer.length > ZZ_BUFFERSIZE)\n      zzBuffer = new char[ZZ_BUFFERSIZE];\n  }\n\n\n  /**\n   * Returns the current lexical state.\n   */\n  public final int yystate() {\n    return zzLexicalState;\n  }\n\n\n  /**\n   * Enters a new lexical state\n   *\n   * @param newState the new lexical state\n   */\n  public final void yybegin(int newState) {\n    zzLexicalState = newState;\n  }\n\n\n  /**\n   * Returns the text matched by the current regular expression.\n   */\n  public final String yytext() {\n    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );\n  }\n\n\n  /**\n   * Returns the character at position <tt>pos</tt> from the \n   * matched text. \n   * \n   * It is equivalent to yytext().charAt(pos), but faster\n   *\n   * @param pos the position of the character to fetch. \n   *            A value from 0 to yylength()-1.\n   *\n   * @return the character at position pos\n   */\n  public final char yycharat(int pos) {\n    return zzBuffer[zzStartRead+pos];\n  }\n\n\n  /**\n   * Returns the length of the matched text region.\n   */\n  public final int yylength() {\n    return zzMarkedPos-zzStartRead;\n  }\n\n\n  /**\n   * Reports an error that occured while scanning.\n   *\n   * In a wellformed scanner (no or only correct usage of \n   * yypushback(int) and a match-all fallback rule) this method \n   * will only be called with things that "Can't Possibly Happen".\n   * If this method is called, something is seriously wrong\n   * (e.g. a JFlex bug producing a faulty scanner etc.).\n   *\n   * Usual syntax/scanner level error handling should be done\n   * in error fallback rules.\n   *\n   * @param   errorCode  the code of the errormessage to display\n   */\n  private void zzScanError(int errorCode) {\n    String message;\n    try {\n      message = ZZ_ERROR_MSG[errorCode];\n    }\n    catch (ArrayIndexOutOfBoundsException e) {\n      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];\n    }\n\n    throw new Error(message);\n  } \n\n\n  /**\n   * Pushes the specified amount of characters back into the input stream.\n   *\n   * They will be read again by then next call of the scanning method\n   *\n   * @param number  the number of characters to be read again.\n   *                This number must not be greater than yylength()!\n   */\n  public void yypushback(int number)  {\n    if ( number > yylength() )\n      zzScanError(ZZ_PUSHBACK_2BIG);\n\n    zzMarkedPos -= number;\n  }\n\n\n  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 44: \n          { numWikiTokensSeen = 0; positionInc = 1; currentTokType = CATEGORY; yybegin(CATEGORY_STATE);/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 47: break;\n        case 37: \n          { currentTokType = BOLD_ITALICS;  yybegin(FIVE_SINGLE_QUOTES_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 48: break;\n        case 16: \n          { currentTokType = HEADING; yybegin(DOUBLE_EQUALS_STATE); numWikiTokensSeen++; return currentTokType;\n          }\n        case 49: break;\n        case 20: \n          { numBalanced = 0; numWikiTokensSeen = 0; currentTokType = EXTERNAL_LINK;yybegin(EXTERNAL_LINK_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 50: break;\n        case 40: \n          { positionInc = 1; return ACRONYM;\n          }\n        case 51: break;\n        case 5: \n          { positionInc = 1; /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 52: break;\n        case 36: \n          { positionInc = 1; return COMPANY;\n          }\n        case 53: break;\n        case 10: \n          { numLinkToks = 0; positionInc = 0; yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 54: break;\n        case 15: \n          { currentTokType = SUB_HEADING; numWikiTokensSeen = 0; yybegin(STRING); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 55: break;\n        case 22: \n          { numWikiTokensSeen = 0; positionInc = 1; if (numBalanced == 0){numBalanced++;yybegin(TWO_SINGLE_QUOTES_STATE);} else{numBalanced = 0;}/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 56: break;\n        case 35: \n          { positionInc = 1; return NUM;\n          }\n        case 57: break;\n        case 33: \n          { positionInc = 1; return APOSTROPHE;\n          }\n        case 58: break;\n        case 21: \n          { yybegin(STRING); return currentTokType;/*pipe*/\n          }\n        case 59: break;\n        case 18: \n          { /* Break so we don't hit fall-through warning: */ break;/* ignore STRING */\n          }\n        case 60: break;\n        case 2: \n          { positionInc = 1; return ALPHANUM;\n          }\n        case 61: break;\n        case 1: \n          { numWikiTokensSeen = 0;  positionInc = 1; /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 62: break;\n        case 17: \n          { yybegin(DOUBLE_BRACE_STATE); numWikiTokensSeen = 0; return currentTokType;\n          }\n        case 63: break;\n        case 39: \n          { numBalanced = 0;currentTokType = ALPHANUM; yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;/*end sub header*/\n          }\n        case 64: break;\n        case 29: \n          { currentTokType = INTERNAL_LINK; numWikiTokensSeen = 0;  yybegin(INTERNAL_LINK_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 65: break;\n        case 46: \n          { numBalanced = 0; numWikiTokensSeen = 0; currentTokType = CATEGORY;yybegin(CATEGORY_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 66: break;\n        case 27: \n          { numLinkToks = 0; yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 67: break;\n        case 4: \n          { numWikiTokensSeen = 0; positionInc = 1; currentTokType = EXTERNAL_LINK_URL; yybegin(EXTERNAL_LINK_STATE);/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 68: break;\n        case 38: \n          { numBalanced = 0;currentTokType = ALPHANUM;yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;/*end bold*/\n          }\n        case 69: break;\n        case 13: \n          { currentTokType = EXTERNAL_LINK; numWikiTokensSeen = 0; yybegin(EXTERNAL_LINK_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 70: break;\n        case 3: \n          { positionInc = 1; return CJ;\n          }\n        case 71: break;\n        case 45: \n          { currentTokType = CATEGORY; numWikiTokensSeen = 0; yybegin(CATEGORY_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 72: break;\n        case 6: \n          { yybegin(CATEGORY_STATE); numWikiTokensSeen++; return currentTokType;\n          }\n        case 73: break;\n        case 11: \n          { currentTokType = BOLD;  yybegin(THREE_SINGLE_QUOTES_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 74: break;\n        case 25: \n          { numWikiTokensSeen = 0; positionInc = 1; currentTokType = CITATION; yybegin(DOUBLE_BRACE_STATE);/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 75: break;\n        case 8: \n          { /* Break so we don't hit fall-through warning: */ break;/* ignore */\n          }\n        case 76: break;\n        case 19: \n          { yybegin(STRING); numWikiTokensSeen++; return currentTokType;/* STRING ALPHANUM*/\n          }\n        case 77: break;\n        case 43: \n          { positionInc = 1; numWikiTokensSeen++; yybegin(EXTERNAL_LINK_STATE); return currentTokType;\n          }\n        case 78: break;\n        case 42: \n          { numBalanced = 0;currentTokType = ALPHANUM; yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;/*end bold italics*/\n          }\n        case 79: break;\n        case 30: \n          { yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 80: break;\n        case 14: \n          { yybegin(STRING); numWikiTokensSeen++; return currentTokType;\n          }\n        case 81: break;\n        case 9: \n          { if (numLinkToks == 0){positionInc = 0;} else{positionInc = 1;} numWikiTokensSeen++; currentTokType = EXTERNAL_LINK; yybegin(EXTERNAL_LINK_STATE); numLinkToks++; return currentTokType;\n          }\n        case 82: break;\n        case 7: \n          { yybegin(INTERNAL_LINK_STATE); numWikiTokensSeen++; return currentTokType;\n          }\n        case 83: break;\n        case 41: \n          { positionInc = 1; return EMAIL;\n          }\n        case 84: break;\n        case 28: \n          { currentTokType = INTERNAL_LINK; numWikiTokensSeen = 0; yybegin(INTERNAL_LINK_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 85: break;\n        case 23: \n          { numWikiTokensSeen = 0; positionInc = 1; yybegin(DOUBLE_EQUALS_STATE);/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 86: break;\n        case 34: \n          { positionInc = 1; return HOST;\n          }\n        case 87: break;\n        case 32: \n          { numBalanced = 0; numWikiTokensSeen = 0; currentTokType = INTERNAL_LINK;yybegin(INTERNAL_LINK_STATE); /* Break so we don't hit fall-through warning: */ break;\n          }\n        case 88: break;\n        case 12: \n          { currentTokType = ITALICS; numWikiTokensSeen++;  yybegin(STRING); return currentTokType;/*italics*/\n          }\n        case 89: break;\n        case 24: \n          { numWikiTokensSeen = 0; positionInc = 1; currentTokType = INTERNAL_LINK; yybegin(INTERNAL_LINK_STATE);/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 90: break;\n        case 31: \n          { numBalanced = 0;currentTokType = ALPHANUM; yybegin(YYINITIAL); /* Break so we don't hit fall-through warning: */ break;/*end italics*/\n          }\n        case 91: break;\n        case 26: \n          { yybegin(YYINITIAL);/* Break so we don't hit fall-through warning: */ break;\n          }\n        case 92: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            return YYEOF;\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n\n}	Feature Envy	Long Method\n	God Class\n	Divergent Change\n	WikipediaTokenizerImpl.java	84b29496676a8fca072ecfe34bc8f705	\N	Um método está mais interessado em outra classe do que aquela em que está realmente	NOA (Number of Operations Added), LOCC ((Lines of Concern Code), LCOM (Lack of Cohesion in Methods) 	Refatoração sugerida:Move Method	t	2
44	Identifique o Bad Smell na classe abaixo	package org.apache.tools.ant.taskdefs;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.tools.ant.AntTypeDefinition;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.ComponentHelper;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.ant.RuntimeConfigurable;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.TaskContainer;\nimport org.apache.tools.ant.UnknownElement;\n\n/**\n * Describe class <code>MacroDef</code> here.\n *\n * @since Ant 1.6\n */\npublic class MacroDef extends AntlibDefinition  {\n\n    private NestedSequential nestedSequential;\n    private String     name;\n    private boolean    backTrace = true;\n    private List<Attribute>       attributes = new ArrayList<Attribute>();\n    private Map<String, TemplateElement>        elements   = new HashMap<String, TemplateElement>();\n    private String     textName   = null;\n    private Text       text       = null;\n    private boolean    hasImplicitElement = false;\n\n    /**\n     * Name of the definition\n     * @param name the name of the definition\n     */\n     public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Add the text element.\n     * @param text the nested text element to add\n     * @since ant 1.6.1\n     */\n    public void addConfiguredText(Text text) {\n        if (this.text != null) {\n            throw new BuildException(\n                "Only one nested text element allowed");\n        }\n        if (text.getName() == null) {\n            throw new BuildException(\n                "the text nested element needed a \\"name\\" attribute");\n        }\n        // Check if used by attributes\n        for (Attribute attribute : attributes) {\n            if (text.getName().equals(attribute.getName())) {\n                throw new BuildException(\n                    "the name \\"" + text.getName()\n                    + "\\" is already used as an attribute");\n            }\n        }\n        this.text = text;\n        this.textName = text.getName();\n    }\n\n    /**\n     * @return the nested text element\n     * @since ant 1.6.1\n     */\n    public Text getText() {\n        return text;\n    }\n\n    /**\n     * Set the backTrace attribute.\n     *\n     * @param backTrace if true and the macro instance generates\n     *                  an error, a backtrace of the location within\n     *                  the macro and call to the macro will be output.\n     *                  if false, only the location of the call to the\n     *                  macro will be shown. Default is true.\n     * @since ant 1.7\n     */\n    public void setBackTrace(boolean backTrace) {\n        this.backTrace = backTrace;\n    }\n\n    /**\n     * @return the backTrace attribute.\n     * @since ant 1.7\n     */\n    public boolean getBackTrace() {\n        return backTrace;\n    }\n\n    /**\n     * This is the sequential nested element of the macrodef.\n     *\n     * @return a sequential element to be configured.\n     */\n    public NestedSequential createSequential() {\n        if (this.nestedSequential != null) {\n            throw new BuildException("Only one sequential allowed");\n        }\n        this.nestedSequential = new NestedSequential();\n        return this.nestedSequential;\n    }\n\n    /**\n     * The class corresponding to the sequential nested element.\n     * This is a simple task container.\n     */\n    public static class NestedSequential implements TaskContainer {\n        private List<Task> nested = new ArrayList<Task>();\n\n        /**\n         * Add a task or type to the container.\n         *\n         * @param task an unknown element.\n         */\n        public void addTask(Task task) {\n            nested.add(task);\n        }\n\n        /**\n         * @return the list of unknown elements\n         */\n        public List<Task> getNested() {\n            return nested;\n        }\n\n        /**\n         * A compare function to compare this with another\n         * NestedSequential.\n         * It calls similar on the nested unknown elements.\n         *\n         * @param other the nested sequential to compare with.\n         * @return true if they are similar, false otherwise\n         */\n        public boolean similar(NestedSequential other) {\n            final int size = nested.size();\n            if (size != other.nested.size()) {\n                return false;\n            }\n            for (int i = 0; i < size; ++i) {\n                UnknownElement me = (UnknownElement) nested.get(i);\n                UnknownElement o = (UnknownElement) other.nested.get(i);\n                if (!me.similar(o)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Convert the nested sequential to an unknown element\n     * @return the nested sequential as an unknown element.\n     */\n    public UnknownElement getNestedTask() {\n        UnknownElement ret = new UnknownElement("sequential");\n        ret.setTaskName("sequential");\n        ret.setNamespace("");\n        ret.setQName("sequential");\n        new RuntimeConfigurable(ret, "sequential");\n        final int size = nestedSequential.getNested().size();\n        for (int i = 0; i < size; ++i) {\n            UnknownElement e =\n                (UnknownElement) nestedSequential.getNested().get(i);\n            ret.addChild(e);\n            ret.getWrapper().addChild(e.getWrapper());\n        }\n        return ret;\n    }\n\n    /**\n     * Gets this macro's attribute (and define?) list.\n     *\n     * @return the nested Attributes\n     */\n    public List<Attribute> getAttributes() {\n        return attributes;\n    }\n\n    /**\n     * Gets this macro's elements.\n     *\n     * @return the map nested elements, keyed by element name, with\n     *         {@link TemplateElement} values.\n     */\n    public Map<String, TemplateElement> getElements() {\n        return elements;\n    }\n\n    /**\n     * Check if a character is a valid character for an element or\n     * attribute name.\n     *\n     * @param c the character to check\n     * @return true if the character is a letter or digit or '.' or '-'\n     *         attribute name\n     */\n    public static boolean isValidNameCharacter(char c) {\n        // ? is there an xml api for this ?\n        return Character.isLetterOrDigit(c) || c == '.' || c == '-';\n    }\n\n    /**\n     * Check if a string is a valid name for an element or attribute.\n     *\n     * @param name the string to check\n     * @return true if the name consists of valid name characters\n     */\n    private static boolean isValidName(String name) {\n        if (name.length() == 0) {\n            return false;\n        }\n        for (int i = 0; i < name.length(); ++i) {\n            if (!isValidNameCharacter(name.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Add an attribute element.\n     *\n     * @param attribute an attribute nested element.\n     */\n    public void addConfiguredAttribute(Attribute attribute) {\n        if (attribute.getName() == null) {\n            throw new BuildException(\n                "the attribute nested element needed a \\"name\\" attribute");\n        }\n        if (attribute.getName().equals(textName)) {\n            throw new BuildException(\n                "the name \\"" + attribute.getName()\n                + "\\" has already been used by the text element");\n        }\n        final int size = attributes.size();\n        for (int i = 0; i < size; ++i) {\n            Attribute att = (Attribute) attributes.get(i);\n            if (att.getName().equals(attribute.getName())) {\n                throw new BuildException(\n                    "the name \\"" + attribute.getName()\n                        + "\\" has already been used in "\n                        + "another attribute element");\n            }\n        }\n        attributes.add(attribute);\n    }\n\n    /**\n     * Add an element element.\n     *\n     * @param element an element nested element.\n     */\n    public void addConfiguredElement(TemplateElement element) {\n        if (element.getName() == null) {\n            throw new BuildException(\n                "the element nested element needed a \\"name\\" attribute");\n        }\n        if (elements.get(element.getName()) != null) {\n            throw new BuildException(\n                "the element " + element.getName()\n                + " has already been specified");\n        }\n        if (hasImplicitElement\n            || (element.isImplicit() && elements.size() != 0)) {\n            throw new BuildException(\n                "Only one element allowed when using implicit elements");\n        }\n        hasImplicitElement = element.isImplicit();\n        elements.put(element.getName(), element);\n    }\n\n    /**\n     * Create a new ant type based on the embedded tasks and types.\n     */\n    public void execute() {\n        if (nestedSequential == null) {\n            throw new BuildException("Missing sequential element");\n        }\n        if (name == null) {\n            throw new BuildException("Name not specified");\n        }\n\n        name = ProjectHelper.genComponentName(getURI(), name);\n\n        MyAntTypeDefinition def = new MyAntTypeDefinition(this);\n        def.setName(name);\n        def.setClass(MacroInstance.class);\n\n        ComponentHelper helper = ComponentHelper.getComponentHelper(\n            getProject());\n\n        helper.addDataTypeDefinition(def);\n        log("creating macro  " + name, Project.MSG_VERBOSE);\n    }\n\n\n    /**\n     * An attribute for the MacroDef task.\n     *\n     */\n    public static class Attribute {\n        private String name;\n        private String defaultValue;\n        private String description;\n        private boolean doubleExpanding = true;\n\n        /**\n         * The name of the attribute.\n         *\n         * @param name the name of the attribute\n         */\n        public void setName(String name) {\n            if (!isValidName(name)) {\n                throw new BuildException(\n                    "Illegal name [" + name + "] for attribute");\n            }\n            this.name = name.toLowerCase(Locale.ENGLISH);\n        }\n\n        /**\n         * @return the name of the attribute\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * The default value to use if the parameter is not\n         * used in the templated instance.\n         *\n         * @param defaultValue the default value\n         */\n        public void setDefault(String defaultValue) {\n            this.defaultValue = defaultValue;\n        }\n\n        /**\n         * @return the default value, null if not set\n         */\n        public String getDefault() {\n            return defaultValue;\n        }\n\n        /**\n         * @param desc Description of the element.\n         * @since ant 1.6.1\n         */\n        public void setDescription(String desc) {\n            description = desc;\n        }\n\n        /**\n         * @return the description of the element, or <code>null</code> if\n         *         no description is available.\n         * @since ant 1.6.1\n         */\n        public String getDescription() {\n            return description;\n        }\n\n        /**\n         * See {@link #isDoubleExpanding} for explanation.\n         * @param doubleExpanding true to expand twice, false for just once\n         * @since Ant 1.8.3\n         */\n        public void setDoubleExpanding(boolean doubleExpanding) {\n            this.doubleExpanding = doubleExpanding;\n        }\n\n        /**\n         * Determines whether {@link RuntimeConfigurable#maybeConfigure(Project, boolean)} will reevaluate this property.\n         * For compatibility reasons (#52621) it will, though for most applications (#42046) it should not.\n         * @return true if expanding twice (the default), false for just once\n         * @since Ant 1.8.3\n         */\n        public boolean isDoubleExpanding() {\n            return doubleExpanding;\n        }\n\n        /**\n         * equality method\n         *\n         * @param obj an <code>Object</code> value\n         * @return a <code>boolean</code> value\n         */\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (obj.getClass() != getClass()) {\n                return false;\n            }\n            Attribute other = (Attribute) obj;\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            if (defaultValue == null) {\n                if (other.defaultValue != null) {\n                    return false;\n                }\n            } else if (!defaultValue.equals(other.defaultValue)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @return a hash code value for this object.\n         */\n        public int hashCode() {\n            return objectHashCode(defaultValue) + objectHashCode(name);\n        }\n    }\n\n    /**\n     * A nested text element for the MacroDef task.\n     * @since ant 1.6.1\n     */\n    public static class Text {\n        private String  name;\n        private boolean optional;\n        private boolean trim;\n        private String  description;\n        private String  defaultString;\n\n        /**\n         * The name of the attribute.\n         *\n         * @param name the name of the attribute\n         */\n        public void setName(String name) {\n            if (!isValidName(name)) {\n                throw new BuildException(\n                    "Illegal name [" + name + "] for attribute");\n            }\n            this.name = name.toLowerCase(Locale.ENGLISH);\n        }\n\n        /**\n         * @return the name of the attribute\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * The optional attribute of the text element.\n         *\n         * @param optional if true this is optional\n         */\n        public void setOptional(boolean optional) {\n            this.optional = optional;\n        }\n\n        /**\n         * @return true if the text is optional\n         */\n        public boolean getOptional() {\n            return optional;\n        }\n\n        /**\n         * The trim attribute of the text element.\n         *\n         * @param trim if true this String.trim() is called on\n         *             the contents of the text element.\n         */\n        public void setTrim(boolean trim) {\n            this.trim = trim;\n        }\n\n        /**\n         * @return true if the text is trim\n         */\n        public boolean getTrim() {\n            return trim;\n        }\n\n        /**\n         * @param desc Description of the text.\n         */\n        public void setDescription(String desc) {\n            description = desc;\n        }\n\n        /**\n         * @return the description of the text, or <code>null</code> if\n         *         no description is available.\n         */\n        public String getDescription() {\n            return description;\n        }\n\n        /**\n         * @param defaultString default text for the string.\n         */\n        public void setDefault(String defaultString) {\n            this.defaultString = defaultString;\n        }\n\n        /**\n         * @return the default text if set, null otherwise.\n         */\n        public String getDefault() {\n            return defaultString;\n        }\n\n        /**\n         * equality method\n         *\n         * @param obj an <code>Object</code> value\n         * @return a <code>boolean</code> value\n         */\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (obj.getClass() != getClass()) {\n                return false;\n            }\n            Text other = (Text) obj;\n            return safeCompare(name, other.name)\n                && optional == other.optional\n                && trim == other.trim\n                && safeCompare(defaultString, other.defaultString);\n        }\n\n        /**\n         * @return a hash code value for this object.\n         */\n        public int hashCode() {\n            return objectHashCode(name);\n        }\n    }\n\n    private static boolean safeCompare(Object a, Object b) {\n        return a == null ? b == null : a.equals(b);\n    }\n\n    /**\n     * A nested element for the MacroDef task.\n     */\n    public static class TemplateElement {\n\n        private String name;\n        private String description;\n        private boolean optional = false;\n        private boolean implicit = false;\n\n        /**\n         * Sets the name of this element.\n         *\n         * @param name the name of the element\n         */\n        public void setName(String name) {\n            if (!isValidName(name)) {\n                throw new BuildException(\n                    "Illegal name [" + name + "] for macro element");\n            }\n            this.name = name.toLowerCase(Locale.ENGLISH);\n        }\n\n        /**\n         * Gets the name of this element.\n         *\n         * @return the name of the element.\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * Sets a textual description of this element,\n         * for build documentation purposes only.\n         *\n         * @param desc Description of the element.\n         * @since ant 1.6.1\n         */\n        public void setDescription(String desc) {\n            description = desc;\n        }\n\n        /**\n         * Gets the description of this element.\n         *\n         * @return the description of the element, or <code>null</code> if\n         *         no description is available.\n         * @since ant 1.6.1\n         */\n        public String getDescription() {\n            return description;\n        }\n\n        /**\n         * Sets whether this element is optional.\n         *\n         * @param optional if true this element may be left out, default\n         *                 is false.\n         */\n        public void setOptional(boolean optional) {\n            this.optional = optional;\n        }\n\n        /**\n         * Gets whether this element is optional.\n         *\n         * @return the optional attribute\n         */\n        public boolean isOptional() {\n            return optional;\n        }\n\n        /**\n         * Sets whether this element is implicit.\n         *\n         * @param implicit if true this element may be left out, default\n         *                 is false.\n         */\n        public void setImplicit(boolean implicit) {\n            this.implicit = implicit;\n        }\n\n        /**\n         * Gets whether this element is implicit.\n         *\n         * @return the implicit attribute\n         */\n        public boolean isImplicit() {\n            return implicit;\n        }\n\n        /**\n         * equality method.\n         *\n         * @param obj an <code>Object</code> value\n         * @return a <code>boolean</code> value\n         */\n        public boolean equals(Object obj) {\n            if (obj == this) {\n              return true;\n            }\n            if (obj == null || !obj.getClass().equals(getClass())) {\n                return false;\n            }\n            TemplateElement t = (TemplateElement) obj;\n            return\n                (name == null ? t.name == null : name.equals(t.name))\n                && optional == t.optional\n                && implicit == t.implicit;\n        }\n\n        /**\n         * @return a hash code value for this object.\n         */\n        public int hashCode() {\n            return objectHashCode(name)\n                + (optional ? 1 : 0) + (implicit ? 1 : 0);\n        }\n\n    } // END static class TemplateElement\n\n    /**\n     * same or similar equality method for macrodef, ignores project and\n     * runtime info.\n     *\n     * @param obj an <code>Object</code> value\n     * @param same if true test for sameness, otherwise just similar\n     * @return a <code>boolean</code> value\n     */\n    private boolean sameOrSimilar(Object obj, boolean same) {\n        if (obj == this) {\n            return true;\n        }\n\n        if (obj == null) {\n            return false;\n        }\n        if (!obj.getClass().equals(getClass())) {\n            return false;\n        }\n        MacroDef other = (MacroDef) obj;\n        if (name == null) {\n            return other.name == null;\n        }\n        if (!name.equals(other.name)) {\n            return false;\n        }\n        // Allow two macro definitions with the same location\n        // to be treated as similar - bugzilla 31215\n        if (other.getLocation() != null\n            && other.getLocation().equals(getLocation())\n            && !same) {\n            return true;\n        }\n        if (text == null) {\n            if (other.text != null) {\n                return false;\n            }\n        } else {\n            if (!text.equals(other.text)) {\n                return false;\n            }\n        }\n        if (getURI() == null || getURI().equals("")\n            || getURI().equals(ProjectHelper.ANT_CORE_URI)) {\n            if (!(other.getURI() == null || other.getURI().equals("")\n                  || other.getURI().equals(ProjectHelper.ANT_CORE_URI))) {\n                return false;\n            }\n        } else {\n            if (!getURI().equals(other.getURI())) {\n                return false;\n            }\n        }\n\n        if (!nestedSequential.similar(other.nestedSequential)) {\n            return false;\n        }\n        if (!attributes.equals(other.attributes)) {\n            return false;\n        }\n        if (!elements.equals(other.elements)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Similar method for this definition\n     *\n     * @param obj another definition\n     * @return true if the definitions are similar\n     */\n    public boolean similar(Object obj) {\n        return sameOrSimilar(obj, false);\n    }\n\n    /**\n     * Equality method for this definition\n     *\n     * @param obj another definition\n     * @return true if the definitions are the same\n     */\n    public boolean sameDefinition(Object obj) {\n        return sameOrSimilar(obj, true);\n    }\n\n    /**\n     * extends AntTypeDefinition, on create\n     * of the object, the template macro definition\n     * is given.\n     */\n    private static class MyAntTypeDefinition extends AntTypeDefinition {\n        private MacroDef macroDef;\n\n        /**\n         * Creates a new <code>MyAntTypeDefinition</code> instance.\n         *\n         * @param macroDef a <code>MacroDef</code> value\n         */\n        public MyAntTypeDefinition(MacroDef macroDef) {\n            this.macroDef = macroDef;\n        }\n\n        /**\n         * Create an instance of the definition.\n         * The instance may be wrapped in a proxy class.\n         * @param project the current project\n         * @return the created object\n         */\n        public Object create(Project project) {\n            Object o = super.create(project);\n            if (o == null) {\n                return null;\n            }\n            ((MacroInstance) o).setMacroDef(macroDef);\n            return o;\n        }\n\n        /**\n         * Equality method for this definition\n         *\n         * @param other another definition\n         * @param project the current project\n         * @return true if the definitions are the same\n         */\n        public boolean sameDefinition(AntTypeDefinition other, Project project) {\n            if (!super.sameDefinition(other, project)) {\n                return false;\n            }\n            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;\n            return macroDef.sameDefinition(otherDef.macroDef);\n        }\n\n        /**\n         * Similar method for this definition\n         *\n         * @param other another definition\n         * @param project the current project\n         * @return true if the definitions are the same\n         */\n        public boolean similarDefinition(\n            AntTypeDefinition other, Project project) {\n            if (!super.similarDefinition(other, project)) {\n                return false;\n            }\n            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;\n            return macroDef.similar(otherDef.macroDef);\n        }\n    }\n\n    private static int objectHashCode(Object o) {\n        if (o == null) {\n            return 0;\n        } else {\n            return o.hashCode();\n        }\n    }\n\n}	Feature Envy	Shotgun Surgery\n	Feature Envy\n	Long Method	MacroDef.java	84b29496676a8fca072ecfe34bc8f705	\N	Um método está mais interessado em outra classe do que aquela em que está realmente	NOA (Number of Operations Added), LOCC ((Lines of Concern Code), LCOM (Lack of Cohesion in Methods) 	Refatoração sugerida:Move Method	t	2
45	Identifique o Bad Smell na classe abaixo	/*\n * Copyright 2012 GitHub Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.github.mobile.ui;\n\nimport static android.os.Build.VERSION.SDK_INT;\nimport static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.View;\n\n/**\n * {@link ViewPager} extension with support for horizontally scrolling an\n * embedded {@link WebView}\n */\npublic class ViewPager extends android.support.v4.view.ViewPager {\n\n    /**\n     * @param context\n     */\n    public ViewPager(final Context context) {\n        super(context);\n    }\n\n    /**\n     * @param context\n     * @param attrs\n     */\n    public ViewPager(final Context context, final AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    /**\n     * Set current item and return whether the item changed\n     * \n\n     * This method does not call {@link #setCurrentItem(int)} unless the item\n     * parameter differs from the current item\n     *\n     * @param item\n     * @return true if set, false if same\n     */\n    public boolean setItem(final int item) {\n        final boolean changed = item != getCurrentItem();\n        if (changed)\n            setCurrentItem(item, false);\n        return changed;\n    }\n\n    /**\n     * Set current item, invoke the listener if changes, and return whether the\n     * item changed\n     * \n\n\n     * This method does not call {@link #setCurrentItem(int)} unless the item\n     * parameter differs from the current item\n     *\n     * @param item\n     * @param listener\n     * @return true if set, false if same\n     */\n    public boolean setItem(final int item, final OnPageChangeListener listener) {\n        final boolean changed = setItem(item);\n        if (changed && listener != null)\n            listener.onPageSelected(item);\n        return changed;\n    }\n\n    /**\n     * Schedule a call to {@link #setItem(int)} to occur on the UI-thread\n     *\n     * @param item\n     * @param listener\n     */\n    public void scheduleSetItem(final int item,\n            final OnPageChangeListener listener) {\n        post(new Runnable() {\n\n            @Override\n            public void run() {\n                setItem(item, listener);\n            }\n        });\n    }\n\n    /**\n     * Schedule a call to {@link #setItem(int)} to occur on the UI-thread\n     *\n     * @param item\n     */\n    public void scheduleSetItem(final int item) {\n        post(new Runnable() {\n\n            @Override\n            public void run() {\n                setItem(item);\n            }\n        });\n    }\n\n    @Override\n    protected boolean canScroll(final View v, final boolean checkV,\n            final int dx, final int x, final int y) {\n        if (SDK_INT < ICE_CREAM_SANDWICH && v instanceof WebView)\n            return ((WebView) v).canScrollHorizontally(-dx);\n        else\n            return super.canScroll(v, checkV, dx, x, y);\n    }\n}	God Class	Divergent Change\n	Long Method\n	Feature Envy\n	ViewPager	a11020143047a5100ce24af8367610aa	\N	Uma classe implementando várias responsabilidades, tendo um grande número de atributos, operações e dependências com classes de dados 	LOC (Lines of Code), WMC (Weighted Method per Class), CBO (Coupling Betwenn Object Classes); LCOM (Lack of Cohesion in Methods)	Refatoração sugerida:Extract Subclass	t	2
46	Identifique o Bad Smell na classe abaixo	/*\n * Copyright  2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.taskdefs.optional.ejb;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.SAXParser;\nimport org.apache.tools.ant.AntClassLoader;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.Java;\nimport org.apache.tools.ant.types.Path;\n\n/**\n * The deployment tool to add the jonas specific deployment descriptors to the\n * ejb JAR file. JONAS only requires one additional file jonas-ejb-jar.xml.\n *\n * @version 1.0\n * @see EjbJar#createJonas\n */\npublic class JonasDeploymentTool extends GenericDeploymentTool {\n\n    /** Public Id of the standard deployment descriptor DTD. */\n    protected static final String EJB_JAR_1_1_PUBLIC_ID\n        = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN";\n    protected static final String EJB_JAR_2_0_PUBLIC_ID\n        = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN";\n\n    /** Public Id of the JOnAS-specific deployment descriptor DTD. */\n    protected static final String JONAS_EJB_JAR_2_4_PUBLIC_ID\n        = "-//ObjectWeb//DTD JOnAS 2.4//EN";\n    protected static final String JONAS_EJB_JAR_2_5_PUBLIC_ID\n        = "-//ObjectWeb//DTD JOnAS 2.5//EN";\n\n    /** RMI ORB. */\n    protected static final String RMI_ORB = "RMI";\n\n    /** JEREMIE ORB. */\n    protected static final String JEREMIE_ORB = "JEREMIE";\n\n    /** DAVID ORB. */\n    protected static final String DAVID_ORB = "DAVID";\n\n    /**\n     * Name of the standard deployment descriptor DTD (these files are stored in\n     * the ${JONAS_ROOT}/xml directory).\n     */\n    protected static final String EJB_JAR_1_1_DTD = "ejb-jar_1_1.dtd";\n    protected static final String EJB_JAR_2_0_DTD = "ejb-jar_2_0.dtd";\n\n    /**\n     * Name of the JOnAS-specific deployment descriptor DTD (these files are\n     * stored in the ${JONAS_ROOT}/xml directory).\n     */\n    protected static final String JONAS_EJB_JAR_2_4_DTD\n        = "jonas-ejb-jar_2_4.dtd";\n    protected static final String JONAS_EJB_JAR_2_5_DTD\n        = "jonas-ejb-jar_2_5.dtd";\n\n    /** Default JOnAS deployment descriptor name. */\n    protected static final String JONAS_DD = "jonas-ejb-jar.xml";\n\n    /** GenIC class name (JOnAS 2.5) */\n    protected static final String GENIC_CLASS =\n    "org.objectweb.jonas_ejb.genic.GenIC";\n\n    /** Old GenIC class name (JOnAS 2.4.x). */\n    protected static final String OLD_GENIC_CLASS_1 =\n        "org.objectweb.jonas_ejb.tools.GenWholeIC";\n\n    /** Old GenIC class name. */\n    protected static final String OLD_GENIC_CLASS_2 =\n        "org.objectweb.jonas_ejb.tools.GenIC";\n\n    /**\n     * Filename of the standard EJB descriptor (which is passed to this class\n     * from the parent "ejbjar" task). This file is relative to the directory\n     * specified by the "srcdir" attribute in the ejbjar task.\n     */\n    private String descriptorName;\n\n    /**\n     * Filename of the JOnAS-specific EJB descriptor (which is passed to this\n     * class from the parent "ejbjar" task). This file is relative to the\n     * directory specified by the "srcdir" attribute in the ejbjar task.\n     */\n    private String jonasDescriptorName;\n\n    /* ------------- */\n    /* GenIC options */\n    /* ------------- */\n\n    /**\n     * Temporary output directory used by GenIC.\n     */\n    private File outputdir;\n\n    /**\n     * <code>true</code> if the intermediate Java source files generated by\n     * GenIC must be deleted or not. The default is <code>false</code>\n     */\n    private boolean keepgenerated = false;\n\n    /**\n     * <code>true</code> if the generated source files must not be compiled via\n     * the java and rmi compilers. The default is <code>false</code>.\n     */\n    private boolean nocompil = false;\n\n    /**\n     * <code>true</code> if the XML deployment descriptors must be parsed\n     * without validation. The default is <code>false</code>.\n     */\n    private boolean novalidation = false;\n\n    /**\n     * Java compiler to use. The default is the value of\n     * <code>build.compiler</code> property.\n     */\n    private String javac;\n\n    /** Options to pass to the java compiler. */\n    private String javacopts;\n\n    /** Options to pass to the rmi compiler. */\n    private String rmicopts;\n\n    /**\n     * Whether or not the RMI skeleton and stub must be modified to\n     * implement the implicit propagation of the security context (the\n     * transactional context is always provided). The default is\n     * <code>false</code>.\n     */\n    private boolean secpropag = false;\n\n    /**\n     * <code>true</code> if the GenIC call must be verbose. The default\n     * is <code>false</code>.\n     */\n    private boolean verbose = false;\n\n    /** Additional args to send to GenIC. */\n    private String additionalargs;\n\n    /* ------------- */\n    /* other options */\n    /* ------------- */\n\n    /** JOnAS root directory. */\n    private File jonasroot;\n\n    /**\n     * <code>true</code> if the generic JAR file used as input to GenIC must be\n     * retained. The default is <code>false</code>.\n     */\n    private boolean keepgeneric = false;\n\n    /** Stores the suffix for the JOnAS JAR file. The default is '.jar'. */\n    private String suffix = ".jar";\n\n    /**\n     *  ORB to use (RMI, JEREMIE or DAVID). If omitted, it defaults to the one\n     *  present in classpath. If specified, the corresponding JOnAS JAR is\n     *  automatically added to the classpath.\n     */\n    private String orb;\n\n    /**\n     * <code>true</code> if GenIC must not be run on the EJB JAR.\n     * The default is <code>false</code>.\n     */\n    private boolean nogenic = false;\n\n    /* -------------------- */\n    /* GenIC options setter */\n    /* -------------------- */\n\n    /**\n     * Set the {@link #keepgenerated} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setKeepgenerated(boolean aBoolean) {\n        keepgenerated = aBoolean;\n    }\n\n    /**\n     * Set the {@link #additionalargs}.\n     *\n     * @param aString additional args.\n     */\n    public void setAdditionalargs(String aString) {\n        additionalargs = aString;\n    }\n\n    /**\n     * Set the {@link #nocompil} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setNocompil(boolean aBoolean) {\n        nocompil = aBoolean;\n    }\n\n    /**\n     * Set the {@link #novalidation} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setNovalidation(boolean aBoolean) {\n        novalidation = aBoolean;\n    }\n\n    /**\n     * Set the java compiler {@link #javac} to use.\n     *\n     * @param aString the java compiler.\n     */\n    public void setJavac(String aString) {\n        javac = aString;\n    }\n\n    /**\n     * Set the options to pass to the java compiler.\n     *\n     * @param aString the options.\n     */\n    public void setJavacopts(String aString) {\n        javacopts = aString;\n    }\n\n    /**\n     * Set the options to pass to the rmi compiler.\n     *\n     * @param aString the options.\n     */\n    public void setRmicopts(String aString) {\n        rmicopts = aString;\n    }\n\n    /**\n     * Set the {@link #secpropag} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setSecpropag(boolean aBoolean) {\n        secpropag = aBoolean;\n    }\n\n    /**\n     * Set the {@link #verbose} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setVerbose(boolean aBoolean) {\n        verbose = aBoolean;\n    }\n\n    /* -------------------- */\n    /* other options setter */\n    /* -------------------- */\n\n    /**\n     * Set the JOnAS root directory.\n     *\n     * @param aFile the JOnAS root directory.\n     */\n    public void setJonasroot(File aFile) {\n        jonasroot = aFile;\n    }\n\n    /**\n     * Set the {@link #keepgeneric} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setKeepgeneric(boolean aBoolean) {\n        keepgeneric = aBoolean;\n    }\n\n    /**\n     * Set the {@link #suffix jar suffix}.\n     *\n     * @param aString the string to use as the suffix.\n     */\n    public void setJarsuffix(String aString) {\n        suffix = aString;\n    }\n\n    /**\n     * Set the {@link #orb} to construct classpath.\n     *\n     * @param aString 'RMI', 'JEREMIE', or 'DAVID'.\n     */\n    public void setOrb(String aString) {\n        orb = aString;\n    }\n\n    /**\n     * Set the {@link #nogenic} flag.\n     *\n     * @param aBoolean <code>true</code> if the flag must be set.\n     */\n    public void setNogenic(boolean aBoolean) {\n        nogenic = aBoolean;\n    }\n\n    /* ------------- */\n    /* other methods */\n    /* ------------- */\n\n    public void processDescriptor(String aDescriptorName, SAXParser saxParser) {\n\n        descriptorName = aDescriptorName;\n\n        log("JOnAS Deployment Tool processing: " + descriptorName,\n            Project.MSG_VERBOSE);\n\n        super.processDescriptor(descriptorName, saxParser);\n\n        if (outputdir != null) {\n            // the method deleteOnExit() do not work because the directory is not empty\n            log("Deleting temp output directory '" + outputdir + "'.", Project.MSG_VERBOSE);\n            deleteAllFiles(outputdir);\n        }\n    }\n\n    protected void writeJar(String baseName, File jarfile, Hashtable ejbFiles, String publicId)\n    throws BuildException {\n\n        // create the generic jar first\n        File genericJarFile = super.getVendorOutputJarFile(baseName);\n        super.writeJar(baseName, genericJarFile, ejbFiles, publicId);\n\n        // GenIC call on generic jar\n        addGenICGeneratedFiles(genericJarFile, ejbFiles);\n\n        // create the real jar\n        super.writeJar(baseName, getVendorOutputJarFile(baseName), ejbFiles, publicId);\n\n        if (!keepgeneric) {\n            log("Deleting generic JAR " + genericJarFile.toString(), Project.MSG_VERBOSE);\n            genericJarFile.delete();\n        }\n    }\n\n    protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {\n\n    // JOnAS-specific descriptor deployment\n    jonasDescriptorName = getJonasDescriptorName();\n        File jonasDD = new File(getConfig().descriptorDir, jonasDescriptorName);\n\n        if (jonasDD.exists()) {\n            ejbFiles.put(META_DIR + JONAS_DD, jonasDD);\n        } else {\n            log("Unable to locate the JOnAS deployment descriptor. It was expected to be in: "\n                + jonasDD.getPath() + ".", Project.MSG_WARN);\n        }\n    }\n\n    protected File getVendorOutputJarFile(String baseName) {\n        return new File(getDestDir(), baseName + suffix);\n    }\n\n    /**\n     * Determines the name of the JOnAS-specific EJB descriptor using the\n     * specified standard EJB descriptor name. In general, the standard\n     * descriptor will be named "[basename]-ejb-jar.xml", and this method will\n     * return "[basename]-jonas-ejb-jar.xml" or "jonas-[basename].xml"\n     *\n     * @return The name of the JOnAS-specific EJB descriptor file.\n     */\n    private String getJonasDescriptorName() {\n\n        // descriptorName = <path><basename><basenameterminator><remainder>\n        // examples = /org/objectweb/fooAppli/foo/Foo-ejb-jar.xml\n        // examples = /org/objectweb/fooAppli/foo/Foo.xml (JOnAS convention)\n\n        String jonasDescriptorName; // JOnAS-specific DD\n        boolean jonasConvention = false; // true if the JOnAS convention is used for the DD\n        String path;            // Directory path of the EJB descriptor\n        String fileName;        // EJB descriptor file name\n        String baseName;        // Filename appearing before name terminator\n        String remainder;       // Filename appearing after the name terminator\n\n        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);\n        if (startOfFileName != -1) {\n            // extract path info\n            path = descriptorName.substring(0, startOfFileName + 1);\n            fileName = descriptorName.substring(startOfFileName + 1);\n        } else {\n            // descriptorName is just a file without path\n            path = "";\n            fileName = descriptorName;\n        }\n\n        if (fileName.startsWith(EJB_DD)) {\n            return path + JONAS_DD;\n        }\n\n        int endOfBaseName = descriptorName.indexOf(getConfig().baseNameTerminator, startOfFileName);\n\n        /*\n         * Check for the odd case where the terminator and/or filename\n         * extension aren't found.  These will ensure "jonas-" appears at the\n         * end of the name and before the '.' (if present).\n         */\n        if (endOfBaseName < 0) {\n            // baseNameTerminator not found: the descriptor use the\n            // JOnAS naming convention, ie [Foo.xml,jonas-Foo.xml] and\n            // not [Foo<baseNameTerminator>-ejb-jar.xml,\n            // Foo<baseNameTerminator>-jonas-ejb-jar.xml].\n            endOfBaseName = descriptorName.lastIndexOf('.') - 1;\n            if (endOfBaseName < 0) {\n                // no . found\n                endOfBaseName = descriptorName.length() - 1;\n            }\n\n            jonasConvention = true;\n        }\n\n        baseName = descriptorName.substring(startOfFileName + 1, endOfBaseName + 1);\n        remainder = descriptorName.substring(endOfBaseName + 1);\n\n        if (jonasConvention) {\n            jonasDescriptorName = path + "jonas-" + baseName + ".xml";\n        } else {\n            jonasDescriptorName = path + baseName + "jonas-" + remainder;\n        }\n\n        log("Standard EJB descriptor name: " + descriptorName, Project.MSG_VERBOSE);\n        log("JOnAS-specific descriptor name: " + jonasDescriptorName, Project.MSG_VERBOSE);\n\n        return jonasDescriptorName;\n    }\n\n    protected String getJarBaseName(String descriptorFileName) {\n\n        String baseName = null;\n\n        if (getConfig().namingScheme.getValue().equals(EjbJar.NamingScheme.DESCRIPTOR)) {\n\n            // try to find JOnAS specific convention name\n            if (descriptorFileName.indexOf(getConfig().baseNameTerminator) == -1) {\n\n                // baseNameTerminator not found: the descriptor use the\n                // JOnAS naming convention, ie [Foo.xml,jonas-Foo.xml] and\n                // not [Foo<baseNameTerminator>-ejb-jar.xml,\n                // Foo<baseNameTerminator>-jonas-ejb-jar.xml].\n\n                String aCanonicalDescriptor = descriptorFileName.replace('\\\\', '/');\n                int lastSeparatorIndex = aCanonicalDescriptor.lastIndexOf('/');\n                int endOfBaseName;\n\n                if (lastSeparatorIndex != -1) {\n                    endOfBaseName = descriptorFileName.indexOf(".xml", lastSeparatorIndex);\n                } else {\n                    endOfBaseName = descriptorFileName.indexOf(".xml");\n                }\n\n                if (endOfBaseName != -1) {\n                    baseName = descriptorFileName.substring(0, endOfBaseName);\n                }\n            }\n        }\n\n        if (baseName == null) {\n            // else get standard baseName\n            baseName = super.getJarBaseName(descriptorFileName);\n        }\n\n        log("JAR base name: " + baseName, Project.MSG_VERBOSE);\n\n        return baseName;\n    }\n\n    protected void registerKnownDTDs(DescriptorHandler handler) {\n        handler.registerDTD(EJB_JAR_1_1_PUBLIC_ID,\n                    jonasroot + File.separator + "xml" + File.separator + EJB_JAR_1_1_DTD);\n        handler.registerDTD(EJB_JAR_2_0_PUBLIC_ID,\n                    jonasroot + File.separator + "xml" + File.separator + EJB_JAR_2_0_DTD);\n\n        handler.registerDTD(JONAS_EJB_JAR_2_4_PUBLIC_ID,\n                    jonasroot + File.separator + "xml" + File.separator + JONAS_EJB_JAR_2_4_DTD);\n        handler.registerDTD(JONAS_EJB_JAR_2_5_PUBLIC_ID,\n                    jonasroot + File.separator + "xml" + File.separator + JONAS_EJB_JAR_2_5_DTD);\n    }\n\n    /**\n     * Add to the given hashtable all the file generated by GenIC.\n     *\n     * @param genericJarFile jar file.\n     * @param ejbFiles the hashtable.\n     */\n    private void addGenICGeneratedFiles(File genericJarFile, Hashtable ejbFiles) {\n        // GenIC task\n        Java genicTask = null;\n\n        // GenIC class (3 GenIC classes for various versions of JOnAS\n        // are supported)\n        String genicClass = null;\n\n        if (nogenic) {\n            return;\n        }\n\n        genicTask = (Java) getTask().getProject().createTask("java");\n        genicTask.setTaskName("genic");\n        genicTask.setFork(true);\n\n        // jonasroot\n        genicTask.createJvmarg().setValue("-Dinstall.root=" + jonasroot);\n\n        // java policy file\n        String jonasConfigDir = jonasroot + File.separator + "config";\n        File javaPolicyFile = new File(jonasConfigDir, "java.policy");\n        if (javaPolicyFile.exists()) {\n            genicTask.createJvmarg().setValue("-Djava.security.policy="\n                              + javaPolicyFile.toString());\n        }\n\n        // outputdir\n        try {\n            outputdir = createTempDir();\n        } catch (IOException aIOException) {\n            String msg = "Cannot create temp dir: " + aIOException.getMessage();\n            throw new BuildException(msg, aIOException);\n        }\n        log("Using temporary output directory: " + outputdir, Project.MSG_VERBOSE);\n\n        genicTask.createArg().setValue("-d");\n        genicTask.createArg().setFile(outputdir);\n\n        // work around a bug of GenIC 2.5\n        String key;\n        File f;\n        Enumeration keys = ejbFiles.keys();\n        while (keys.hasMoreElements()) {\n            key = (String) keys.nextElement();\n            f = new File(outputdir + File.separator + key);\n            f.getParentFile().mkdirs();\n        }\n        log("Worked around a bug of GenIC 2.5.", Project.MSG_VERBOSE);\n\n        // classpath\n        Path classpath = getCombinedClasspath();\n        if (classpath == null) {\n            classpath = new Path(getTask().getProject());\n        }\n        classpath.append(new Path(classpath.getProject(), jonasConfigDir));\n        classpath.append(new Path(classpath.getProject(), outputdir.toString()));\n\n        // try to create the classpath for the correct ORB\n        if (orb != null) {\n            String orbJar = jonasroot + File.separator + "lib"\n                + File.separator + orb + "_jonas.jar";\n            classpath.append(new Path(classpath.getProject(), orbJar));\n        }\n\n        log("Using classpath: " + classpath.toString(), Project.MSG_VERBOSE);\n        genicTask.setClasspath(classpath);\n\n        // class name (search in the classpath provided for the ejbjar element)\n        genicClass = getGenicClassName(classpath);\n        if (genicClass == null) {\n            log("Cannot find GenIC class in classpath.", Project.MSG_ERR);\n            throw new BuildException("GenIC class not found, please check the classpath.");\n        } else {\n            log("Using '" + genicClass + "' GenIC class." , Project.MSG_VERBOSE);\n            genicTask.setClassname(genicClass);\n        }\n\n        // keepgenerated\n        if (keepgenerated) {\n            genicTask.createArg().setValue("-keepgenerated");\n        }\n\n        // nocompil\n        if (nocompil) {\n            genicTask.createArg().setValue("-nocompil");\n        }\n\n        // novalidation\n        if (novalidation) {\n            genicTask.createArg().setValue("-novalidation");\n        }\n\n        // javac\n        if (javac != null) {\n            genicTask.createArg().setValue("-javac");\n            genicTask.createArg().setLine(javac);\n        }\n\n        // javacopts\n        if (javacopts != null && !javacopts.equals("")) {\n            genicTask.createArg().setValue("-javacopts");\n            genicTask.createArg().setLine(javacopts);\n        }\n\n        // rmicopts\n        if (rmicopts != null && !rmicopts.equals("")) {\n            genicTask.createArg().setValue("-rmicopts");\n            genicTask.createArg().setLine(rmicopts);\n        }\n\n        // secpropag\n        if (secpropag) {\n            genicTask.createArg().setValue("-secpropag");\n        }\n\n        // verbose\n        if (verbose) {\n            genicTask.createArg().setValue("-verbose");\n                }\n\n        // additionalargs\n        if (additionalargs != null) {\n            genicTask.createArg().setValue(additionalargs);\n        }\n\n        // the generated classes must not be added in the generic JAR!\n        // is that buggy on old JOnAS (2.4) ??\n        genicTask.createArg().setValue("-noaddinjar");\n\n        // input file to process by GenIC\n        genicTask.createArg().setValue(genericJarFile.getPath());\n\n        // calling GenIC task\n        log("Calling " + genicClass + " for " + getConfig().descriptorDir\n            + File.separator + descriptorName + ".", Project.MSG_VERBOSE);\n\n        if (genicTask.executeJava() != 0) {\n\n            // the method deleteOnExit() do not work because the directory is not empty\n            log("Deleting temp output directory '" + outputdir + "'.", Project.MSG_VERBOSE);\n            deleteAllFiles(outputdir);\n\n            if (!keepgeneric) {\n            log("Deleting generic JAR " + genericJarFile.toString(), Project.MSG_VERBOSE);\n            genericJarFile.delete();\n            }\n\n            throw new BuildException("GenIC reported an error.");\n        }\n\n        // add the generated files to the ejbFiles\n        addAllFiles(outputdir, "", ejbFiles);\n    }\n\n    /**\n     * Get the GenIC class name to use in the given classpath.\n     *\n     * @param classpath classpath where the GenIC class must be searched.\n     * @return the GenIC class name. Return <code>null</code> if the class name\n     * cannot be found.\n     */\n    String getGenicClassName(Path classpath) {\n\n        log("Looking for GenIC class in classpath: "\n            + classpath.toString(), Project.MSG_VERBOSE);\n\n        AntClassLoader cl = classpath.getProject().createClassLoader(classpath);\n\n        try {\n            cl.loadClass(JonasDeploymentTool.GENIC_CLASS);\n            log("Found GenIC class '" + JonasDeploymentTool.GENIC_CLASS\n                + "' in classpath.", Project.MSG_VERBOSE);\n            return JonasDeploymentTool.GENIC_CLASS;\n\n        } catch (ClassNotFoundException cnf1) {\n            log("GenIC class '" + JonasDeploymentTool.GENIC_CLASS\n                + "' not found in classpath.",\n            Project.MSG_VERBOSE);\n        }\n\n        try {\n            cl.loadClass(JonasDeploymentTool.OLD_GENIC_CLASS_1);\n            log("Found GenIC class '" + JonasDeploymentTool.OLD_GENIC_CLASS_1\n                + "' in classpath.", Project.MSG_VERBOSE);\n            return JonasDeploymentTool.OLD_GENIC_CLASS_1;\n\n        } catch (ClassNotFoundException cnf2) {\n            log("GenIC class '" + JonasDeploymentTool.OLD_GENIC_CLASS_1\n                + "' not found in classpath.",\n            Project.MSG_VERBOSE);\n        }\n\n        try {\n            cl.loadClass(JonasDeploymentTool.OLD_GENIC_CLASS_2);\n            log("Found GenIC class '" + JonasDeploymentTool.OLD_GENIC_CLASS_2\n                + "' in classpath.", Project.MSG_VERBOSE);\n            return JonasDeploymentTool.OLD_GENIC_CLASS_2;\n\n        } catch (ClassNotFoundException cnf3) {\n            log("GenIC class '" + JonasDeploymentTool.OLD_GENIC_CLASS_2\n                + "' not found in classpath.",\n            Project.MSG_VERBOSE);\n        }\n        return null;\n    }\n\n    protected void checkConfiguration(String descriptorFileName,\n                      SAXParser saxParser) throws BuildException {\n\n        // jonasroot\n        if (jonasroot == null) {\n            throw new BuildException("The jonasroot attribut is not set.");\n        } else if (!jonasroot.isDirectory()) {\n            throw new BuildException("The jonasroot attribut '" + jonasroot\n                + "' is not a valid directory.");\n        }\n\n        // orb\n        if (orb != null && !orb.equals(RMI_ORB) && !orb.equals(JEREMIE_ORB)\n            && !orb.equals(DAVID_ORB)) {\n            throw new BuildException("The orb attribut '" + orb\n                + "' is not valid (must be either "\n                + RMI_ORB + ", " + JEREMIE_ORB + " or " + DAVID_ORB + ").");\n        }\n\n        // additionalargs\n        if (additionalargs != null && additionalargs.equals("")) {\n            throw new BuildException("Empty additionalargs attribut.");\n        }\n\n        // javac\n        if (javac != null && javac.equals("")) {\n            throw new BuildException("Empty javac attribut.");\n        }\n    }\n\n    /* ----------------------------------------------------------------------------------- */\n    /* utilitary methods */\n    /* ----------------------------------------------------------------------------------- */\n\n    /**\n     * Create a temporary directory for GenIC output.\n     *\n     * @return the temp directory.\n     * @throws BuildException if a temp directory cannot be created.\n     */\n    private File createTempDir() throws IOException {\n        File tmpDir = File.createTempFile("genic", null, null);\n        tmpDir.delete();\n        if (!tmpDir.mkdir()) {\n            throw new IOException("Cannot create the temporary directory '" + tmpDir + "'.");\n        }\n        return tmpDir;\n    }\n\n    /**\n     * Delete a file. If the file is a directory, delete recursivly all the\n     * files inside.\n     *\n     * @param aFile file to delete.\n     */\n    private void deleteAllFiles(File aFile) {\n        if (aFile.isDirectory()) {\n            File[] someFiles = aFile.listFiles();\n\n            for (int i = 0; i < someFiles.length; i++) {\n                deleteAllFiles(someFiles[i]);\n            }\n        }\n        aFile.delete();\n    }\n\n    /**\n     * Add a file to the a given hashtable. If the file is a directory, add\n     * recursivly all the files inside to the hashtable.\n     *\n     * @param file the file to add.\n     * @param rootDir the current sub-directory to scan.\n     * @param hashtable the hashtable where to add the files.\n     */\n    private void addAllFiles(File file, String rootDir, Hashtable hashtable) {\n\n        if (!file.exists()) {\n            throw new IllegalArgumentException();\n        }\n\n        String newRootDir;\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                if (rootDir.length() > 0) {\n                    newRootDir = rootDir + File.separator + files[i].getName();\n                } else {\n                    newRootDir = files[i].getName();\n                }\n                addAllFiles(files[i], newRootDir, hashtable);\n            }\n        } else {\n            hashtable.put(rootDir, file);\n        }\n    }\n}	Long Method	Feature Envy\n	Divergent Change\n	God Class	JonasDeploymentTool.java	19d9e603f8694c4764c33bce53be5b0c	\N	Quando métodos que centralizam a funcionalidade da classe	LOC (Lines of Code), NCO (Number Concerns per Operations), NCC (Number Concerns per Component)	Refatoração sugerida:  Replace Method with Method Object	t	3
48	Identifique o Bad Smell na classe abaixo	/*\n * Copyright  2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.taskdefs.optional;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.types.EnumeratedAttribute;\nimport org.apache.tools.ant.types.PropertySet;\nimport org.apache.tools.ant.util.CollectionUtils;\nimport org.apache.tools.ant.util.DOMElementWriter;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n *  Displays all the current properties in the build. The output can be sent to\n *  a file if desired. <P>\n *\n *  Attribute "destfile" defines a file to send the properties to. This can be\n *  processed as a standard property file later. <P>\n *\n *  Attribute "prefix" defines a prefix which is used to filter the properties\n *  only those properties starting with this prefix will be echoed. <P>\n *\n *  By default, the "failonerror" attribute is enabled. If an error occurs while\n *  writing the properties to a file, and this attribute is enabled, then a\n *  BuildException will be thrown. If disabled, then IO errors will be reported\n *  as a log statement, but no error will be thrown. <P>\n *\n *  Examples: <pre>\n *  &lt;echoproperties  /&gt;\n * </pre> Report the current properties to the log. <P>\n *\n *  <pre>\n *  &lt;echoproperties destfile="my.properties" /&gt;\n * </pre> Report the current properties to the file "my.properties", and will\n *  fail the build if the file could not be created or written to. <P>\n *\n *  <pre>\n *  &lt;echoproperties destfile="my.properties" failonerror="false"\n *      prefix="ant" /&gt;\n * </pre> Report all properties beginning with 'ant' to the file\n *  "my.properties", and will log a message if the file could not be created or\n *  written to, but will still allow the build to continue.\n *\n *@since      Ant 1.5\n */\npublic class EchoProperties extends Task {\n\n    /**\n     * the properties element.\n     */\n    private static final String PROPERTIES = "properties";\n\n    /**\n     * the property element.\n     */\n    private static final String PROPERTY = "property";\n\n    /**\n     * name attribute for property, testcase and testsuite elements.\n     */\n    private static final String ATTR_NAME = "name";\n\n    /**\n     * value attribute for property elements.\n     */\n    private static final String ATTR_VALUE = "value";\n\n    /**\n     * the input file.\n     */\n    private File inFile = null;\n\n    /**\n     *  File object pointing to the output file. If this is null, then\n     *  we output to the project log, not to a file.\n     */\n    private File destfile = null;\n\n    /**\n     *  If this is true, then errors generated during file output will become\n     *  build errors, and if false, then such errors will be logged, but not\n     *  thrown.\n     */\n    private boolean failonerror = true;\n\n    private Vector propertySets = new Vector();\n\n    private String format = "text";\n\n    /**\n     * Sets the input file.\n     *\n     * @param file  the input file\n     */\n    public void setSrcfile(File file) {\n        inFile = file;\n    }\n\n    /**\n     *  Set a file to store the property output.  If this is never specified,\n     *  then the output will be sent to the Ant log.\n     *\n     *@param destfile file to store the property output\n     */\n    public void setDestfile(File destfile) {\n        this.destfile = destfile;\n    }\n\n\n    /**\n     * If true, the task will fail if an error occurs writing the properties\n     * file, otherwise errors are just logged.\n     *\n     *@param  failonerror  <tt>true</tt> if IO exceptions are reported as build\n     *      exceptions, or <tt>false</tt> if IO exceptions are ignored.\n     */\n    public void setFailOnError(boolean failonerror) {\n        this.failonerror = failonerror;\n    }\n\n\n    /**\n     *  If the prefix is set, then only properties which start with this\n     *  prefix string will be recorded.  If this is never set, or it is set\n     *  to an empty string or <tt>null</tt>, then all properties will be\n     *  recorded. <P>\n     *\n     *  For example, if the property is set as:\n     *    <PRE>&lt;echoproperties  prefix="ant." /&gt;</PRE>\n     *  then the property "ant.home" will be recorded, but "ant-example"\n     *  will not.\n     *\n     *@param  prefix  The new prefix value\n     */\n    public void setPrefix(String prefix) {\n        PropertySet ps = new PropertySet();\n        ps.setProject(getProject());\n        ps.appendPrefix(prefix);\n        addPropertyset(ps);\n    }\n\n    /**\n     * A set of properties to write.\n     *\n     * @since Ant 1.6\n     */\n    public void addPropertyset(PropertySet ps) {\n        propertySets.addElement(ps);\n    }\n\n    public void setFormat(FormatAttribute ea) {\n        format = ea.getValue();\n    }\n\n    public static class FormatAttribute extends EnumeratedAttribute {\n        private String [] formats = new String[]{"xml", "text"};\n\n        public String[] getValues() {\n            return formats;\n        }\n    }\n\n    /**\n     *  Run the task.\n     *\n     *@exception  BuildException  trouble, probably file IO\n     */\n    public void execute() throws BuildException {\n        //copy the properties file\n        Hashtable allProps = new Hashtable();\n\n        /* load properties from file if specified, otherwise\n        use Ant's properties */\n        if (inFile == null && propertySets.size() == 0) {\n            // add ant properties\n            CollectionUtils.putAll(allProps, getProject().getProperties());\n        } else if (inFile != null) {\n            if (inFile.exists() && inFile.isDirectory()) {\n                String message = "srcfile is a directory!";\n                if (failonerror) {\n                    throw new BuildException(message, getLocation());\n                } else {\n                    log(message, Project.MSG_ERR);\n                }\n                return;\n            }\n\n            if (inFile.exists() && !inFile.canRead()) {\n                String message = "Can not read from the specified srcfile!";\n                if (failonerror) {\n                    throw new BuildException(message, getLocation());\n                } else {\n                    log(message, Project.MSG_ERR);\n                }\n                return;\n            }\n\n            FileInputStream in = null;\n            try {\n                in = new FileInputStream(inFile);\n                Properties props = new Properties();\n                props.load(in);\n                CollectionUtils.putAll(allProps, props);\n            } catch (FileNotFoundException fnfe) {\n                String message =\n                    "Could not find file " + inFile.getAbsolutePath();\n                if (failonerror) {\n                    throw new BuildException(message, fnfe, getLocation());\n                } else {\n                    log(message, Project.MSG_WARN);\n                }\n                return;\n            } catch (IOException ioe) {\n                String message =\n                    "Could not read file " + inFile.getAbsolutePath();\n                if (failonerror) {\n                    throw new BuildException(message, ioe, getLocation());\n                } else {\n                    log(message, Project.MSG_WARN);\n                }\n                return;\n            } finally {\n                try {\n                    if (null != in) {\n                        in.close();\n                    }\n                } catch (IOException ioe) {\n                    //ignore\n                }\n            }\n        }\n\n        Enumeration e = propertySets.elements();\n        while (e.hasMoreElements()) {\n            PropertySet ps = (PropertySet) e.nextElement();\n            CollectionUtils.putAll(allProps, ps.getProperties());\n        }\n\n        OutputStream os = null;\n        try {\n            if (destfile == null) {\n                os = new ByteArrayOutputStream();\n                saveProperties(allProps, os);\n                log(os.toString(), Project.MSG_INFO);\n            } else {\n                if (destfile.exists() && destfile.isDirectory()) {\n                    String message = "destfile is a directory!";\n                    if (failonerror) {\n                        throw new BuildException(message, getLocation());\n                    } else {\n                        log(message, Project.MSG_ERR);\n                    }\n                    return;\n                }\n\n                if (destfile.exists() && !destfile.canWrite()) {\n                    String message =\n                        "Can not write to the specified destfile!";\n                    if (failonerror) {\n                        throw new BuildException(message, getLocation());\n                    } else {\n                        log(message, Project.MSG_ERR);\n                    }\n                    return;\n                }\n                os = new FileOutputStream(this.destfile);\n                saveProperties(allProps, os);\n            }\n        } catch (IOException ioe) {\n            if (failonerror) {\n                throw new BuildException(ioe, getLocation());\n            } else {\n                log(ioe.getMessage(), Project.MSG_INFO);\n            }\n        } finally {\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException ex) {\n                    //ignore\n                }\n            }\n        }\n    }\n\n\n    /**\n     *  Send the key/value pairs in the hashtable to the given output stream.\n     *  Only those properties matching the <tt>prefix</tt> constraint will be\n     *  sent to the output stream.\n     *  The output stream will be closed when this method returns.\n     *\n     *@param  allProps         propfile to save\n     *@param  os               output stream\n     *@exception  IOException  trouble\n     */\n    protected void saveProperties(Hashtable allProps, OutputStream os)\n             throws IOException, BuildException {\n        Properties props = new Properties();\n        Enumeration e = allProps.keys();\n        while (e.hasMoreElements()) {\n            String name = e.nextElement().toString();\n            String value = allProps.get(name).toString();\n            props.put(name, value);\n        }\n\n        if ("text".equals(format)) {\n            jdkSaveProperties(props, os, "Ant properties");\n        } else if ("xml".equals(format)) {\n            xmlSaveProperties(props, os);\n        }\n    }\n\n    protected void xmlSaveProperties(Properties props,\n                                     OutputStream os) throws IOException {\n        // create XML document\n        Document doc = getDocumentBuilder().newDocument();\n        Element rootElement = doc.createElement(PROPERTIES);\n\n        // output properties\n        String name;\n        Enumeration e = props.propertyNames();\n        while (e.hasMoreElements()) {\n            name = (String) e.nextElement();\n            Element propElement = doc.createElement(PROPERTY);\n            propElement.setAttribute(ATTR_NAME, name);\n            propElement.setAttribute(ATTR_VALUE, props.getProperty(name));\n            rootElement.appendChild(propElement);\n        }\n\n        Writer wri = null;\n        try {\n            wri = new OutputStreamWriter(os, "UTF8");\n            wri.write("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>");\n            (new DOMElementWriter()).write(rootElement, wri, 0, "\\t");\n            wri.flush();\n        } catch (IOException ioe) {\n            throw new BuildException("Unable to write XML file", ioe);\n        } finally {\n            if (wri != null) {\n                wri.close();\n            }\n        }\n    }\n\n    /**\n     *  JDK 1.2 allows for the safer method\n     *  <tt>Properties.store(OutputStream, String)</tt>, which throws an\n     *  <tt>IOException</tt> on an output error.\n     *\n     *@param props the properties to record\n     *@param os record the properties to this output stream\n     *@param header prepend this header to the property output\n     *@exception IOException on an I/O error during a write.\n     */\n    protected void jdkSaveProperties(Properties props, OutputStream os,\n                                     String header) throws IOException {\n       try {\n           props.store(os, header);\n\n       } catch (IOException ioe) {\n           throw new BuildException(ioe, getLocation());\n       } finally {\n           if (os != null) {\n               try {\n                   os.close();\n               } catch (IOException ioex) {\n                   log("Failed to close output stream");\n               }\n           }\n       }\n    }\n\n\n    /**\n     * Uses the DocumentBuilderFactory to get a DocumentBuilder instance.\n     *\n     * @return   The DocumentBuilder instance\n     */\n    private static DocumentBuilder getDocumentBuilder() {\n        try {\n            return DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        } catch (Exception e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n}	Long Method	God Class\n	Feature Envy\n	Shotgun Surgery\n	EchoProperties.java\n	19d9e603f8694c4764c33bce53be5b0c	\N	Quando métodos que centralizam a funcionalidade da classe	LOC (Lines of Code), NCO (Number Concerns per Operations), NCC (Number Concerns per Component)	Refatoração sugerida:  Replace Method with Method Object	t	3
50	Identifique o Bad Smell na classe abaixo	/*\n * Copyright  2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant.taskdefs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.Path;\nimport org.apache.tools.ant.util.FileUtils;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Loads property values from a valid XML file, generating the\n * property names from the file's element and attribute names.\n *\n * <p>Example:</p>\n * <pre>\n *   &lt;root-tag myattr="true"&gt;\n *     &lt;inner-tag someattr="val"&gt;Text&lt;/inner-tag&gt;\n *     &lt;a2&gt;&lt;a3&gt;&lt;a4&gt;false&lt;/a4&gt;&lt;/a3&gt;&lt;/a2&gt;\n *     &lt;x&gt;x1&lt;/x&gt;\n *     &lt;x&gt;x2&lt;/x&gt;\n *   &lt;/root-tag&gt;\n *</pre>\n *\n * <p>this generates the following properties:</p>\n *\n * <pre>\n *  root-tag(myattr)=true\n *  root-tag.inner-tag=Text\n *  root-tag.inner-tag(someattr)=val\n *  root-tag.a2.a3.a4=false\n *  root-tag.x=x1,x2\n * </pre>\n *\n * <p>The <i>collapseAttributes</i> property of this task can be set\n * to true (the default is false) which will instead result in the\n * following properties (note the difference in names of properties\n * corresponding to XML attributes):</p>\n *\n * <pre>\n *  root-tag.myattr=true\n *  root-tag.inner-tag=Text\n *  root-tag.inner-tag.someattr=val\n *  root-tag.a2.a3.a4=false\n *  root-tag.x=x1,x2\n * </pre>\n *\n * <p>Optionally, to more closely mirror the abilities of the Property\n * task, a selected set of attributes can be treated specially.  To\n * enable this behavior, the "semanticAttributes" property of this task\n * must be set to true (it defaults to false).  If this attribute is\n * specified, the following attributes take on special meaning\n * (setting this to true implicitly sets collapseAttributes to true as\n * well):</p>\n *\n * <ul>\n *  <li><b>value</b>: Identifies a text value for a property.</li>\n *  <li><b>location</b>: Identifies a file location for a property.</li>\n *  <li><b>id</b>: Sets an id for a property</li>\n *  <li><b>refid</b>: Sets a property to the value of another property\n *       based upon the provided id</li>\n *  <li><b>pathid</b>: Defines a path rather than a property with\n *       the given id.</li>\n * </ul>\n *\n * <p>For example, with keepRoot = false, the following properties file:</p>\n *\n * <pre>\n * &lt;root-tag&gt;\n *   &lt;build&gt;\n *   &lt;build folder="build"&gt;\n *     &lt;classes id="build.classes" location="${build.folder}/classes"/&gt;\n *     &lt;reference refid="build.classes"/&gt;\n *   &lt;/build&gt;\n *   &lt;compile&gt;\n *     &lt;classpath pathid="compile.classpath"&gt;\n *       &lt;pathelement location="${build.classes}"/&gt;\n *     &lt;/classpath&gt;\n *   &lt;/compile&gt;\n *   &lt;run-time&gt;\n *     &lt;jars&gt;*.jar&lt;/jars&gt;\n *     &lt;classpath pathid="run-time.classpath"&gt;\n *       &lt;path refid="compile.classpath"/&gt;\n *       &lt;pathelement path="${run-time.jars}"/&gt;\n *     &lt;/classpath&gt;\n *   &lt;/run-time&gt;\n * &lt;/root-tag&gt;\n * </pre>\n *\n * <p>is equivalent to the following entries in a build file:</p>\n *\n * <pre>\n * &lt;property name="build" location="build"/&gt;\n * &lt;property name="build.classes" location="${build.location}/classes"/&gt;\n * &lt;property name="build.reference" refid="build.classes"/&gt;\n *\n * &lt;property name="run-time.jars" value="*.jar/&gt;\n *\n * &lt;classpath id="compile.classpath"&gt;\n *   &lt;pathelement location="${build.classes}"/&gt;\n * &lt;/classpath&gt;\n *\n * &lt;classpath id="run-time.classpath"&gt;\n *   &lt;path refid="compile.classpath"/&gt;\n *   &lt;pathelement path="${run-time.jars}"/&gt;\n * &lt;/classpath&gt;\n * </pre>\n *\n * <p> This task <i>requires</i> the following attributes:</p>\n *\n * <ul>\n * <li><b>file</b>: The name of the file to load.</li>\n * </ul>\n *\n * <p>This task supports the following attributes:</p>\n *\n * <ul>\n * <li><b>prefix</b>: Optionally specify a prefix applied to\n *     all properties loaded.  Defaults to an empty string.</li>\n * <li><b>keepRoot</b>: Indicate whether the root xml element\n *     is kept as part of property name.  Defaults to true.</li>\n * <li><b>validate</b>: Indicate whether the xml file is validated.\n *     Defaults to false.</li>\n * <li><b>collapseAttributes</b>: Indicate whether attributes are\n *     stored in property names with parens or with period\n *     delimiters.  Defaults to false, meaning properties\n *     are stored with parens (i.e., foo(attr)).</li>\n * <li><b>semanticAttributes</b>: Indicate whether attributes\n *     named "location", "value", "refid" and "path"\n *     are interpreted as ant properties.  Defaults\n *     to false.</li>\n * <li><b>rootDirectory</b>: Indicate the directory to use\n *     as the root directory for resolving location\n *     properties.  Defaults to the directory\n *     of the project using the task.</li>\n * <li><b>includeSemanticAttribute</b>: Indicate whether to include\n *     the semantic attribute ("location" or "value") as\n *     part of the property name.  Defaults to false.</li>\n * </ul>\n *\n * @ant.task name="xmlproperty" category="xml"\n */\n\npublic class XmlProperty extends org.apache.tools.ant.Task {\n\n    private File src;\n    private String prefix = "";\n    private boolean keepRoot = true;\n    private boolean validate = false;\n    private boolean collapseAttributes = false;\n    private boolean semanticAttributes = false;\n    private boolean includeSemanticAttribute = false;\n    private File rootDirectory = null;\n    private FileUtils fileUtils = FileUtils.newFileUtils();\n    private Hashtable addedAttributes = new Hashtable();\n\n    private static final String ID = "id";\n    private static final String REF_ID = "refid";\n    private static final String LOCATION = "location";\n    private static final String VALUE = "value";\n    private static final String PATH = "path";\n    private static final String PATHID = "pathid";\n    private static final String[] ATTRIBUTES = new String[] {\n        ID, REF_ID, LOCATION, VALUE, PATH, PATHID\n    };\n\n    /**\n     * Constructor.\n     */\n    public XmlProperty() {\n        super();\n    }\n\n    /**\n     * Initializes the task.\n     */\n\n    public void init() {\n        super.init();\n    }\n\n    /**\n     * Run the task.\n     * @throws BuildException The exception raised during task execution.\n     * @todo validate the source file is valid before opening, print a better error message\n     * @todo add a verbose level log message listing the name of the file being loaded\n     */\n    public void execute()\n            throws BuildException {\n\n        if (getFile() == null) {\n            String msg = "XmlProperty task requires a file attribute";\n            throw new BuildException(msg);\n        }\n\n        try {\n            log("Loading " + src.getAbsolutePath(), Project.MSG_VERBOSE);\n\n            if (src.exists()) {\n\n              DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n              factory.setValidating(validate);\n              factory.setNamespaceAware(false);\n              Document document = factory.newDocumentBuilder().parse(src);\n              Element topElement = document.getDocumentElement();\n\n              // Keep a hashtable of attributes added by this task.\n              // This task is allow to override its own properties\n              // but not other properties.  So we need to keep track\n              // of which properties we've added.\n              addedAttributes = new Hashtable();\n\n              if (keepRoot) {\n                  addNodeRecursively(topElement, prefix, null);\n              } else {\n                  NodeList topChildren = topElement.getChildNodes();\n                  int numChildren = topChildren.getLength();\n                  for (int i = 0; i < numChildren; i++) {\n                    addNodeRecursively(topChildren.item(i), prefix, null);\n                  }\n              }\n\n            } else {\n                log("Unable to find property file: " + src.getAbsolutePath(),\n                    Project.MSG_VERBOSE);\n            }\n\n        } catch (SAXException sxe) {\n            // Error generated during parsing\n            Exception x = sxe;\n            if (sxe.getException() != null) {\n                x = sxe.getException();\n            }\n            throw new BuildException(x);\n\n        } catch (ParserConfigurationException pce) {\n            // Parser with specified options can't be built\n            throw new BuildException(pce);\n        } catch (IOException ioe) {\n            // I/O error\n            throw new BuildException(ioe);\n        }\n    }\n\n    /** Iterate through all nodes in the tree. */\n    private void addNodeRecursively(Node node, String prefix,\n                                    Object container) {\n\n        // Set the prefix for this node to include its tag name.\n        String nodePrefix = prefix;\n        if (node.getNodeType() != Node.TEXT_NODE) {\n            if (prefix.trim().length() > 0) {\n                nodePrefix += ".";\n            }\n            nodePrefix += node.getNodeName();\n        }\n\n        // Pass the container to the processing of this node,\n        Object nodeObject = processNode(node, nodePrefix, container);\n\n        // now, iterate through children.\n        if (node.hasChildNodes()) {\n\n            NodeList nodeChildren = node.getChildNodes();\n            int numChildren = nodeChildren.getLength();\n\n            for (int i = 0; i < numChildren; i++) {\n                // For each child, pass the object added by\n                // processNode to its children -- in other word, each\n                // object can pass information along to its children.\n                addNodeRecursively(nodeChildren.item(i), nodePrefix,\n                                   nodeObject);\n            }\n        }\n    }\n\n    void addNodeRecursively(org.w3c.dom.Node node, String prefix) {\n        addNodeRecursively(node, prefix, null);\n    }\n\n    /**\n     * Process the given node, adding any required attributes from\n     * this child node alone -- but <em>not</em> processing any\n     * children.\n     *\n     * @param node the XML Node to parse\n     * @param prefix A string to prepend to any properties that get\n     * added by this node.\n     * @param container Optionally, an object that a parent node\n     * generated that this node might belong to.  For example, this\n     * node could be within a node that generated a Path.\n     * @return the Object created by this node.  Generally, this is\n     * either a String if this node resulted in setting an attribute,\n     * or a Path.\n     */\n    public Object processNode (Node node, String prefix, Object container) {\n\n        // Parse the attribute(s) and text of this node, adding\n        // properties for each.\n        // if the "path" attribute is specified, then return the created path\n        // which will be passed to the children of this node.\n        Object addedPath = null;\n\n        // The value of an id attribute of this node.\n        String id = null;\n\n        if (node.hasAttributes()) {\n\n            NamedNodeMap nodeAttributes = node.getAttributes();\n\n            // Is there an id attribute?\n            Node idNode = nodeAttributes.getNamedItem(ID);\n            id = (semanticAttributes && idNode != null\n                  ? idNode.getNodeValue() : null);\n\n            // Now, iterate through the attributes adding them.\n            for (int i = 0; i < nodeAttributes.getLength(); i++) {\n\n                Node attributeNode = nodeAttributes.item(i);\n\n                if (!semanticAttributes) {\n                    String attributeName = getAttributeName(attributeNode);\n                    String attributeValue = getAttributeValue(attributeNode);\n                    addProperty(prefix + attributeName, attributeValue, null);\n                } else {\n\n                    String nodeName = attributeNode.getNodeName();\n                    String attributeValue = getAttributeValue(attributeNode);\n\n                    Path containingPath = (container != null\n                        && container instanceof Path ? (Path) container : null);\n\n                    /*\n                     * The main conditional logic -- if the attribute\n                     * is somehow "special" (i.e., it has known\n                     * semantic meaning) then deal with it\n                     * appropriately.\n                     */\n                    if (nodeName.equals(ID)) {\n                        // ID has already been found above.\n                        continue;\n                    } else if (containingPath != null\n                               && nodeName.equals(PATH)) {\n                        // A "path" attribute for a node within a Path object.\n                        containingPath.setPath(attributeValue);\n                    } else if (container instanceof Path\n                               && nodeName.equals(REF_ID)) {\n                        // A "refid" attribute for a node within a Path object.\n                        containingPath.setPath(attributeValue);\n                    } else if (container instanceof Path\n                               && nodeName.equals(LOCATION)) {\n                        // A "location" attribute for a node within a\n                        // Path object.\n                        containingPath.setLocation(resolveFile(attributeValue));\n                    } else if (nodeName.equals(PATHID)) {\n                        // A node identifying a new path\n                        if (container != null) {\n                            throw new BuildException("XmlProperty does not "\n                                                     + "support nested paths");\n                        }\n\n                        addedPath = new Path(getProject());\n                        getProject().addReference(attributeValue, addedPath);\n                    } else {\n                        // An arbitrary attribute.\n                        String attributeName = getAttributeName(attributeNode);\n                        addProperty(prefix + attributeName, attributeValue, id);\n                    }\n                }\n            }\n        }\n\n        String nodeText = null;\n        if (node.getNodeType() == Node.TEXT_NODE) {\n            // For the text node, add a property.\n            nodeText = getAttributeValue(node);\n        } else if ((node.getNodeType() == Node.ELEMENT_NODE)\n            && (node.getChildNodes().getLength() == 1)\n            && (node.getFirstChild().getNodeType() == Node.CDATA_SECTION_NODE)) {\n\n            nodeText = node.getFirstChild().getNodeValue();\n        }\n\n        if (nodeText != null) {\n            // If the containing object was a String, then use it as the ID.\n            if (semanticAttributes && id == null\n                && container instanceof String) {\n                id = (String) container;\n                System.out.println("Setting id = " + id);\n            }\n\n            if (nodeText.trim().length() != 0) {\n                addProperty(prefix, nodeText, id);\n            }\n        }\n\n        // Return the Path we added or the ID of this node for\n        // children to reference if needed.  Path objects are\n        // definitely used by child path elements, and ID may be used\n        // for a child text node.\n        return (addedPath != null ? addedPath : id);\n    }\n\n    /**\n     * Actually add the given property/value to the project\n     * after writing a log message.\n     */\n    private void addProperty (String name, String value, String id) {\n        String msg = name + ":" + value;\n        if (id != null) {\n            msg += ("(id=" + id + ")");\n        }\n        log(msg, Project.MSG_DEBUG);\n\n        if (addedAttributes.containsKey(name)) {\n            // If this attribute was added by this task, then\n            // we append this value to the existing value.\n            // We use the setProperty method which will\n            // forcibly override the property if it already exists.\n            // We need to put these properties into the project\n            // when we read them, though (instead of keeping them\n            // outside of the project and batch adding them at the end)\n            // to allow other properties to reference them.\n            value = (String) addedAttributes.get(name) + "," + value;\n            getProject().setProperty(name, value);\n        } else {\n            getProject().setNewProperty(name, value);\n        }\n        addedAttributes.put(name, value);\n        if (id != null) {\n            getProject().addReference(id, value);\n        }\n    }\n\n    /**\n     * Return a reasonable attribute name for the given node.\n     * If we are using semantic attributes or collapsing\n     * attributes, the returned name is ".nodename".\n     * Otherwise, we return "(nodename)".  This is long-standing\n     * (and default) &lt;xmlproperty&gt; behavior.\n     */\n    private String getAttributeName (Node attributeNode) {\n        String attributeName = attributeNode.getNodeName();\n\n        if (semanticAttributes) {\n            // Never include the "refid" attribute as part of the\n            // attribute name.\n            if (attributeName.equals(REF_ID)) {\n                return "";\n            // Otherwise, return it appended unless property to hide it is set.\n            } else if (!isSemanticAttribute(attributeName)\n                       || includeSemanticAttribute) {\n                return "." + attributeName;\n            } else {\n                return "";\n            }\n        } else if (collapseAttributes) {\n            return "." + attributeName;\n        } else {\n            return "(" + attributeName + ")";\n        }\n    }\n\n    /**\n     * Return whether the provided attribute name is recognized or not.\n     */\n    private static boolean isSemanticAttribute (String attributeName) {\n        for (int i = 0; i < ATTRIBUTES.length; i++) {\n            if (attributeName.equals(ATTRIBUTES[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the value for the given attribute.\n     * If we are not using semantic attributes, its just the\n     * literal string value of the attribute.\n     *\n     * <p>If we <em>are</em> using semantic attributes, then first\n     * dependent properties are resolved (i.e., ${foo} is resolved\n     * based on the foo property value), and then an appropriate data\n     * type is used.  In particular, location-based properties are\n     * resolved to absolute file names.  Also for refid values, look\n     * up the referenced object from the project.</p>\n     */\n    private String getAttributeValue (Node attributeNode) {\n        String nodeValue = attributeNode.getNodeValue().trim();\n        if (semanticAttributes) {\n            String attributeName = attributeNode.getNodeName();\n            nodeValue = getProject().replaceProperties(nodeValue);\n            if (attributeName.equals(LOCATION)) {\n                File f = resolveFile(nodeValue);\n                return f.getPath();\n            } else if (attributeName.equals(REF_ID)) {\n                Object ref = getProject().getReference(nodeValue);\n                if (ref != null) {\n                    return ref.toString();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * The XML file to parse; required.\n     * @param src the file to parse\n     */\n    public void setFile(File src) {\n        this.src = src;\n    }\n\n    /**\n     * the prefix to prepend to each property\n     * @param prefix the prefix to prepend to each property\n     */\n    public void setPrefix(String prefix) {\n        this.prefix = prefix.trim();\n    }\n\n    /**\n     * flag to include the xml root tag as a\n     * first value in the property name; optional,\n     * default is true\n     * @param keepRoot if true (default), include the xml root tag\n     */\n    public void setKeeproot(boolean keepRoot) {\n        this.keepRoot = keepRoot;\n    }\n\n    /**\n     * flag to validate the XML file; optional, default false\n     * @param validate if true validate the XML file, default false\n     */\n    public void setValidate(boolean validate) {\n        this.validate = validate;\n    }\n\n    /**\n     * flag to treat attributes as nested elements;\n     * optional, default false\n     * @param collapseAttributes if true treat attributes as nested elements\n     */\n    public void setCollapseAttributes(boolean collapseAttributes) {\n        this.collapseAttributes = collapseAttributes;\n    }\n\n    public void setSemanticAttributes (boolean semanticAttributes) {\n        this.semanticAttributes = semanticAttributes;\n    }\n\n    public void setRootDirectory (File rootDirectory) {\n        this.rootDirectory = rootDirectory;\n    }\n\n    public void setIncludeSemanticAttribute (boolean includeSemanticAttribute) {\n        this.includeSemanticAttribute = includeSemanticAttribute;\n    }\n\n    /* Expose members for extensibility */\n\n    protected File getFile () {\n        return this.src;\n    }\n\n    protected String getPrefix () {\n        return this.prefix;\n    }\n\n    protected boolean getKeeproot () {\n        return this.keepRoot;\n    }\n\n    protected boolean getValidate () {\n        return this.validate;\n    }\n\n    protected boolean getCollapseAttributes () {\n        return this.collapseAttributes;\n    }\n\n    protected boolean getSemanticAttributes () {\n        return this.semanticAttributes;\n    }\n\n    protected File getRootDirectory () {\n        return this.rootDirectory;\n    }\n\n    protected boolean getIncludeSementicAttribute () {\n        return this.includeSemanticAttribute;\n    }\n\n    /**\n     * Let project resolve the file - or do it ourselves if\n     * rootDirectory has been set.\n     */\n    private File resolveFile(String fileName) {\n        if (rootDirectory == null) {\n            return getProject().resolveFile(fileName);\n        }\n        return fileUtils.resolveFile(rootDirectory, fileName);\n    }\n\n}	Long Method	God Class\n	Feature Envy\n	Shotgun Surgery\n	XmlProperty.java	19d9e603f8694c4764c33bce53be5b0c	\N	Quando métodos que centralizam a funcionalidade da classe	LOC (Lines of Code), NCO (Number Concerns per Operations), NCC (Number Concerns per Component)	Refatoração sugerida:  Replace Method with Method Object	t	3
52	Identifique o Bad Smell na classe abaixo	/*\r\n * Copyright (C) 2007 The Android Open Source Project\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the "License");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an "AS IS" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage com.android.server.wm;\r\n\r\nimport static android.view.WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW;\r\nimport static android.view.WindowManager.LayoutParams.FIRST_SUB_WINDOW;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_BLUR_BEHIND;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_DIM_BEHIND;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;\r\nimport static android.view.WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;\r\nimport static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;\r\nimport static android.view.WindowManager.LayoutParams.LAST_SUB_WINDOW;\r\nimport static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;\r\nimport static android.view.WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\r\nimport static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;\r\nimport static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG;\r\nimport static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;\r\n\r\nimport com.android.internal.app.IBatteryStats;\r\nimport com.android.internal.policy.PolicyManager;\r\nimport com.android.internal.policy.impl.PhoneWindowManager;\r\nimport com.android.internal.view.BaseInputHandler;\r\nimport com.android.internal.view.IInputContext;\r\nimport com.android.internal.view.IInputMethodClient;\r\nimport com.android.internal.view.IInputMethodManager;\r\nimport com.android.internal.view.WindowManagerPolicyThread;\r\nimport com.android.server.AttributeCache;\r\nimport com.android.server.EventLogTags;\r\nimport com.android.server.PowerManagerService;\r\nimport com.android.server.Watchdog;\r\nimport com.android.server.am.BatteryStatsService;\r\n\r\nimport android.Manifest;\r\nimport android.app.ActivityManagerNative;\r\nimport android.app.IActivityManager;\r\nimport android.app.StatusBarManager;\r\nimport android.app.admin.DevicePolicyManager;\r\nimport android.content.BroadcastReceiver;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.IntentFilter;\r\nimport android.content.pm.ActivityInfo;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.CompatibilityInfo;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.PixelFormat;\r\nimport android.graphics.Point;\r\nimport android.graphics.Rect;\r\nimport android.graphics.Region;\r\nimport android.os.BatteryStats;\r\nimport android.os.Binder;\r\nimport android.os.Bundle;\r\nimport android.os.Debug;\r\nimport android.os.Handler;\r\nimport android.os.IBinder;\r\nimport android.os.LocalPowerManager;\r\nimport android.os.Looper;\r\nimport android.os.Message;\r\nimport android.os.Parcel;\r\nimport android.os.ParcelFileDescriptor;\r\nimport android.os.Power;\r\nimport android.os.PowerManager;\r\nimport android.os.Process;\r\nimport android.os.RemoteException;\r\nimport android.os.ServiceManager;\r\nimport android.os.StrictMode;\r\nimport android.os.SystemClock;\r\nimport android.os.SystemProperties;\r\nimport android.os.TokenWatcher;\r\nimport android.provider.Settings;\r\nimport android.util.DisplayMetrics;\r\nimport android.util.EventLog;\r\nimport android.util.Log;\r\nimport android.util.Slog;\r\nimport android.util.SparseIntArray;\r\nimport android.util.TypedValue;\r\nimport android.view.Display;\r\nimport android.view.Gravity;\r\nimport android.view.IApplicationToken;\r\nimport android.view.IOnKeyguardExitResult;\r\nimport android.view.IRotationWatcher;\r\nimport android.view.IWindow;\r\nimport android.view.IWindowManager;\r\nimport android.view.IWindowSession;\r\nimport android.view.InputChannel;\r\nimport android.view.InputDevice;\r\nimport android.view.InputEvent;\r\nimport android.view.InputHandler;\r\nimport android.view.InputQueue;\r\nimport android.view.KeyEvent;\r\nimport android.view.MotionEvent;\r\nimport android.view.Surface;\r\nimport android.view.SurfaceSession;\r\nimport android.view.View;\r\nimport android.view.WindowManager;\r\nimport android.view.WindowManagerImpl;\r\nimport android.view.WindowManagerPolicy;\r\nimport android.view.WindowManager.LayoutParams;\r\nimport android.view.animation.Animation;\r\nimport android.view.animation.AnimationUtils;\r\nimport android.view.animation.Transformation;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.DataInputStream;\r\nimport java.io.File;\r\nimport java.io.FileDescriptor;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.PrintWriter;\r\nimport java.io.StringWriter;\r\nimport java.net.Socket;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/** {@hide} */\r\npublic class WindowManagerService extends IWindowManager.Stub\r\n        implements Watchdog.Monitor {\r\n    static final String TAG = "WindowManager";\r\n    static final boolean DEBUG = false;\r\n    static final boolean DEBUG_ADD_REMOVE = false;\r\n    static final boolean DEBUG_FOCUS = false;\r\n    static final boolean DEBUG_ANIM = false;\r\n    static final boolean DEBUG_LAYOUT = false;\r\n    static final boolean DEBUG_RESIZE = false;\r\n    static final boolean DEBUG_LAYERS = false;\r\n    static final boolean DEBUG_INPUT = false;\r\n    static final boolean DEBUG_INPUT_METHOD = false;\r\n    static final boolean DEBUG_VISIBILITY = false;\r\n    static final boolean DEBUG_WINDOW_MOVEMENT = false;\r\n    static final boolean DEBUG_TOKEN_MOVEMENT = false;\r\n    static final boolean DEBUG_ORIENTATION = false;\r\n    static final boolean DEBUG_APP_ORIENTATION = false;\r\n    static final boolean DEBUG_CONFIGURATION = false;\r\n    static final boolean DEBUG_APP_TRANSITIONS = false;\r\n    static final boolean DEBUG_STARTING_WINDOW = false;\r\n    static final boolean DEBUG_REORDER = false;\r\n    static final boolean DEBUG_WALLPAPER = false;\r\n    static final boolean DEBUG_DRAG = false;\r\n    static final boolean DEBUG_SCREEN_ON = false;\r\n    static final boolean DEBUG_SCREENSHOT = false;\r\n    static final boolean SHOW_SURFACE_ALLOC = false;\r\n    static final boolean SHOW_TRANSACTIONS = false;\r\n    static final boolean HIDE_STACK_CRAWLS = true;\r\n\r\n    static final boolean PROFILE_ORIENTATION = false;\r\n    static final boolean BLUR = true;\r\n    static final boolean localLOGV = DEBUG;\r\n\r\n    /** How much to multiply the policy's type layer, to reserve room\r\n     * for multiple windows of the same type and Z-ordering adjustment\r\n     * with TYPE_LAYER_OFFSET. */\r\n    static final int TYPE_LAYER_MULTIPLIER = 10000;\r\n\r\n    /** Offset from TYPE_LAYER_MULTIPLIER for moving a group of windows above\r\n     * or below others in the same layer. */\r\n    static final int TYPE_LAYER_OFFSET = 1000;\r\n\r\n    /** How much to increment the layer for each window, to reserve room\r\n     * for effect surfaces between them.\r\n     */\r\n    static final int WINDOW_LAYER_MULTIPLIER = 5;\r\n\r\n    /**\r\n     * Dim surface layer is immediately below target window.\r\n     */\r\n    static final int LAYER_OFFSET_DIM = 1;\r\n\r\n    /**\r\n     * Blur surface layer is immediately below dim layer.\r\n     */\r\n    static final int LAYER_OFFSET_BLUR = 2;\r\n\r\n    /**\r\n     * Layer at which to put the rotation freeze snapshot.\r\n     */\r\n    static final int FREEZE_LAYER = (TYPE_LAYER_MULTIPLIER * 200) + 1;\r\n\r\n    /**\r\n     * Layer at which to put the mask for emulated screen sizes.\r\n     */\r\n    static final int MASK_LAYER = TYPE_LAYER_MULTIPLIER * 200;\r\n\r\n    /** The maximum length we will accept for a loaded animation duration:\r\n     * this is 10 seconds.\r\n     */\r\n    static final int MAX_ANIMATION_DURATION = 10*1000;\r\n\r\n    /** Amount of time (in milliseconds) to animate the dim surface from one\r\n     * value to another, when no window animation is driving it.\r\n     */\r\n    static final int DEFAULT_DIM_DURATION = 200;\r\n\r\n    /** Amount of time (in milliseconds) to animate the fade-in-out transition for\r\n     * compatible windows.\r\n     */\r\n    static final int DEFAULT_FADE_IN_OUT_DURATION = 400;\r\n\r\n    /**\r\n     * If true, the window manager will do its own custom freezing and general\r\n     * management of the screen during rotation.\r\n     */\r\n    static final boolean CUSTOM_SCREEN_ROTATION = true;\r\n\r\n    // Maximum number of milliseconds to wait for input event injection.\r\n    // FIXME is this value reasonable?\r\n    private static final int INJECTION_TIMEOUT_MILLIS = 30 * 1000;\r\n\r\n    // Maximum number of milliseconds to wait for input devices to be enumerated before\r\n    // proceding with safe mode detection.\r\n    private static final int INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS = 1000;\r\n\r\n    // Default input dispatching timeout in nanoseconds.\r\n    static final long DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS = 5000 * 1000000L;\r\n\r\n    static final int UPDATE_FOCUS_NORMAL = 0;\r\n    static final int UPDATE_FOCUS_WILL_ASSIGN_LAYERS = 1;\r\n    static final int UPDATE_FOCUS_PLACING_SURFACES = 2;\r\n    static final int UPDATE_FOCUS_WILL_PLACE_SURFACES = 3;\r\n\r\n    private static final String SYSTEM_SECURE = "ro.secure";\r\n    private static final String SYSTEM_DEBUGGABLE = "ro.debuggable";\r\n    private static final String SYSTEM_HEADLESS = "ro.config.headless";\r\n\r\n    /**\r\n     * Condition waited on by {@link #reenableKeyguard} to know the call to\r\n     * the window policy has finished.\r\n     * This is set to true only if mKeyguardTokenWatcher.acquired() has\r\n     * actually disabled the keyguard.\r\n     */\r\n    private boolean mKeyguardDisabled = false;\r\n\r\n    private final boolean mHeadless;\r\n\r\n    private static final int ALLOW_DISABLE_YES = 1;\r\n    private static final int ALLOW_DISABLE_NO = 0;\r\n    private static final int ALLOW_DISABLE_UNKNOWN = -1; // check with DevicePolicyManager\r\n    private int mAllowDisableKeyguard = ALLOW_DISABLE_UNKNOWN; // sync'd by mKeyguardTokenWatcher\r\n\r\n    final TokenWatcher mKeyguardTokenWatcher = new TokenWatcher(\r\n            new Handler(), "WindowManagerService.mKeyguardTokenWatcher") {\r\n        public void acquired() {\r\n            if (shouldAllowDisableKeyguard()) {\r\n                mPolicy.enableKeyguard(false);\r\n                mKeyguardDisabled = true;\r\n            } else {\r\n                Log.v(TAG, "Not disabling keyguard since device policy is enforced");\r\n            }\r\n        }\r\n        public void released() {\r\n            mPolicy.enableKeyguard(true);\r\n            synchronized (mKeyguardTokenWatcher) {\r\n                mKeyguardDisabled = false;\r\n                mKeyguardTokenWatcher.notifyAll();\r\n            }\r\n        }\r\n    };\r\n\r\n    final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\r\n        @Override\r\n        public void onReceive(Context context, Intent intent) {\r\n            mPolicy.enableKeyguard(true);\r\n            synchronized(mKeyguardTokenWatcher) {\r\n                // lazily evaluate this next time we're asked to disable keyguard\r\n                mAllowDisableKeyguard = ALLOW_DISABLE_UNKNOWN;\r\n                mKeyguardDisabled = false;\r\n            }\r\n        }\r\n    };\r\n\r\n    final Context mContext;\r\n\r\n    final boolean mHaveInputMethods;\r\n\r\n    final boolean mLimitedAlphaCompositing;\r\n\r\n    final WindowManagerPolicy mPolicy = PolicyManager.makeNewWindowManager();\r\n\r\n    final IActivityManager mActivityManager;\r\n\r\n    final IBatteryStats mBatteryStats;\r\n\r\n    /**\r\n     * All currently active sessions with clients.\r\n     */\r\n    final HashSet<Session> mSessions = new HashSet<Session>();\r\n\r\n    /**\r\n     * Mapping from an IWindow IBinder to the server's Window object.\r\n     * This is also used as the lock for all of our state.\r\n     */\r\n    final HashMap<IBinder, WindowState> mWindowMap = new HashMap<IBinder, WindowState>();\r\n\r\n    /**\r\n     * Mapping from a token IBinder to a WindowToken object.\r\n     */\r\n    final HashMap<IBinder, WindowToken> mTokenMap =\r\n            new HashMap<IBinder, WindowToken>();\r\n\r\n    /**\r\n     * Window tokens that are in the process of exiting, but still\r\n     * on screen for animations.\r\n     */\r\n    final ArrayList<WindowToken> mExitingTokens = new ArrayList<WindowToken>();\r\n\r\n    /**\r\n     * Z-ordered (bottom-most first) list of all application tokens, for\r\n     * controlling the ordering of windows in different applications.  This\r\n     * contains AppWindowToken objects.\r\n     */\r\n    final ArrayList<AppWindowToken> mAppTokens = new ArrayList<AppWindowToken>();\r\n\r\n    /**\r\n     * Application tokens that are in the process of exiting, but still\r\n     * on screen for animations.\r\n     */\r\n    final ArrayList<AppWindowToken> mExitingAppTokens = new ArrayList<AppWindowToken>();\r\n\r\n    /**\r\n     * List of window tokens that have finished starting their application,\r\n     * and now need to have the policy remove their windows.\r\n     */\r\n    final ArrayList<AppWindowToken> mFinishedStarting = new ArrayList<AppWindowToken>();\r\n\r\n    /**\r\n     * Z-ordered (bottom-most first) list of all Window objects.\r\n     */\r\n    final ArrayList<WindowState> mWindows = new ArrayList<WindowState>();\r\n\r\n    /**\r\n     * Windows that are being resized.  Used so we can tell the client about\r\n     * the resize after closing the transaction in which we resized the\r\n     * underlying surface.\r\n     */\r\n    final ArrayList<WindowState> mResizingWindows = new ArrayList<WindowState>();\r\n\r\n    /**\r\n     * Windows whose animations have ended and now must be removed.\r\n     */\r\n    final ArrayList<WindowState> mPendingRemove = new ArrayList<WindowState>();\r\n\r\n    /**\r\n     * Used when processing mPendingRemove to avoid working on the original array.\r\n     */\r\n    WindowState[] mPendingRemoveTmp = new WindowState[20];\r\n\r\n    /**\r\n     * Windows whose surface should be destroyed.\r\n     */\r\n    final ArrayList<WindowState> mDestroySurface = new ArrayList<WindowState>();\r\n\r\n    /**\r\n     * Windows that have lost input focus and are waiting for the new\r\n     * focus window to be displayed before they are told about this.\r\n     */\r\n    ArrayList<WindowState> mLosingFocus = new ArrayList<WindowState>();\r\n\r\n    /**\r\n     * This is set when we have run out of memory, and will either be an empty\r\n     * list or contain windows that need to be force removed.\r\n     */\r\n    ArrayList<WindowState> mForceRemoves;\r\n\r\n    /**\r\n     * Used when rebuilding window list to keep track of windows that have\r\n     * been removed.\r\n     */\r\n    WindowState[] mRebuildTmp = new WindowState[20];\r\n\r\n    IInputMethodManager mInputMethodManager;\r\n\r\n    SurfaceSession mFxSession;\r\n    private DimAnimator mDimAnimator = null;\r\n    Surface mBlurSurface;\r\n    boolean mBlurShown;\r\n    Watermark mWatermark;\r\n    StrictModeFlash mStrictModeFlash;\r\n    ScreenRotationAnimation mScreenRotationAnimation;\r\n\r\n    BlackFrame mBlackFrame;\r\n\r\n    int mTransactionSequence = 0;\r\n\r\n    final float[] mTmpFloats = new float[9];\r\n\r\n    boolean mSafeMode;\r\n    boolean mDisplayEnabled = false;\r\n    boolean mSystemBooted = false;\r\n    boolean mForceDisplayEnabled = false;\r\n    boolean mShowingBootMessages = false;\r\n    int mInitialDisplayWidth = 0;\r\n    int mInitialDisplayHeight = 0;\r\n    int mBaseDisplayWidth = 0;\r\n    int mBaseDisplayHeight = 0;\r\n    int mCurDisplayWidth = 0;\r\n    int mCurDisplayHeight = 0;\r\n    int mAppDisplayWidth = 0;\r\n    int mAppDisplayHeight = 0;\r\n    int mRotation = 0;\r\n    int mRequestedRotation = 0;\r\n    int mForcedAppOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\r\n    boolean mAltOrientation = false;\r\n    int mLastRotationFlags;\r\n    ArrayList<IRotationWatcher> mRotationWatchers\r\n            = new ArrayList<IRotationWatcher>();\r\n    int mDeferredRotation;\r\n    int mDeferredRotationAnimFlags;\r\n\r\n    boolean mLayoutNeeded = true;\r\n    boolean mAnimationPending = false;\r\n    boolean mDisplayFrozen = false;\r\n    boolean mWaitingForConfig = false;\r\n    boolean mWindowsFreezingScreen = false;\r\n    int mAppsFreezingScreen = 0;\r\n    int mLastWindowForcedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\r\n\r\n    int mLayoutSeq = 0;\r\n    \r\n    // State while inside of layoutAndPlaceSurfacesLocked().\r\n    boolean mFocusMayChange;\r\n    \r\n    Configuration mCurConfiguration = new Configuration();\r\n    \r\n    // This is held as long as we have the screen frozen, to give us time to\r\n    // perform a rotation animation when turning off shows the lock screen which\r\n    // changes the orientation.\r\n    PowerManager.WakeLock mScreenFrozenLock;\r\n\r\n    // State management of app transitions.  When we are preparing for a\r\n    // transition, mNextAppTransition will be the kind of transition to\r\n    // perform or TRANSIT_NONE if we are not waiting.  If we are waiting,\r\n    // mOpeningApps and mClosingApps are the lists of tokens that will be\r\n    // made visible or hidden at the next transition.\r\n    int mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;\r\n    String mNextAppTransitionPackage;\r\n    int mNextAppTransitionEnter;\r\n    int mNextAppTransitionExit;\r\n    boolean mAppTransitionReady = false;\r\n    boolean mAppTransitionRunning = false;\r\n    boolean mAppTransitionTimeout = false;\r\n    boolean mStartingIconInTransition = false;\r\n    boolean mSkipAppTransitionAnimation = false;\r\n    final ArrayList<AppWindowToken> mOpeningApps = new ArrayList<AppWindowToken>();\r\n    final ArrayList<AppWindowToken> mClosingApps = new ArrayList<AppWindowToken>();\r\n    final ArrayList<AppWindowToken> mToTopApps = new ArrayList<AppWindowToken>();\r\n    final ArrayList<AppWindowToken> mToBottomApps = new ArrayList<AppWindowToken>();\r\n\r\n    Display mDisplay;\r\n\r\n    final DisplayMetrics mDisplayMetrics = new DisplayMetrics();\r\n    final DisplayMetrics mRealDisplayMetrics = new DisplayMetrics();\r\n    final DisplayMetrics mTmpDisplayMetrics = new DisplayMetrics();\r\n    final DisplayMetrics mCompatDisplayMetrics = new DisplayMetrics();\r\n\r\n    H mH = new H();\r\n\r\n    WindowState mCurrentFocus = null;\r\n    WindowState mLastFocus = null;\r\n\r\n    // This just indicates the window the input method is on top of, not\r\n    // necessarily the window its input is going to.\r\n    WindowState mInputMethodTarget = null;\r\n    boolean mInputMethodTargetWaitingAnim;\r\n    int mInputMethodAnimLayerAdjustment;\r\n\r\n    WindowState mInputMethodWindow = null;\r\n    final ArrayList<WindowState> mInputMethodDialogs = new ArrayList<WindowState>();\r\n\r\n    boolean mHardKeyboardAvailable;\r\n    boolean mHardKeyboardEnabled;\r\n    OnHardKeyboardStatusChangeListener mHardKeyboardStatusChangeListener;\r\n\r\n    final ArrayList<WindowToken> mWallpaperTokens = new ArrayList<WindowToken>();\r\n\r\n    // If non-null, this is the currently visible window that is associated\r\n    // with the wallpaper.\r\n    WindowState mWallpaperTarget = null;\r\n    // If non-null, we are in the middle of animating from one wallpaper target\r\n    // to another, and this is the lower one in Z-order.\r\n    WindowState mLowerWallpaperTarget = null;\r\n    // If non-null, we are in the middle of animating from one wallpaper target\r\n    // to another, and this is the higher one in Z-order.\r\n    WindowState mUpperWallpaperTarget = null;\r\n    // Window currently running an animation that has requested it be detached\r\n    // from the wallpaper.  This means we need to ensure the wallpaper is\r\n    // visible behind it in case it animates in a way that would allow it to be\r\n    // seen.\r\n    WindowState mWindowDetachedWallpaper = null;\r\n    DimSurface mWindowAnimationBackgroundSurface = null;\r\n    int mWallpaperAnimLayerAdjustment;\r\n    float mLastWallpaperX = -1;\r\n    float mLastWallpaperY = -1;\r\n    float mLastWallpaperXStep = -1;\r\n    float mLastWallpaperYStep = -1;\r\n    // This is set when we are waiting for a wallpaper to tell us it is done\r\n    // changing its scroll position.\r\n    WindowState mWaitingOnWallpaper;\r\n    // The last time we had a timeout when waiting for a wallpaper.\r\n    long mLastWallpaperTimeoutTime;\r\n    // We give a wallpaper up to 150ms to finish scrolling.\r\n    static final long WALLPAPER_TIMEOUT = 150;\r\n    // Time we wait after a timeout before trying to wait again.\r\n    static final long WALLPAPER_TIMEOUT_RECOVERY = 10000;\r\n\r\n    AppWindowToken mFocusedApp = null;\r\n\r\n    PowerManagerService mPowerManager;\r\n\r\n    float mWindowAnimationScale = 1.0f;\r\n    float mTransitionAnimationScale = 1.0f;\r\n\r\n    final InputManager mInputManager;\r\n\r\n    // Who is holding the screen on.\r\n    Session mHoldingScreenOn;\r\n    PowerManager.WakeLock mHoldingScreenWakeLock;\r\n\r\n    boolean mTurnOnScreen;\r\n\r\n    DragState mDragState = null;\r\n    final InputHandler mDragInputHandler = new BaseInputHandler() {\r\n        @Override\r\n        public void handleMotion(MotionEvent event, InputQueue.FinishedCallback finishedCallback) {\r\n            boolean handled = false;\r\n            try {\r\n                if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0\r\n                        && mDragState != null) {\r\n                    boolean endDrag = false;\r\n                    final float newX = event.getRawX();\r\n                    final float newY = event.getRawY();\r\n\r\n                    switch (event.getAction()) {\r\n                    case MotionEvent.ACTION_DOWN: {\r\n                        if (DEBUG_DRAG) {\r\n                            Slog.w(TAG, "Unexpected ACTION_DOWN in drag layer");\r\n                        }\r\n                    } break;\r\n\r\n                    case MotionEvent.ACTION_MOVE: {\r\n                        synchronized (mWindowMap) {\r\n                            // move the surface and tell the involved window(s) where we are\r\n                            mDragState.notifyMoveLw(newX, newY);\r\n                        }\r\n                    } break;\r\n\r\n                    case MotionEvent.ACTION_UP: {\r\n                        if (DEBUG_DRAG) Slog.d(TAG, "Got UP on move channel; dropping at "\r\n                                + newX + "," + newY);\r\n                        synchronized (mWindowMap) {\r\n                            endDrag = mDragState.notifyDropLw(newX, newY);\r\n                        }\r\n                    } break;\r\n\r\n                    case MotionEvent.ACTION_CANCEL: {\r\n                        if (DEBUG_DRAG) Slog.d(TAG, "Drag cancelled!");\r\n                        endDrag = true;\r\n                    } break;\r\n                    }\r\n\r\n                    if (endDrag) {\r\n                        if (DEBUG_DRAG) Slog.d(TAG, "Drag ended; tearing down state");\r\n                        // tell all the windows that the drag has ended\r\n                        synchronized (mWindowMap) {\r\n                            mDragState.endDragLw();\r\n                        }\r\n                    }\r\n\r\n                    handled = true;\r\n                }\r\n            } catch (Exception e) {\r\n                Slog.e(TAG, "Exception caught by drag handleMotion", e);\r\n            } finally {\r\n                finishedCallback.finished(handled);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Whether the UI is currently running in touch mode (not showing\r\n     * navigational focus because the user is directly pressing the screen).\r\n     */\r\n    boolean mInTouchMode = true;\r\n\r\n    private ViewServer mViewServer;\r\n    private ArrayList<WindowChangeListener> mWindowChangeListeners =\r\n        new ArrayList<WindowChangeListener>();\r\n    private boolean mWindowsChanged = false;\r\n\r\n    public interface WindowChangeListener {\r\n        public void windowsChanged();\r\n        public void focusChanged();\r\n    }\r\n\r\n    final Configuration mTempConfiguration = new Configuration();\r\n\r\n    // The desired scaling factor for compatible apps.\r\n    float mCompatibleScreenScale;\r\n\r\n    public static WindowManagerService main(Context context,\r\n            PowerManagerService pm, boolean haveInputMethods) {\r\n        WMThread thr = new WMThread(context, pm, haveInputMethods);\r\n        thr.start();\r\n\r\n        synchronized (thr) {\r\n            while (thr.mService == null) {\r\n                try {\r\n                    thr.wait();\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }\r\n            return thr.mService;\r\n        }\r\n    }\r\n\r\n    static class WMThread extends Thread {\r\n        WindowManagerService mService;\r\n\r\n        private final Context mContext;\r\n        private final PowerManagerService mPM;\r\n        private final boolean mHaveInputMethods;\r\n\r\n        public WMThread(Context context, PowerManagerService pm,\r\n                boolean haveInputMethods) {\r\n            super("WindowManager");\r\n            mContext = context;\r\n            mPM = pm;\r\n            mHaveInputMethods = haveInputMethods;\r\n        }\r\n\r\n        public void run() {\r\n            Looper.prepare();\r\n            WindowManagerService s = new WindowManagerService(mContext, mPM,\r\n                    mHaveInputMethods);\r\n            android.os.Process.setThreadPriority(\r\n                    android.os.Process.THREAD_PRIORITY_DISPLAY);\r\n            android.os.Process.setCanSelfBackground(false);\r\n\r\n            synchronized (this) {\r\n                mService = s;\r\n                notifyAll();\r\n            }\r\n\r\n            // For debug builds, log event loop stalls to dropbox for analysis.\r\n            if (StrictMode.conditionallyEnableDebugLogging()) {\r\n                Slog.i(TAG, "Enabled StrictMode logging for WMThread's Looper");\r\n            }\r\n\r\n            Looper.loop();\r\n        }\r\n    }\r\n\r\n    static class PolicyThread extends Thread {\r\n        private final WindowManagerPolicy mPolicy;\r\n        private final WindowManagerService mService;\r\n        private final Context mContext;\r\n        private final PowerManagerService mPM;\r\n        boolean mRunning = false;\r\n\r\n        public PolicyThread(WindowManagerPolicy policy,\r\n                WindowManagerService service, Context context,\r\n                PowerManagerService pm) {\r\n            super("WindowManagerPolicy");\r\n            mPolicy = policy;\r\n            mService = service;\r\n            mContext = context;\r\n            mPM = pm;\r\n        }\r\n\r\n        public void run() {\r\n            Looper.prepare();\r\n            WindowManagerPolicyThread.set(this, Looper.myLooper());\r\n            \r\n            //Looper.myLooper().setMessageLogging(new LogPrinter(\r\n            //        Log.VERBOSE, "WindowManagerPolicy", Log.LOG_ID_SYSTEM));\r\n            android.os.Process.setThreadPriority(\r\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND);\r\n            android.os.Process.setCanSelfBackground(false);\r\n            mPolicy.init(mContext, mService, mPM);\r\n\r\n            synchronized (this) {\r\n                mRunning = true;\r\n                notifyAll();\r\n            }\r\n\r\n            // For debug builds, log event loop stalls to dropbox for analysis.\r\n            if (StrictMode.conditionallyEnableDebugLogging()) {\r\n                Slog.i(TAG, "Enabled StrictMode for PolicyThread's Looper");\r\n            }\r\n\r\n            Looper.loop();\r\n        }\r\n    }\r\n\r\n    private WindowManagerService(Context context, PowerManagerService pm,\r\n            boolean haveInputMethods) {\r\n        mContext = context;\r\n        mHaveInputMethods = haveInputMethods;\r\n        mLimitedAlphaCompositing = context.getResources().getBoolean(\r\n                com.android.internal.R.bool.config_sf_limitedAlpha);\r\n        mHeadless = "1".equals(SystemProperties.get(SYSTEM_HEADLESS, "0"));\r\n\r\n        mPowerManager = pm;\r\n        mPowerManager.setPolicy(mPolicy);\r\n        PowerManager pmc = (PowerManager)context.getSystemService(Context.POWER_SERVICE);\r\n        mScreenFrozenLock = pmc.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,\r\n                "SCREEN_FROZEN");\r\n        mScreenFrozenLock.setReferenceCounted(false);\r\n\r\n        mActivityManager = ActivityManagerNative.getDefault();\r\n        mBatteryStats = BatteryStatsService.getService();\r\n\r\n        // Get persisted window scale setting\r\n        mWindowAnimationScale = Settings.System.getFloat(context.getContentResolver(),\r\n                Settings.System.WINDOW_ANIMATION_SCALE, mWindowAnimationScale);\r\n        mTransitionAnimationScale = Settings.System.getFloat(context.getContentResolver(),\r\n                Settings.System.TRANSITION_ANIMATION_SCALE, mTransitionAnimationScale);\r\n\r\n        // Track changes to DevicePolicyManager state so we can enable/disable keyguard.\r\n        IntentFilter filter = new IntentFilter();\r\n        filter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);\r\n        mContext.registerReceiver(mBroadcastReceiver, filter);\r\n\r\n        mHoldingScreenWakeLock = pmc.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,\r\n                "KEEP_SCREEN_ON_FLAG");\r\n        mHoldingScreenWakeLock.setReferenceCounted(false);\r\n\r\n        mInputManager = new InputManager(context, this);\r\n\r\n        PolicyThread thr = new PolicyThread(mPolicy, this, context, pm);\r\n        thr.start();\r\n\r\n        synchronized (thr) {\r\n            while (!thr.mRunning) {\r\n                try {\r\n                    thr.wait();\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }\r\n        }\r\n\r\n        mInputManager.start();\r\n\r\n        // Add ourself to the Watchdog monitors.\r\n        Watchdog.getInstance().addMonitor(this);\r\n    }\r\n\r\n    @Override\r\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\r\n            throws RemoteException {\r\n        try {\r\n            return super.onTransact(code, data, reply, flags);\r\n        } catch (RuntimeException e) {\r\n            // The window manager only throws security exceptions, so let's\r\n            // log all others.\r\n            if (!(e instanceof SecurityException)) {\r\n                Slog.e(TAG, "Window Manager Crash", e);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private void placeWindowAfter(WindowState pos, WindowState window) {\r\n        final int i = mWindows.indexOf(pos);\r\n        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(\r\n            TAG, "Adding window " + window + " at "\r\n            + (i+1) + " of " + mWindows.size() + " (after " + pos + ")");\r\n        mWindows.add(i+1, window);\r\n        mWindowsChanged = true;\r\n    }\r\n\r\n    private void placeWindowBefore(WindowState pos, WindowState window) {\r\n        final int i = mWindows.indexOf(pos);\r\n        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(\r\n            TAG, "Adding window " + window + " at "\r\n            + i + " of " + mWindows.size() + " (before " + pos + ")");\r\n        mWindows.add(i, window);\r\n        mWindowsChanged = true;\r\n    }\r\n\r\n    //This method finds out the index of a window that has the same app token as\r\n    //win. used for z ordering the windows in mWindows\r\n    private int findIdxBasedOnAppTokens(WindowState win) {\r\n        //use a local variable to cache mWindows\r\n        ArrayList<WindowState> localmWindows = mWindows;\r\n        int jmax = localmWindows.size();\r\n        if(jmax == 0) {\r\n            return -1;\r\n        }\r\n        for(int j = (jmax-1); j >= 0; j--) {\r\n            WindowState wentry = localmWindows.get(j);\r\n            if(wentry.mAppToken == win.mAppToken) {\r\n                return j;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private void addWindowToListInOrderLocked(WindowState win, boolean addToToken) {\r\n        final IWindow client = win.mClient;\r\n        final WindowToken token = win.mToken;\r\n        final ArrayList<WindowState> localmWindows = mWindows;\r\n\r\n        final int N = localmWindows.size();\r\n        final WindowState attached = win.mAttachedWindow;\r\n        int i;\r\n        if (attached == null) {\r\n            int tokenWindowsPos = token.windows.size();\r\n            if (token.appWindowToken != null) {\r\n                int index = tokenWindowsPos-1;\r\n                if (index >= 0) {\r\n                    // If this application has existing windows, we\r\n                    // simply place the new window on top of them... but\r\n                    // keep the starting window on top.\r\n                    if (win.mAttrs.type == TYPE_BASE_APPLICATION) {\r\n                        // Base windows go behind everything else.\r\n                        placeWindowBefore(token.windows.get(0), win);\r\n                        tokenWindowsPos = 0;\r\n                    } else {\r\n                        AppWindowToken atoken = win.mAppToken;\r\n                        if (atoken != null &&\r\n                                token.windows.get(index) == atoken.startingWindow) {\r\n                            placeWindowBefore(token.windows.get(index), win);\r\n                            tokenWindowsPos--;\r\n                        } else {\r\n                            int newIdx =  findIdxBasedOnAppTokens(win);\r\n                            if(newIdx != -1) {\r\n                                //there is a window above this one associated with the same\r\n                                //apptoken note that the window could be a floating window\r\n                                //that was created later or a window at the top of the list of\r\n                                //windows associated with this token.\r\n                                if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {\r\n                                    Slog.v(TAG, "Adding window " + win + " at "\r\n                                            + (newIdx+1) + " of " + N);\r\n                                }\r\n                                localmWindows.add(newIdx+1, win);\r\n                                mWindowsChanged = true;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (localLOGV) Slog.v(\r\n                        TAG, "Figuring out where to add app window "\r\n                        + client.asBinder() + " (token=" + token + ")");\r\n                    // Figure out where the window should go, based on the\r\n                    // order of applications.\r\n                    final int NA = mAppTokens.size();\r\n                    WindowState pos = null;\r\n                    for (i=NA-1; i>=0; i--) {\r\n                        AppWindowToken t = mAppTokens.get(i);\r\n                        if (t == token) {\r\n                            i--;\r\n                            break;\r\n                        }\r\n\r\n                        // We haven't reached the token yet; if this token\r\n                        // is not going to the bottom and has windows, we can\r\n                        // use it as an anchor for when we do reach the token.\r\n                        if (!t.sendingToBottom && t.windows.size() > 0) {\r\n                            pos = t.windows.get(0);\r\n                        }\r\n                    }\r\n                    // We now know the index into the apps.  If we found\r\n                    // an app window above, that gives us the position; else\r\n                    // we need to look some more.\r\n                    if (pos != null) {\r\n                        // Move behind any windows attached to this one.\r\n                        WindowToken atoken = mTokenMap.get(pos.mClient.asBinder());\r\n                        if (atoken != null) {\r\n                            final int NC = atoken.windows.size();\r\n                            if (NC > 0) {\r\n                                WindowState bottom = atoken.windows.get(0);\r\n                                if (bottom.mSubLayer < 0) {\r\n                                    pos = bottom;\r\n                                }\r\n                            }\r\n                        }\r\n                        placeWindowBefore(pos, win);\r\n                    } else {\r\n                        // Continue looking down until we find the first\r\n                        // token that has windows.\r\n                        while (i >= 0) {\r\n                            AppWindowToken t = mAppTokens.get(i);\r\n                            final int NW = t.windows.size();\r\n                            if (NW > 0) {\r\n                                pos = t.windows.get(NW-1);\r\n                                break;\r\n                            }\r\n                            i--;\r\n                        }\r\n                        if (pos != null) {\r\n                            // Move in front of any windows attached to this\r\n                            // one.\r\n                            WindowToken atoken = mTokenMap.get(pos.mClient.asBinder());\r\n                            if (atoken != null) {\r\n                                final int NC = atoken.windows.size();\r\n                                if (NC > 0) {\r\n                                    WindowState top = atoken.windows.get(NC-1);\r\n                                    if (top.mSubLayer >= 0) {\r\n                                        pos = top;\r\n                                    }\r\n                                }\r\n                            }\r\n                            placeWindowAfter(pos, win);\r\n                        } else {\r\n                            // Just search for the start of this layer.\r\n                            final int myLayer = win.mBaseLayer;\r\n                            for (i=0; i<N; i++) {\r\n                                WindowState w = localmWindows.get(i);\r\n                                if (w.mBaseLayer > myLayer) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {\r\n                                Slog.v(TAG, "Adding window " + win + " at "\r\n                                        + i + " of " + N);\r\n                            }\r\n                            localmWindows.add(i, win);\r\n                            mWindowsChanged = true;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Figure out where window should go, based on layer.\r\n                final int myLayer = win.mBaseLayer;\r\n                for (i=N-1; i>=0; i--) {\r\n                    if (localmWindows.get(i).mBaseLayer <= myLayer) {\r\n                        i++;\r\n                        break;\r\n                    }\r\n                }\r\n                if (i < 0) i = 0;\r\n                if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(\r\n                        TAG, "Adding window " + win + " at "\r\n                        + i + " of " + N);\r\n                localmWindows.add(i, win);\r\n                mWindowsChanged = true;\r\n            }\r\n            if (addToToken) {\r\n                if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);\r\n                token.windows.add(tokenWindowsPos, win);\r\n            }\r\n\r\n        } else {\r\n            // Figure out this window's ordering relative to the window\r\n            // it is attached to.\r\n            final int NA = token.windows.size();\r\n            final int sublayer = win.mSubLayer;\r\n            int largestSublayer = Integer.MIN_VALUE;\r\n            WindowState windowWithLargestSublayer = null;\r\n            for (i=0; i<NA; i++) {\r\n                WindowState w = token.windows.get(i);\r\n                final int wSublayer = w.mSubLayer;\r\n                if (wSublayer >= largestSublayer) {\r\n                    largestSublayer = wSublayer;\r\n                    windowWithLargestSublayer = w;\r\n                }\r\n                if (sublayer < 0) {\r\n                    // For negative sublayers, we go below all windows\r\n                    // in the same sublayer.\r\n                    if (wSublayer >= sublayer) {\r\n                        if (addToToken) {\r\n                            if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);\r\n                            token.windows.add(i, win);\r\n                        }\r\n                        placeWindowBefore(\r\n                            wSublayer >= 0 ? attached : w, win);\r\n                        break;\r\n                    }\r\n                } else {\r\n                    // For positive sublayers, we go above all windows\r\n                    // in the same sublayer.\r\n                    if (wSublayer > sublayer) {\r\n                        if (addToToken) {\r\n                            if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);\r\n                            token.windows.add(i, win);\r\n                        }\r\n                        placeWindowBefore(w, win);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (i >= NA) {\r\n                if (addToToken) {\r\n                    if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);\r\n                    token.windows.add(win);\r\n                }\r\n                if (sublayer < 0) {\r\n                    placeWindowBefore(attached, win);\r\n                } else {\r\n                    placeWindowAfter(largestSublayer >= 0\r\n                                     ? windowWithLargestSublayer\r\n                                     : attached,\r\n                                     win);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (win.mAppToken != null && addToToken) {\r\n            win.mAppToken.allAppWindows.add(win);\r\n        }\r\n    }\r\n\r\n    static boolean canBeImeTarget(WindowState w) {\r\n        final int fl = w.mAttrs.flags\r\n                & (FLAG_NOT_FOCUSABLE|FLAG_ALT_FOCUSABLE_IM);\r\n        if (fl == 0 || fl == (FLAG_NOT_FOCUSABLE|FLAG_ALT_FOCUSABLE_IM)\r\n                || w.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING) {\r\n            if (DEBUG_INPUT_METHOD) {\r\n                Slog.i(TAG, "isVisibleOrAdding " + w + ": " + w.isVisibleOrAdding());\r\n                if (!w.isVisibleOrAdding()) {\r\n                    Slog.i(TAG, "  mSurface=" + w.mSurface + " reportDestroy=" + w.mReportDestroySurface\r\n                            + " relayoutCalled=" + w.mRelayoutCalled + " viewVis=" + w.mViewVisibility\r\n                            + " policyVis=" + w.mPolicyVisibility + " attachHid=" + w.mAttachedHidden\r\n                            + " exiting=" + w.mExiting + " destroying=" + w.mDestroying);\r\n                    if (w.mAppToken != null) {\r\n                        Slog.i(TAG, "  mAppToken.hiddenRequested=" + w.mAppToken.hiddenRequested);\r\n                    }\r\n                }\r\n            }\r\n            return w.isVisibleOrAdding();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    int findDesiredInputMethodWindowIndexLocked(boolean willMove) {\r\n        final ArrayList<WindowState> localmWindows = mWindows;\r\n        final int N = localmWindows.size();\r\n        WindowState w = null;\r\n        int i = N;\r\n        while (i > 0) {\r\n            i--;\r\n            w = localmWindows.get(i);\r\n\r\n            if (DEBUG_INPUT_METHOD && willMove) Slog.i(TAG, "Checking window @" + i\r\n                    + " " + w + " fl=0x" + Integer.toHexString(w.mAttrs.flags));\r\n            if (canBeImeTarget(w)) {\r\n                //Slog.i(TAG, "Putting input method here!");\r\n\r\n                // Yet more tricksyness!  If this window is a "starting"\r\n                // window, we do actually want to be on top of it, but\r\n                // it is not -really- where input will go.  So if the caller\r\n                // is not actually looking to move the IME, look down below\r\n                // for a real window to target...\r\n                if (!willMove\r\n                        && w.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING\r\n                        && i > 0) {\r\n                    WindowState wb = localmWindows.get(i-1);\r\n                    if (wb.mAppToken == w.mAppToken && canBeImeTarget(wb)) {\r\n                        i--;\r\n                        w = wb;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (DEBUG_INPUT_METHOD && willMove) Slog.v(TAG, "Proposed new IME target: " + w);\r\n        \r\n        // Now, a special case -- if the last target's window is in the\r\n        // process of exiting, and is above the new target, keep on the\r\n        // last target to avoid flicker.  Consider for example a Dialog with\r\n        // the IME shown: when the Dialog is dismissed, we want to keep\r\n        // the IME above it until it is completely gone so it doesn't drop\r\n        // behind the dialog or its full-screen scrim.\r\n        if (mInputMethodTarget != null && w != null\r\n                && mInputMethodTarget.isDisplayedLw()\r\n                && mInputMethodTarget.mExiting) {\r\n            if (mInputMethodTarget.mAnimLayer > w.mAnimLayer) {\r\n                w = mInputMethodTarget;\r\n                i = localmWindows.indexOf(w);\r\n                if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Current target higher, switching to: " + w);\r\n            }\r\n        }\r\n\r\n        if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Desired input method target="\r\n                + w + " willMove=" + willMove);\r\n\r\n        if (willMove && w != null) {\r\n            final WindowState curTarget = mInputMethodTarget;\r\n            if (curTarget != null && curTarget.mAppToken != null) {\r\n\r\n                // Now some fun for dealing with window animations that\r\n                // modify the Z order.  We need to look at all windows below\r\n                // the current target that are in this app, finding the highest\r\n                // visible one in layering.\r\n                AppWindowToken token = curTarget.mAppToken;\r\n                WindowState highestTarget = null;\r\n                int highestPos = 0;\r\n                if (token.animating || token.animation != null) {\r\n                    int pos = 0;\r\n                    pos = localmWindows.indexOf(curTarget);\r\n                    while (pos >= 0) {\r\n                        WindowState win = localmWindows.get(pos);\r\n                        if (win.mAppToken != token) {\r\n                            break;\r\n                        }\r\n                        if (!win.mRemoved) {\r\n                            if (highestTarget == null || win.mAnimLayer >\r\n                                    highestTarget.mAnimLayer) {\r\n                                highestTarget = win;\r\n                                highestPos = pos;\r\n                            }\r\n                        }\r\n                        pos--;\r\n                    }\r\n                }\r\n\r\n                if (highestTarget != null) {\r\n                    if (DEBUG_INPUT_METHOD) Slog.v(TAG, "mNextAppTransition="\r\n                            + mNextAppTransition + " " + highestTarget\r\n                            + " animating=" + highestTarget.isAnimating()\r\n                            + " layer=" + highestTarget.mAnimLayer\r\n                            + " new layer=" + w.mAnimLayer);\r\n\r\n                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {\r\n                        // If we are currently setting up for an animation,\r\n                        // hold everything until we can find out what will happen.\r\n                        mInputMethodTargetWaitingAnim = true;\r\n                        mInputMethodTarget = highestTarget;\r\n                        return highestPos + 1;\r\n                    } else if (highestTarget.isAnimating() &&\r\n                            highestTarget.mAnimLayer > w.mAnimLayer) {\r\n                        // If the window we are currently targeting is involved\r\n                        // with an animation, and it is on top of the next target\r\n                        // we will be over, then hold off on moving until\r\n                        // that is done.\r\n                        mInputMethodTargetWaitingAnim = true;\r\n                        mInputMethodTarget = highestTarget;\r\n                        return highestPos + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Slog.i(TAG, "Placing input method @" + (i+1));\r\n        if (w != null) {\r\n            if (willMove) {\r\n                if (DEBUG_INPUT_METHOD) {\r\n                    RuntimeException e = null;\r\n                    if (!HIDE_STACK_CRAWLS) {\r\n                        e = new RuntimeException();\r\n                        e.fillInStackTrace();\r\n                    }\r\n                    Slog.w(TAG, "Moving IM target from "\r\n                            + mInputMethodTarget + " to " + w, e);\r\n                }\r\n                mInputMethodTarget = w;\r\n                mInputMethodTargetWaitingAnim = false;\r\n                if (w.mAppToken != null) {\r\n                    setInputMethodAnimLayerAdjustment(w.mAppToken.animLayerAdjustment);\r\n                } else {\r\n                    setInputMethodAnimLayerAdjustment(0);\r\n                }\r\n            }\r\n            return i+1;\r\n        }\r\n        if (willMove) {\r\n            if (DEBUG_INPUT_METHOD) {\r\n                RuntimeException e = null;\r\n                if (!HIDE_STACK_CRAWLS) {\r\n                    e = new RuntimeException();\r\n                    e.fillInStackTrace();\r\n                }\r\n                Slog.w(TAG, "Moving IM target from "\r\n                        + mInputMethodTarget + " to null", e);\r\n            }\r\n            mInputMethodTarget = null;\r\n            setInputMethodAnimLayerAdjustment(0);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    void addInputMethodWindowToListLocked(WindowState win) {\r\n        int pos = findDesiredInputMethodWindowIndexLocked(true);\r\n        if (pos >= 0) {\r\n            win.mTargetAppToken = mInputMethodTarget.mAppToken;\r\n            if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(\r\n                    TAG, "Adding input method window " + win + " at " + pos);\r\n            mWindows.add(pos, win);\r\n            mWindowsChanged = true;\r\n            moveInputMethodDialogsLocked(pos+1);\r\n            return;\r\n        }\r\n        win.mTargetAppToken = null;\r\n        addWindowToListInOrderLocked(win, true);\r\n        moveInputMethodDialogsLocked(pos);\r\n    }\r\n\r\n    void setInputMethodAnimLayerAdjustment(int adj) {\r\n        if (DEBUG_LAYERS) Slog.v(TAG, "Setting im layer adj to " + adj);\r\n        mInputMethodAnimLayerAdjustment = adj;\r\n        WindowState imw = mInputMethodWindow;\r\n        if (imw != null) {\r\n            imw.mAnimLayer = imw.mLayer + adj;\r\n            if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + imw\r\n                    + " anim layer: " + imw.mAnimLayer);\r\n            int wi = imw.mChildWindows.size();\r\n            while (wi > 0) {\r\n                wi--;\r\n                WindowState cw = imw.mChildWindows.get(wi);\r\n                cw.mAnimLayer = cw.mLayer + adj;\r\n                if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + cw\r\n                        + " anim layer: " + cw.mAnimLayer);\r\n            }\r\n        }\r\n        int di = mInputMethodDialogs.size();\r\n        while (di > 0) {\r\n            di --;\r\n            imw = mInputMethodDialogs.get(di);\r\n            imw.mAnimLayer = imw.mLayer + adj;\r\n            if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + imw\r\n                    + " anim layer: " + imw.mAnimLayer);\r\n        }\r\n    }\r\n\r\n    private int tmpRemoveWindowLocked(int interestingPos, WindowState win) {\r\n        int wpos = mWindows.indexOf(win);\r\n        if (wpos >= 0) {\r\n            if (wpos < interestingPos) interestingPos--;\r\n            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Temp removing at " + wpos + ": " + win);\r\n            mWindows.remove(wpos);\r\n            mWindowsChanged = true;\r\n            int NC = win.mChildWindows.size();\r\n            while (NC > 0) {\r\n                NC--;\r\n                WindowState cw = win.mChildWindows.get(NC);\r\n                int cpos = mWindows.indexOf(cw);\r\n                if (cpos >= 0) {\r\n                    if (cpos < interestingPos) interestingPos--;\r\n                    if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Temp removing child at "\r\n                            + cpos + ": " + cw);\r\n                    mWindows.remove(cpos);\r\n                }\r\n            }\r\n        }\r\n        return interestingPos;\r\n    }\r\n\r\n    private void reAddWindowToListInOrderLocked(WindowState win) {\r\n        addWindowToListInOrderLocked(win, false);\r\n        // This is a hack to get all of the child windows added as well\r\n        // at the right position.  Child windows should be rare and\r\n        // this case should be rare, so it shouldn't be that big a deal.\r\n        int wpos = mWindows.indexOf(win);\r\n        if (wpos >= 0) {\r\n            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "ReAdd removing from " + wpos\r\n                    + ": " + win);\r\n            mWindows.remove(wpos);\r\n            mWindowsChanged = true;\r\n            reAddWindowLocked(wpos, win);\r\n        }\r\n    }\r\n\r\n    void logWindowList(String prefix) {\r\n        int N = mWindows.size();\r\n        while (N > 0) {\r\n            N--;\r\n            Slog.v(TAG, prefix + "#" + N + ": " + mWindows.get(N));\r\n        }\r\n    }\r\n\r\n    void moveInputMethodDialogsLocked(int pos) {\r\n        ArrayList<WindowState> dialogs = mInputMethodDialogs;\r\n\r\n        final int N = dialogs.size();\r\n        if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Removing " + N + " dialogs w/pos=" + pos);\r\n        for (int i=0; i<N; i++) {\r\n            pos = tmpRemoveWindowLocked(pos, dialogs.get(i));\r\n        }\r\n        if (DEBUG_INPUT_METHOD) {\r\n            Slog.v(TAG, "Window list w/pos=" + pos);\r\n            logWindowList("  ");\r\n        }\r\n\r\n        if (pos >= 0) {\r\n            final AppWindowToken targetAppToken = mInputMethodTarget.mAppToken;\r\n            if (pos < mWindows.size()) {\r\n                WindowState wp = mWindows.get(pos);\r\n                if (wp == mInputMethodWindow) {\r\n                    pos++;\r\n                }\r\n            }\r\n            if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Adding " + N + " dialogs at pos=" + pos);\r\n            for (int i=0; i<N; i++) {\r\n                WindowState win = dialogs.get(i);\r\n                win.mTargetAppToken = targetAppToken;\r\n                pos = reAddWindowLocked(pos, win);\r\n            }\r\n            if (DEBUG_INPUT_METHOD) {\r\n                Slog.v(TAG, "Final window list:");\r\n                logWindowList("  ");\r\n            }\r\n            return;\r\n        }\r\n        for (int i=0; i<N; i++) {\r\n            WindowState win = dialogs.get(i);\r\n            win.mTargetAppToken = null;\r\n            reAddWindowToListInOrderLocked(win);\r\n            if (DEBUG_INPUT_METHOD) {\r\n                Slog.v(TAG, "No IM target, final list:");\r\n                logWindowList("  ");\r\n            }\r\n        }\r\n    }\r\n\r\n    boolean moveInputMethodWindowsIfNeededLocked(boolean needAssignLayers) {\r\n        final WindowState imWin = mInputMethodWindow;\r\n        final int DN = mInputMethodDialogs.size();\r\n        if (imWin == null && DN == 0) {\r\n            return false;\r\n        }\r\n\r\n        int imPos = findDesiredInputMethodWindowIndexLocked(true);\r\n        if (imPos >= 0) {\r\n            // In this case, the input method windows are to be placed\r\n            // immediately above the window they are targeting.\r\n\r\n            // First check to see if the input method windows are already\r\n            // located here, and contiguous.\r\n            final int N = mWindows.size();\r\n            WindowState firstImWin = imPos < N\r\n                    ? mWindows.get(imPos) : null;\r\n\r\n            // Figure out the actual input method window that should be\r\n            // at the bottom of their stack.\r\n            WindowState baseImWin = imWin != null\r\n                    ? imWin : mInputMethodDialogs.get(0);\r\n            if (baseImWin.mChildWindows.size() > 0) {\r\n                WindowState cw = baseImWin.mChildWindows.get(0);\r\n                if (cw.mSubLayer < 0) baseImWin = cw;\r\n            }\r\n\r\n            if (firstImWin == baseImWin) {\r\n                // The windows haven't moved...  but are they still contiguous?\r\n                // First find the top IM window.\r\n                int pos = imPos+1;\r\n                while (pos < N) {\r\n                    if (!(mWindows.get(pos)).mIsImWindow) {\r\n                        break;\r\n                    }\r\n                    pos++;\r\n                }\r\n                pos++;\r\n                // Now there should be no more input method windows above.\r\n                while (pos < N) {\r\n                    if ((mWindows.get(pos)).mIsImWindow) {\r\n                        break;\r\n                    }\r\n                    pos++;\r\n                }\r\n                if (pos >= N) {\r\n                    // All is good!\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            if (imWin != null) {\r\n                if (DEBUG_INPUT_METHOD) {\r\n                    Slog.v(TAG, "Moving IM from " + imPos);\r\n                    logWindowList("  ");\r\n                }\r\n                imPos = tmpRemoveWindowLocked(imPos, imWin);\r\n                if (DEBUG_INPUT_METHOD) {\r\n                    Slog.v(TAG, "List after removing with new pos " + imPos + ":");\r\n                    logWindowList("  ");\r\n                }\r\n                imWin.mTargetAppToken = mInputMethodTarget.mAppToken;\r\n                reAddWindowLocked(imPos, imWin);\r\n                if (DEBUG_INPUT_METHOD) {\r\n                    Slog.v(TAG, "List after moving IM to " + imPos + ":");\r\n                    logWindowList("  ");\r\n                }\r\n                if (DN > 0) moveInputMethodDialogsLocked(imPos+1);\r\n            } else {\r\n                moveInputMethodDialogsLocked(imPos);\r\n            }\r\n\r\n        } else {\r\n            // In this case, the input method windows go in a fixed layer,\r\n            // because they aren't currently associated with a focus window.\r\n\r\n            if (imWin != null) {\r\n                if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Moving IM from " + imPos);\r\n                tmpRemoveWindowLocked(0, imWin);\r\n                imWin.mTargetAppToken = null;\r\n                reAddWindowToListInOrderLocked(imWin);\r\n                if (DEBUG_INPUT_METHOD) {\r\n                    Slog.v(TAG, "List with no IM target:");\r\n                    logWindowList("  ");\r\n                }\r\n                if (DN > 0) moveInputMethodDialogsLocked(-1);;\r\n            } else {\r\n                moveInputMethodDialogsLocked(-1);;\r\n            }\r\n\r\n        }\r\n\r\n        if (needAssignLayers) {\r\n            assignLayersLocked();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    void adjustInputMethodDialogsLocked() {\r\n        moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true));\r\n    }\r\n\r\n    final boolean isWallpaperVisible(WindowState wallpaperTarget) {\r\n        if (DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper vis: target obscured="\r\n                + (wallpaperTarget != null ? Boolean.toString(wallpaperTarget.mObscured) : "??")\r\n                + " anim=" + ((wallpaperTarget != null && wallpaperTarget.mAppToken != null)\r\n                        ? wallpaperTarget.mAppToken.animation : null)\r\n                + " upper=" + mUpperWallpaperTarget\r\n                + " lower=" + mLowerWallpaperTarget);\r\n        return (wallpaperTarget != null\r\n                        && (!wallpaperTarget.mObscured || (wallpaperTarget.mAppToken != null\r\n                                && wallpaperTarget.mAppToken.animation != null)))\r\n                || mUpperWallpaperTarget != null\r\n                || mLowerWallpaperTarget != null;\r\n    }\r\n\r\n    static final int ADJUST_WALLPAPER_LAYERS_CHANGED = 1<<1;\r\n    static final int ADJUST_WALLPAPER_VISIBILITY_CHANGED = 1<<2;\r\n\r\n    int adjustWallpaperWindowsLocked() {\r\n        int changed = 0;\r\n\r\n        final int dw = mAppDisplayWidth;\r\n        final int dh = mAppDisplayHeight;\r\n\r\n        // First find top-most window that has asked to be on top of the\r\n        // wallpaper; all wallpapers go behind it.\r\n        final ArrayList<WindowState> localmWindows = mWindows;\r\n        int N = localmWindows.size();\r\n        WindowState w = null;\r\n        WindowState foundW = null;\r\n        int foundI = 0;\r\n        WindowState topCurW = null;\r\n        int topCurI = 0;\r\n        int windowDetachedI = -1;\r\n        int i = N;\r\n        while (i > 0) {\r\n            i--;\r\n            w = localmWindows.get(i);\r\n            if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {\r\n                if (topCurW == null) {\r\n                    topCurW = w;\r\n                    topCurI = i;\r\n                }\r\n                continue;\r\n            }\r\n            topCurW = null;\r\n            if (w != mWindowDetachedWallpaper && w.mAppToken != null) {\r\n                // If this window's app token is hidden and not animating,\r\n                // it is of no interest to us.\r\n                if (w.mAppToken.hidden && w.mAppToken.animation == null) {\r\n                    if (DEBUG_WALLPAPER) Slog.v(TAG,\r\n                            "Skipping not hidden or animating token: " + w);\r\n                    continue;\r\n                }\r\n            }\r\n            if (DEBUG_WALLPAPER) Slog.v(TAG, "Win " + w + ": readyfordisplay="\r\n                    + w.isReadyForDisplay() + " drawpending=" + w.mDrawPending\r\n                    + " commitdrawpending=" + w.mCommitDrawPending);\r\n            if ((w.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay()\r\n                    && (mWallpaperTarget == w\r\n                            || (!w.mDrawPending && !w.mCommitDrawPending))) {\r\n                if (DEBUG_WALLPAPER) Slog.v(TAG,\r\n                        "Found wallpaper activity: #" + i + "=" + w);\r\n                foundW = w;\r\n                foundI = i;\r\n                if (w == mWallpaperTarget && ((w.mAppToken != null\r\n                        && w.mAppToken.animation != null)\r\n                        || w.mAnimation != null)) {\r\n                    // The current wallpaper target is animating, so we'll\r\n                    // look behind it for another possible target and figure\r\n                    // out what is going on below.\r\n                    if (DEBUG_WALLPAPER) Slog.v(TAG, "Win " + w\r\n                            + ": token animating, looking behind.");\r\n                    continue;\r\n                }\r\n                break;\r\n            } else if (w == mWindowDetachedWallpaper) {\r\n                windowDetachedI = i;\r\n            }\r\n        }\r\n\r\n        if (foundW == null && windowDetachedI >= 0) {\r\n            if (DEBUG_WALLPAPER) Slog.v(TAG,\r\n                    "Found animating detached wallpaper activity: #" + i + "=" + w);\r\n            foundW = w;\r\n            foundI = windowDetachedI;\r\n        }\r\n\r\n        if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {\r\n            // If we are currently waiting for an app transition, and either\r\n            // the current target or the next target are involved with it,\r\n            // then hold off on doing anything with the wallpaper.\r\n            // Note that we are checking here for just whether the target\r\n            // is part of an app token...  which is potentially overly aggressive\r\n            // (the app token may not be involved in the transition), but good\r\n            // enough (we'll just wait until whatever transition is pending\r\n            // executes).\r\n            if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {\r\n                if (DEBUG_WALLPAPER) Slog.v(TAG,\r\n                        "Wallpaper not changing: waiting for app anim in current target");\r\n                return 0;\r\n            }\r\n            if (foundW != null && foundW.mAppToken != null) {\r\n                if (DEBUG_WALLPAPER) Slog.v(TAG,\r\n                        "Wallpaper not changing: waiting for app anim in found target");\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        if (mWallpaperTarget != foundW) {\r\n            if (DEBUG_WALLPAPER) {\r\n                Slog.v(TAG, "New wallpaper target: " + foundW\r\n                        + " oldTarget: " + mWallpaperTarget);\r\n            }\r\n\r\n            mLowerWallpaperTarget = null;\r\n            mUpperWallpaperTarget = null;\r\n\r\n            WindowState oldW = mWallpaperTarget;\r\n            mWallpaperTarget = foundW;\r\n\r\n            // Now what is happening...  if the current and new targets are\r\n            // animating, then we are in our super special mode!\r\n            if (foundW != null && oldW != null) {\r\n                boolean oldAnim = oldW.mAnimation != null\r\n                        || (oldW.mAppToken != null && oldW.mAppToken.animation != null);\r\n                boolean foundAnim = foundW.mAnimation != null\r\n                        || (foundW.mAppToken != null && foundW.mAppToken.animation != null);\r\n                if (DEBUG_WALLPAPER) {\r\n                    Slog.v(TAG, "New animation: " + foundAnim\r\n                            + " old animation: " + oldAnim);\r\n                }\r\n                if (foundAnim && oldAnim) {\r\n                    int oldI = localmWindows.indexOf(oldW);\r\n                    if (DEBUG_WALLPAPER) {\r\n                        Slog.v(TAG, "New i: " + foundI + " old i: " + oldI);\r\n                    }\r\n                    if (oldI >= 0) {\r\n                        if (DEBUG_WALLPAPER) {\r\n                            Slog.v(TAG, "Animating wallpapers: old#" + oldI\r\n                                    + "=" + oldW + "; new#" + foundI\r\n                                    + "=" + foundW);\r\n                        }\r\n\r\n                        // Set the new target correctly.\r\n                        if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {\r\n                            if (DEBUG_WALLPAPER) {\r\n                                Slog.v(TAG, "Old wallpaper still the target.");\r\n                            }\r\n                            mWallpaperTarget = oldW;\r\n                        }\r\n\r\n                        // Now set the upper and lower wallpaper targets\r\n                        // correctly, and make sure that we are positioning\r\n                        // the wallpaper below the lower.\r\n                        if (foundI > oldI) {\r\n                            // The new target is on top of the old one.\r\n                            if (DEBUG_WALLPAPER) {\r\n                                Slog.v(TAG, "Found target above old target.");\r\n                            }\r\n                            mUpperWallpaperTarget = foundW;\r\n                            mLowerWallpaperTarget = oldW;\r\n                            foundW = oldW;\r\n                            foundI = oldI;\r\n                        } else {\r\n                            // The new target is below the old one.\r\n                            if (DEBUG_WALLPAPER) {\r\n                                Slog.v(TAG, "Found target below old target.");\r\n                            }\r\n                            mUpperWallpaperTarget = oldW;\r\n                            mLowerWallpaperTarget = foundW;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else if (mLowerWallpaperTarget != null) {\r\n            // Is it time to stop animating?\r\n            boolean lowerAnimating = mLowerWallpaperTarget.mAnimation != null\r\n                    || (mLowerWallpaperTarget.mAppToken != null\r\n                            && mLowerWallpaperTarget.mAppToken.animation != null);\r\n            boolean upperAnimating = mUpperWallpaperTarget.mAnimation != null\r\n                    || (mUpperWallpaperTarget.mAppToken != null\r\n                            && mUpperWallpaperTarget.mAppToken.animation != null);\r\n            if (!lowerAnimating || !upperAnimating) {\r\n                if (DEBUG_WALLPAPER) {\r\n                    Slog.v(TAG, "No longer animating wallpaper targets!");\r\n                }\r\n                mLowerWallpaperTarget = null;\r\n                mUpperWallpaperTarget = null;\r\n            }\r\n        }\r\n\r\n        boolean visible = foundW != null;\r\n        if (visible) {\r\n            // The window is visible to the compositor...  but is it visible\r\n            // to the user?  That is what the wallpaper cares about.\r\n            visible = isWallpaperVisible(foundW);\r\n            if (DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper visibility: " + visible);\r\n\r\n            // If the wallpaper target is animating, we may need to copy\r\n            // its layer adjustment.  Only do this if we are not transfering\r\n            // between two wallpaper targets.\r\n            mWallpaperAnimLayerAdjustment =\r\n                    (mLowerWallpaperTarget == null && foundW.mAppToken != null)\r\n                    ? foundW.mAppToken.animLayerAdjustment : 0;\r\n\r\n            final int maxLayer = mPolicy.getMaxWallpaperLayer()\r\n                    * TYPE_LAYER_MULTIPLIER\r\n                    + TYPE_LAYER_OFFSET;\r\n\r\n            // Now w is the window we are supposed to be behind...  but we\r\n            // need to be sure to also be behind any of its attached windows,\r\n            // AND any starting window associated with it, AND below the\r\n            // maximum layer the policy allows for wallpapers.\r\n            while (foundI > 0) {\r\n                WindowState wb = localmWindows.get(foundI-1);\r\n                if (wb.mBaseLayer < maxLayer &&\r\n                        wb.mAttachedWindow != foundW &&\r\n                        (foundW.mAttachedWindow == null ||\r\n                                wb.mAttachedWindow != foundW.mAttachedWindow) &&\r\n                        (wb.mAttrs.type != TYPE_APPLICATION_STARTING ||\r\n                                foundW.mToken == null || wb.mToken != foundW.mToken)) {\r\n                    // This window is not related to the previous one in any\r\n                    // interesting way, so stop here.\r\n                    break;\r\n                }\r\n                foundW = wb;\r\n                foundI--;\r\n            }\r\n        } else {\r\n            if (DEBUG_WALLPAPER) Slog.v(TAG, "No wallpaper target");\r\n        }\r\n\r\n        if (foundW == null && topCurW != null) {\r\n            // There is no wallpaper target, so it goes at the bottom.\r\n            // We will assume it is the same place as last time, if known.\r\n            foundW = topCurW;\r\n            foundI = topCurI+1;\r\n        } else {\r\n            // Okay i is the position immediately above the wallpaper.  Look at\r\n            // what is below it for later.\r\n            foundW = foundI > 0 ? localmWindows.get(foundI-1) : null;\r\n        }\r\n\r\n        if (visible) {\r\n            if (mWallpaperTarget.mWallpaperX >= 0) {\r\n                mLastWallpaperX = mWallpaperTarget.mWallpaperX;\r\n                mLastWallpaperXStep = mWallpaperTarget.mWallpaperXStep;\r\n            }\r\n            if (mWallpaperTarget.mWallpaperY >= 0) {\r\n                mLastWallpaperY = mWallpaperTarget.mWallpaperY;\r\n                mLastWallpaperYStep = mWallpaperTarget.mWallpaperYStep;\r\n            }\r\n        }\r\n\r\n        // Start stepping backwards from here, ensuring that our wallpaper windows\r\n        // are correctly placed.\r\n        int curTokenIndex = mWallpaperTokens.size();\r\n        while (curTokenIndex > 0) {\r\n            curTokenIndex--;\r\n            WindowToken token = mWallpaperTokens.get(curTokenIndex);\r\n            if (token.hidden == visible) {\r\n                changed |= ADJUST_WALLPAPER_VISIBILITY_CHANGED;\r\n                token.hidden = !visible;\r\n                // Need to do a layout to ensure the wallpaper now has the\r\n                // correct size.\r\n                mLayoutNeeded = true;\r\n            }\r\n\r\n            int curWallpaperIndex = token.windows.size();\r\n            while (curWallpaperIndex > 0) {\r\n                curWallpaperIndex--;\r\n                WindowState wallpaper = token.windows.get(curWallpaperIndex);\r\n\r\n                if (visible) {\r\n                    updateWallpaperOffsetLocked(wallpaper, dw, dh, false);\r\n                }\r\n\r\n                // First, make sure the client has the current visibility\r\n                // state.\r\n                if (wallpaper.mWallpaperVisible != visible) {\r\n                    wallpaper.mWallpaperVisible = visible;\r\n                    try {\r\n                        if (DEBUG_VISIBILITY || DEBUG_WALLPAPER) Slog.v(TAG,\r\n                                "Setting visibility of wallpaper " + wallpaper\r\n                                + ": " + visible);\r\n                        wallpaper.mClient.dispatchAppVisibility(visible);\r\n                    } catch (RemoteException e) {\r\n                    }\r\n                }\r\n\r\n                wallpaper.mAnimLayer = wallpaper.mLayer + mWallpaperAnimLayerAdjustment;\r\n                if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper win "\r\n                        + wallpaper + " anim layer: " + wallpaper.mAnimLayer);\r\n\r\n                // First, if this window is at the current index, then all\r\n                // is well.\r\n                if (wallpaper == foundW) {\r\n                    foundI--;\r\n                    foundW = foundI > 0\r\n                            ? localmWindows.get(foundI-1) : null;\r\n                    continue;\r\n                }\r\n\r\n                // The window didn't match...  the current wallpaper window,\r\n                // wherever it is, is in the wrong place, so make sure it is\r\n                // not in the list.\r\n                int oldIndex = localmWindows.indexOf(wallpaper);\r\n                if (oldIndex >= 0) {\r\n                    if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Wallpaper removing at "\r\n                            + oldIndex + ": " + wallpaper);\r\n                    localmWindows.remove(oldIndex);\r\n                    mWindowsChanged = true;\r\n                    if (oldIndex < foundI) {\r\n                        foundI--;\r\n                    }\r\n                }\r\n\r\n                // Now stick it in.\r\n                if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {\r\n                    Slog.v(TAG, "Moving wallpaper " + wallpaper\r\n                            + " from " + oldIndex + " to " + foundI);\r\n                }\r\n\r\n                localmWindows.add(foundI, wallpaper);\r\n                mWindowsChanged = true;\r\n                changed |= ADJUST_WALLPAPER_LAYERS_CHANGED;\r\n            }\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    void setWallpaperAnimLayerAdjustmentLocked(int adj) {\r\n        if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG,\r\n                "Setting wallpaper layer adj to " + adj);\r\n        mWallpaperAnimLayerAdjustment = adj;\r\n        int curTokenIndex = mWallpaperTokens.size();\r\n        while (curTokenIndex > 0) {\r\n            curTokenIndex--;\r\n            WindowToken token = mWallpaperTokens.get(curTokenIndex);\r\n            int curWallpaperIndex = token.windows.size();\r\n            while (curWallpaperIndex > 0) {\r\n                curWallpaperIndex--;\r\n                WindowState wallpaper = token.windows.get(curWallpaperIndex);\r\n                wallpaper.mAnimLayer = wallpaper.mLayer + adj;\r\n                if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper win "\r\n                        + wallpaper + " anim layer: " + wallpaper.mAnimLayer);\r\n            }\r\n        }\r\n    }\r\n\r\n    boolean updateWallpaperOffsetLocked(WindowState wallpaperWin, int dw, int dh,\r\n            boolean sync) {\r\n        boolean changed = false;\r\n        boolean rawChanged = false;\r\n        float wpx = mLastWallpaperX >= 0 ? mLastWallpaperX : 0.5f;\r\n        float wpxs = mLastWallpaperXStep >= 0 ? mLastWallpaperXStep : -1.0f;\r\n        int availw = wallpaperWin.mFrame.right-wallpaperWin.mFrame.left-dw;\r\n        int offset = availw > 0 ? -(int)(availw*wpx+.5f) : 0;\r\n        changed = wallpaperWin.mXOffset != offset;\r\n        if (changed) {\r\n            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper "\r\n                    + wallpaperWin + " x: " + offset);\r\n            wallpaperWin.mXOffset = offset;\r\n        }\r\n        if (wallpaperWin.mWallpaperX != wpx || wallpaperWin.mWallpaperXStep != wpxs) {\r\n            wallpaperWin.mWallpaperX = wpx;\r\n            wallpaperWin.mWallpaperXStep = wpxs;\r\n            rawChanged = true;\r\n        }\r\n\r\n        float wpy = mLastWallpaperY >= 0 ? mLastWallpaperY : 0.5f;\r\n        float wpys = mLastWallpaperYStep >= 0 ? mLastWallpaperYStep : -1.0f;\r\n        int availh = wallpaperWin.mFrame.bottom-wallpaperWin.mFrame.top-dh;\r\n        offset = availh > 0 ? -(int)(availh*wpy+.5f) : 0;\r\n        if (wallpaperWin.mYOffset != offset) {\r\n            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper "\r\n                    + wallpaperWin + " y: " + offset);\r\n            changed = true;\r\n            wallpaperWin.mYOffset = offset;\r\n        }\r\n        if (wallpaperWin.mWallpaperY != wpy || wallpaperWin.mWallpaperYStep != wpys) {\r\n            wallpaperWin.mWallpaperY = wpy;\r\n            wallpaperWin.mWallpaperYStep = wpys;\r\n            rawChanged = true;\r\n        }\r\n\r\n        if (rawChanged) {\r\n            try {\r\n                if (DEBUG_WALLPAPER) Slog.v(TAG, "Report new wp offset "\r\n                        + wallpaperWin + " x=" + wallpaperWin.mWallpaperX\r\n                        + " y=" + wallpaperWin.mWallpaperY);\r\n                if (sync) {\r\n                    mWaitingOnWallpaper = wallpaperWin;\r\n                }\r\n                wallpaperWin.mClient.dispatchWallpaperOffsets(\r\n                        wallpaperWin.mWallpaperX, wallpaperWin.mWallpaperY,\r\n                        wallpaperWin.mWallpaperXStep, wallpaperWin.mWallpaperYStep, sync);\r\n                if (sync) {\r\n                    if (mWaitingOnWallpaper != null) {\r\n                        long start = SystemClock.uptimeMillis();\r\n                        if ((mLastWallpaperTimeoutTime+WALLPAPER_TIMEOUT_RECOVERY)\r\n                                < start) {\r\n                            try {\r\n                                if (DEBUG_WALLPAPER) Slog.v(TAG,\r\n                                        "Waiting for offset complete...");\r\n                                mWindowMap.wait(WALLPAPER_TIMEOUT);\r\n                            } catch (InterruptedException e) {\r\n                            }\r\n                            if (DEBUG_WALLPAPER) Slog.v(TAG, "Offset complete!");\r\n                            if ((start+WALLPAPER_TIMEOUT)\r\n                                    < SystemClock.uptimeMillis()) {\r\n                                Slog.i(TAG, "Timeout waiting for wallpaper to offset: "\r\n                                        + wallpaperWin);\r\n                                mLastWallpaperTimeoutTime = start;\r\n                            }\r\n                        }\r\n                        mWaitingOnWallpaper = null;\r\n                    }\r\n                }\r\n            } catch (RemoteException e) {\r\n            }\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    void wallpaperOffsetsComplete(IBinder window) {\r\n        synchronized (mWindowMap) {\r\n            if (mWaitingOnWallpaper != null &&\r\n                    mWaitingOnWallpaper.mClient.asBinder() == window) {\r\n                mWaitingOnWallpaper = null;\r\n                mWindowMap.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    boolean updateWallpaperOffsetLocked(WindowState changingTarget, boolean sync) {\r\n        final int dw = mAppDisplayWidth;\r\n        final int dh = mAppDisplayHeight;\r\n\r\n        boolean changed = false;\r\n\r\n        WindowState target = mWallpaperTarget;\r\n        if (target != null) {\r\n            if (target.mWallpaperX >= 0) {\r\n                mLastWallpaperX = target.mWallpaperX;\r\n            } else if (changingTarget.mWallpaperX >= 0) {\r\n                mLastWallpaperX = changingTarget.mWallpaperX;\r\n            }\r\n            if (target.mWallpaperY >= 0) {\r\n                mLastWallpaperY = target.mWallpaperY;\r\n            } else if (changingTarget.mWallpaperY >= 0) {\r\n                mLastWallpaperY = changingTarget.mWallpaperY;\r\n            }\r\n        }\r\n\r\n        int curTokenIndex = mWallpaperTokens.size();\r\n        while (curTokenIndex > 0) {\r\n            curTokenIndex--;\r\n            WindowToken token = mWallpaperTokens.get(curTokenIndex);\r\n            int curWallpaperIndex = token.windows.size();\r\n            while (curWallpaperIndex > 0) {\r\n                curWallpaperIndex--;\r\n                WindowState wallpaper = token.windows.get(curWallpaperIndex);\r\n                if (updateWallpaperOffsetLocked(wallpaper, dw, dh, sync)) {\r\n                    wallpaper.computeShownFrameLocked();\r\n                    changed = true;\r\n                    // We only want to be synchronous with one wallpaper.\r\n                    sync = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    void updateWallpaperVisibilityLocked() {\r\n        final boolean visible = isWallpaperVisible(mWallpaperTarget);\r\n        final int dw = mAppDisplayWidth;\r\n        final int dh = mAppDisplayHeight;\r\n\r\n        int curTokenIndex = mWallpaperTokens.size();\r\n        while (curTokenIndex > 0) {\r\n            curTokenIndex--;\r\n            WindowToken token = mWallpaperTokens.get(curTokenIndex);\r\n            if (token.hidden == visible) {\r\n                token.hidden = !visible;\r\n                // Need to do a layout to ensure the wallpaper now has the\r\n                // correct size.\r\n                mLayoutNeeded = true;\r\n            }\r\n\r\n            int curWallpaperIndex = token.windows.size();\r\n            while (curWallpaperIndex > 0) {\r\n                curWallpaperIndex--;\r\n                WindowState wallpaper = token.windows.get(curWallpaperIndex);\r\n                if (visible) {\r\n                    updateWallpaperOffsetLocked(wallpaper, dw, dh, false);\r\n                }\r\n\r\n                if (wallpaper.mWallpaperVisible != visible) {\r\n                    wallpaper.mWallpaperVisible = visible;\r\n                    try {\r\n                        if (DEBUG_VISIBILITY || DEBUG_WALLPAPER) Slog.v(TAG,\r\n                                "Updating visibility of wallpaper " + wallpaper\r\n                                + ": " + visible);\r\n                        wallpaper.mClient.dispatchAppVisibility(visible);\r\n                    } catch (RemoteException e) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public int addWindow(Session session, IWindow client,\r\n            WindowManager.LayoutParams attrs, int viewVisibility,\r\n            Rect outContentInsets, InputChannel outInputChannel) {\r\n        int res = mPolicy.checkAddPermission(attrs);\r\n        if (res != WindowManagerImpl.ADD_OKAY) {\r\n            return res;\r\n        }\r\n\r\n        boolean reportNewConfig = false;\r\n        WindowState attachedWindow = null;\r\n        WindowState win = null;\r\n        long origId;\r\n\r\n        synchronized(mWindowMap) {\r\n            if (mDisplay == null) {\r\n                throw new IllegalStateException("Display has not been initialialized");\r\n            }\r\n\r\n            if (mWindowMap.containsKey(client.asBinder())) {\r\n                Slog.w(TAG, "Window " + client + " is already added");\r\n                return WindowManagerImpl.ADD_DUPLICATE_ADD;\r\n            }\r\n\r\n            if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {\r\n                attachedWindow = windowForClientLocked(null, attrs.token, false);\r\n                if (attachedWindow == null) {\r\n                    Slog.w(TAG, "Attempted to add window with token that is not a window: "\r\n                          + attrs.token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;\r\n                }\r\n                if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW\r\n                        && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {\r\n                    Slog.w(TAG, "Attempted to add window with token that is a sub-window: "\r\n                            + attrs.token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;\r\n                }\r\n            }\r\n\r\n            boolean addToken = false;\r\n            WindowToken token = mTokenMap.get(attrs.token);\r\n            if (token == null) {\r\n                if (attrs.type >= FIRST_APPLICATION_WINDOW\r\n                        && attrs.type <= LAST_APPLICATION_WINDOW) {\r\n                    Slog.w(TAG, "Attempted to add application window with unknown token "\r\n                          + attrs.token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;\r\n                }\r\n                if (attrs.type == TYPE_INPUT_METHOD) {\r\n                    Slog.w(TAG, "Attempted to add input method window with unknown token "\r\n                          + attrs.token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;\r\n                }\r\n                if (attrs.type == TYPE_WALLPAPER) {\r\n                    Slog.w(TAG, "Attempted to add wallpaper window with unknown token "\r\n                          + attrs.token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;\r\n                }\r\n                token = new WindowToken(this, attrs.token, -1, false);\r\n                addToken = true;\r\n            } else if (attrs.type >= FIRST_APPLICATION_WINDOW\r\n                    && attrs.type <= LAST_APPLICATION_WINDOW) {\r\n                AppWindowToken atoken = token.appWindowToken;\r\n                if (atoken == null) {\r\n                    Slog.w(TAG, "Attempted to add window with non-application token "\r\n                          + token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_NOT_APP_TOKEN;\r\n                } else if (atoken.removed) {\r\n                    Slog.w(TAG, "Attempted to add window with exiting application token "\r\n                          + token + ".  Aborting.");\r\n                    return WindowManagerImpl.ADD_APP_EXITING;\r\n                }\r\n                if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {\r\n                    // No need for this guy!\r\n                    if (localLOGV) Slog.v(\r\n                            TAG, "**** NO NEED TO START: " + attrs.getTitle());\r\n                    return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;\r\n                }\r\n            } else if (attrs.type == TYPE_INPUT_METHOD) {\r\n                if (token.windowType != TYPE_INPUT_METHOD) {\r\n                    Slog.w(TAG, "Attempted to add input method window with bad token "\r\n                            + attrs.token + ".  Aborting.");\r\n                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;\r\n                }\r\n            } else if (attrs.type == TYPE_WALLPAPER) {\r\n                if (token.windowType != TYPE_WALLPAPER) {\r\n                    Slog.w(TAG, "Attempted to add wallpaper window with bad token "\r\n                            + attrs.token + ".  Aborting.");\r\n                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;\r\n                }\r\n            }\r\n\r\n            win = new WindowState(this, session, client, token,\r\n                    attachedWindow, attrs, viewVisibility);\r\n            if (win.mDeathRecipient == null) {\r\n                // Client has apparently died, so there is no reason to\r\n                // continue.\r\n                Slog.w(TAG, "Adding window client " + client.asBinder()\r\n                        + " that is dead, aborting.");\r\n                return WindowManagerImpl.ADD_APP_EXITING;\r\n            }\r\n\r\n            mPolicy.adjustWindowParamsLw(win.mAttrs);\r\n\r\n            res = mPolicy.prepareAddWindowLw(win, attrs);\r\n            if (res != WindowManagerImpl.ADD_OKAY) {\r\n                return res;\r\n            }\r\n            \r\n            if (outInputChannel != null) {\r\n                String name = win.makeInputChannelName();\r\n                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\r\n                win.mInputChannel = inputChannels[0];\r\n                inputChannels[1].transferTo(outInputChannel);\r\n                \r\n                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);\r\n            }\r\n\r\n            // From now on, no exceptions or errors allowed!\r\n\r\n            res = WindowManagerImpl.ADD_OKAY;\r\n\r\n            origId = Binder.clearCallingIdentity();\r\n\r\n            if (addToken) {\r\n                mTokenMap.put(attrs.token, token);\r\n            }\r\n            win.attach();\r\n            mWindowMap.put(client.asBinder(), win);\r\n\r\n            if (attrs.type == TYPE_APPLICATION_STARTING &&\r\n                    token.appWindowToken != null) {\r\n                token.appWindowToken.startingWindow = win;\r\n            }\r\n\r\n            boolean imMayMove = true;\r\n\r\n            if (attrs.type == TYPE_INPUT_METHOD) {\r\n                mInputMethodWindow = win;\r\n                addInputMethodWindowToListLocked(win);\r\n                imMayMove = false;\r\n            } else if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {\r\n                mInputMethodDialogs.add(win);\r\n                addWindowToListInOrderLocked(win, true);\r\n                adjustInputMethodDialogsLocked();\r\n                imMayMove = false;\r\n            } else {\r\n                addWindowToListInOrderLocked(win, true);\r\n                if (attrs.type == TYPE_WALLPAPER) {\r\n                    mLastWallpaperTimeoutTime = 0;\r\n                    adjustWallpaperWindowsLocked();\r\n                } else if ((attrs.flags&FLAG_SHOW_WALLPAPER) != 0) {\r\n                    adjustWallpaperWindowsLocked();\r\n                }\r\n            }\r\n\r\n            win.mEnterAnimationPending = true;\r\n\r\n            mPolicy.getContentInsetHintLw(attrs, outContentInsets);\r\n\r\n            if (mInTouchMode) {\r\n                res |= WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;\r\n            }\r\n            if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {\r\n                res |= WindowManagerImpl.ADD_FLAG_APP_VISIBLE;\r\n            }\r\n\r\n            mInputMonitor.setUpdateInputWindowsNeededLw();\r\n\r\n            boolean focusChanged = false;\r\n            if (win.canReceiveKeys()) {\r\n                focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,\r\n                        false /*updateInputWindows*/);\r\n                if (focusChanged) {\r\n                    imMayMove = false;\r\n                }\r\n            }\r\n\r\n            if (imMayMove) {\r\n                moveInputMethodWindowsIfNeededLocked(false);\r\n            }\r\n\r\n            assignLayersLocked();\r\n            // Don't do layout here, the window must call\r\n            // relayout to be displayed, so we'll do it there.\r\n\r\n            //dump();\r\n\r\n            if (focusChanged) {\r\n                finishUpdateFocusedWindowAfterAssignLayersLocked(false /*updateInputWindows*/);\r\n            }\r\n            mInputMonitor.updateInputWindowsLw(false /*force*/);\r\n\r\n            if (localLOGV) Slog.v(\r\n                TAG, "New client " + client.asBinder()\r\n                + ": window=" + win);\r\n            \r\n            if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked(false)) {\r\n                reportNewConfig = true;\r\n            }\r\n        }\r\n\r\n        if (reportNewConfig) {\r\n            sendNewConfiguration();\r\n        }\r\n\r\n        Binder.restoreCallingIdentity(origId);\r\n\r\n        return res;\r\n    }\r\n\r\n    public void removeWindow(Session session, IWindow client) {\r\n        synchronized(mWindowMap) {\r\n            WindowState win = windowForClientLocked(session, client, false);\r\n            if (win == null) {\r\n                return;\r\n            }\r\n            removeWindowLocked(session, win);\r\n        }\r\n    }\r\n\r\n    public void removeWindowLocked(Session session, WindowState win) {\r\n\r\n        if (localLOGV || DEBUG_FOCUS) Slog.v(\r\n            TAG, "Remove " + win + " client="\r\n            + Integer.toHexString(System.identityHashCode(\r\n                win.mClient.asBinder()))\r\n            + ", surface=" + win.mSurface);\r\n\r\n        final long origId = Binder.clearCallingIdentity();\r\n        \r\n        win.disposeInputChannel();\r\n\r\n        if (DEBUG_APP_TRANSITIONS) Slog.v(\r\n                TAG, "Remove " + win + ": mSurface=" + win.mSurface\r\n                + " mExiting=" + win.mExiting\r\n                + " isAnimating=" + win.isAnimating()\r\n                + " app-animation="\r\n                + (win.mAppToken != null ? win.mAppToken.animation : null)\r\n                + " inPendingTransaction="\r\n                + (win.mAppToken != null ? win.mAppToken.inPendingTransaction : false)\r\n                + " mDisplayFrozen=" + mDisplayFrozen);\r\n        // Visibility of the removed window. Will be used later to update orientation later on.\r\n        boolean wasVisible = false;\r\n        // First, see if we need to run an animation.  If we do, we have\r\n        // to hold off on removing the window until the animation is done.\r\n        // If the display is frozen, just remove immediately, since the\r\n        // animation wouldn't be seen.\r\n        if (win.mSurface != null && !mDisplayFrozen && mDisplayEnabled && mPolicy.isScreenOn()) {\r\n            // If we are not currently running the exit animation, we\r\n            // need to see about starting one.\r\n            if (wasVisible=win.isWinVisibleLw()) {\r\n\r\n                int transit = WindowManagerPolicy.TRANSIT_EXIT;\r\n                if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {\r\n                    transit = WindowManagerPolicy.TRANSIT_PREVIEW_DONE;\r\n                }\r\n                // Try starting an animation.\r\n                if (applyAnimationLocked(win, transit, false)) {\r\n                    win.mExiting = true;\r\n                }\r\n            }\r\n            if (win.mExiting || win.isAnimating()) {\r\n                // The exit animation is running... wait for it!\r\n                //Slog.i(TAG, "*** Running exit animation...");\r\n                win.mExiting = true;\r\n                win.mRemoveOnExit = true;\r\n                mLayoutNeeded = true;\r\n                updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,\r\n                        false /*updateInputWindows*/);\r\n                performLayoutAndPlaceSurfacesLocked();\r\n                mInputMonitor.updateInputWindowsLw(false /*force*/);\r\n                if (win.mAppToken != null) {\r\n                    win.mAppToken.updateReportedVisibilityLocked();\r\n                }\r\n                //dump();\r\n                Binder.restoreCallingIdentity(origId);\r\n                return;\r\n            }\r\n        }\r\n\r\n        removeWindowInnerLocked(session, win);\r\n        // Removing a visible window will effect the computed orientation\r\n        // So just update orientation if needed.\r\n        if (wasVisible && computeForcedAppOrientationLocked()\r\n                != mForcedAppOrientation\r\n                && updateOrientationFromAppTokensLocked(false)) {\r\n            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);\r\n        }\r\n        updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/);\r\n        Binder.restoreCallingIdentity(origId);\r\n    }\r\n\r\n    private void removeWindowInnerLocked(Session session, WindowState win) {\r\n        if (win.mRemoved) {\r\n            // Nothing to do.\r\n            return;\r\n        }\r\n\r\n        for (int i=win.mChildWindows.size()-1; i>=0; i--) {\r\n            WindowState cwin = win.mChildWindows.get(i);\r\n            Slog.w(TAG, "Force-removing child win " + cwin + " from container "\r\n                    + win);\r\n            removeWindowInnerLocked(cwin.mSession, cwin);\r\n        }\r\n\r\n        win.mRemoved = true;\r\n\r\n        if (mInputMethodTarget == win) {\r\n            moveInputMethodWindowsIfNeededLocked(false);\r\n        }\r\n\r\n        if (false) {\r\n            RuntimeException e = new RuntimeException("here");\r\n            e.fillInStackTrace();\r\n            Slog.w(TAG, "Removing window " + win, e);\r\n        }\r\n\r\n        mPolicy.removeWindowLw(win);\r\n        win.removeLocked();\r\n\r\n        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "removeWindowInnerLocked: " + win);\r\n        mWindowMap.remove(win.mClient.asBinder());\r\n        mWindows.remove(win);\r\n        mPendingRemove.remove(win);\r\n        mWindowsChanged = true;\r\n        if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Final remove of window: " + win);\r\n\r\n        if (mInputMethodWindow == win) {\r\n            mInputMethodWindow = null;\r\n        } else if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {\r\n            mInputMethodDialogs.remove(win);\r\n        }\r\n\r\n        final WindowToken token = win.mToken;\r\n        final AppWindowToken atoken = win.mAppToken;\r\n        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Removing " + win + " from " + token);\r\n        token.windows.remove(win);\r\n        if (atoken != null) {\r\n            atoken.allAppWindows.remove(win);\r\n        }\r\n        if (localLOGV) Slog.v(\r\n                TAG, "**** Removing window " + win + ": count="\r\n                + token.windows.size());\r\n        if (token.windows.size() == 0) {\r\n            if (!token.explicit) {\r\n                mTokenMap.remove(token.token);\r\n            } else if (atoken != null) {\r\n                atoken.firstWindowDrawn = false;\r\n            }\r\n        }\r\n\r\n        if (atoken != null) {\r\n            if (atoken.startingWindow == win) {\r\n                atoken.startingWindow = null;\r\n            } else if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {\r\n                // If this is the last window and we had requested a starting\r\n                // transition window, well there is no point now.\r\n                atoken.startingData = null;\r\n            } else if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {\r\n                // If this is the last window except for a starting transition\r\n                // window, we need to get rid of the starting transition.\r\n                if (DEBUG_STARTING_WINDOW) {\r\n                    Slog.v(TAG, "Schedule remove starting " + token\r\n                            + ": no more real windows");\r\n                }\r\n                Message m = mH.obtainMessage(H.REMOVE_STARTING, atoken);\r\n                mH.sendMessage(m);\r\n            }\r\n        }\r\n\r\n        if (win.mAttrs.type == TYPE_WALLPAPER) {\r\n            mLastWallpaperTimeoutTime = 0;\r\n            adjustWallpaperWindowsLocked();\r\n        } else if ((win.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0) {\r\n            adjustWallpaperWindowsLocked();\r\n        }\r\n\r\n        if (!mInLayout) {\r\n            assignLayersLocked();\r\n            mLayoutNeeded = true;\r\n            performLayoutAndPlaceSurfacesLocked();\r\n            if (win.mAppToken != null) {\r\n                win.mAppToken.updateReportedVisibilityLocked();\r\n            }\r\n        }\r\n        \r\n        mInputMonitor.updateInputWindowsLw(true /*force*/);\r\n    }\r\n\r\n    static void logSurface(WindowState w, String msg, RuntimeException where) {\r\n        String str = "  SURFACE " + Integer.toHexString(w.hashCode())\r\n                + ": " + msg + " / " + w.mAttrs.getTitle();\r\n        if (where != null) {\r\n            Slog.i(TAG, str, where);\r\n        } else {\r\n            Slog.i(TAG, str);\r\n        }\r\n    }\r\n    \r\n    void setTransparentRegionWindow(Session session, IWindow client, Region region) {\r\n        long origId = Binder.clearCallingIdentity();\r\n        try {\r\n            synchronized (mWindowMap) {\r\n                WindowState w = windowForClientLocked(session, client, false);\r\n                if ((w != null) && (w.mSurface != null)) {\r\n                    if (SHOW_TRANSACTIONS) Slog.i(TAG,\r\n                            ">>> OPEN TRANSACTION setTransparentRegion");\r\n                    Surface.openTransaction();\r\n                    try {\r\n                        if (SHOW_TRANSACTIONS) logSurface(w,\r\n                                "transparentRegionHint=" + region, null);\r\n                        w.mSurface.setTransparentRegionHint(region);\r\n                    } finally {\r\n                        Surface.closeTransaction();\r\n                        if (SHOW_TRANSACTIONS) Slog.i(TAG,\r\n                                "<<< CLOSE TRANSACTION setTransparentRegion");\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            Binder.restoreCallingIdentity(origId);\r\n        }\r\n    }\r\n\r\n    void setInsetsWindow(Session session, IWindow client,\r\n            int touchableInsets, Rect contentInsets,\r\n            Rect visibleInsets, Region touchableRegion) {\r\n        long origId = Binder.clearCallingIdentity();\r\n        try {\r\n            synchronized (mWindowMap) {\r\n                WindowState w = windowForClientLocked(session, client, false);\r\n                if (w != null) {\r\n                    w.mGivenInsetsPending = false;\r\n                    w.mGivenContentInsets.set(contentInsets);\r\n                    w.mGivenVisibleInsets.set(visibleInsets);\r\n                    w.mGivenTouchableRegion.set(touchableRegion);\r\n                    w.mTouchableInsets = touchableInsets;\r\n                    if (w.mGlobalScale != 1) {\r\n                        w.mGivenContentInsets.scale(w.mGlobalScale);\r\n                        w.mGivenVisibleInsets.scale(w.mGlobalScale);\r\n                        w.mGivenTouchableRegion.scale(w.mGlobalScale);\r\n                    }\r\n                    mLayoutNeeded = true;\r\n                    performLayoutAndPlaceSurfacesLocked();\r\n                }\r\n            }\r\n        } finally {\r\n            Binder.restoreCallingIdentity(origId);\r\n        }\r\n    }\r\n\r\n    public void getWindowDisplayFrame(Session session, IWindow client,\r\n            Rect outDisplayFrame) {\r\n        synchronized(mWindowMap) {\r\n            WindowState win = windowForClientLocked(session, client, false);\r\n            if (win == null) {\r\n                outDisplayFrame.setEmpty();\r\n                return;\r\n            }\r\n            outDisplayFrame.set(win.mDisplayFrame);\r\n        }\r\n    }\r\n\r\n    public void setWindowWallpaperPositionLocked(WindowState window, float x, float y,\r\n            float xStep, float yStep) {\r\n        if (window.mWallpaperX != x || window.mWallpaperY != y)  {\r\n            window.mWallpaperX = x;\r\n            window.mWallpaperY = y;\r\n            window.mWallpaperXStep = xStep;\r\n            window.mWallpaperYStep = yStep;\r\n            if (updateWallpaperOffsetLocked(window, true)) {\r\n                performLayoutAndPlaceSurfacesLocked();\r\n            }\r\n        }\r\n    }\r\n\r\n    void wallpaperCommandComplete(IBinder window, Bundle result) {\r\n        synchronized (mWindowMap) {\r\n            if (mWaitingOnWallpaper != null &&\r\n                    mWaitingOnWallpaper.mClient.asBinder() == window) {\r\n                mWaitingOnWallpaper = null;\r\n                mWindowMap.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    public Bundle sendWindowWallpaperCommandLocked(WindowState window,\r\n            String action, int x, int y, int z, Bundle extras, boolean sync) {\r\n        if (window == mWallpaperTarget || window == mLowerWallpaperTarget\r\n                || window == mUpperWallpaperTarget) {\r\n            boolean doWait = sync;\r\n            int curTokenIndex = mWallpaperTokens.size();\r\n            while (curTokenIndex > 0) {\r\n                curTokenIndex--;\r\n                WindowToken token = mWallpaperTokens.get(curTokenIndex);\r\n                int curWallpaperIndex = token.windows.size();\r\n                while (curWallpaperIndex > 0) {\r\n                    curWallpaperIndex--;\r\n                    WindowState wallpaper = token.windows.get(curWallpaperIndex);\r\n                    try {\r\n                        wallpaper.mClient.dispatchWallpaperCommand(action,\r\n                                x, y, z, extras, sync);\r\n                        // We only want to be synchronous with one wallpaper.\r\n                        sync = false;\r\n                    } catch (RemoteException e) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (doWait) {\r\n                // XXX Need to wait for result.\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public int relayoutWindow(Session session, IWindow client,\r\n            WindowManager.LayoutParams attrs, int requestedWidth,\r\n            int requestedHeight, int viewVisibility, boolean insetsPending,\r\n            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,\r\n            Configuration outConfig, Surface outSurface) {\r\n        boolean displayed = false;\r\n        boolean inTouchMode;\r\n        boolean configChanged;\r\n\r\n        // if they don't have this permission, mask out the status bar bits\r\n        if (attrs != null) {\r\n            if (((attrs.systemUiVisibility|attrs.subtreeSystemUiVisibility)\r\n                    & StatusBarManager.DISABLE_MASK) != 0) {\r\n                if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)\r\n                        != PackageManager.PERMISSION_GRANTED) {\r\n                    attrs.systemUiVisibility &= ~StatusBarManager.DISABLE_MASK;\r\n                    attrs.subtreeSystemUiVisibility &= ~StatusBarManager.DISABLE_MASK;\r\n                }\r\n            }\r\n        }\r\n        long origId = Binder.clearCallingIdentity();\r\n\r\n        synchronized(mWindowMap) {\r\n            WindowState win = windowForClientLocked(session, client, false);\r\n            if (win == null) {\r\n                return 0;\r\n            }\r\n            win.mRequestedWidth = requestedWidth;\r\n            win.mRequestedHeight = requestedHeight;\r\n\r\n            if (attrs != null) {\r\n                mPolicy.adjustWindowParamsLw(attrs);\r\n            }\r\n\r\n            int attrChanges = 0;\r\n            int flagChanges = 0;\r\n            if (attrs != null) {\r\n                flagChanges = win.mAttrs.flags ^= attrs.flags;\r\n                attrChanges = win.mAttrs.copyFrom(attrs);\r\n            }\r\n\r\n            if (DEBUG_LAYOUT) Slog.v(TAG, "Relayout " + win + ": " + win.mAttrs);\r\n\r\n            win.mEnforceSizeCompat = (win.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0;\r\n\r\n            if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {\r\n                win.mAlpha = attrs.alpha;\r\n            }\r\n\r\n            final boolean scaledWindow =\r\n                ((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);\r\n\r\n            if (scaledWindow) {\r\n                // requested{Width|Height} Surface's physical size\r\n                // attrs.{width|height} Size on screen\r\n                win.mHScale = (attrs.width  != requestedWidth)  ?\r\n                        (attrs.width  / (float)requestedWidth) : 1.0f;\r\n                win.mVScale = (attrs.height != requestedHeight) ?\r\n                        (attrs.height / (float)requestedHeight) : 1.0f;\r\n            } else {\r\n                win.mHScale = win.mVScale = 1;\r\n            }\r\n\r\n            boolean imMayMove = (flagChanges&(\r\n                    WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM |\r\n                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;\r\n\r\n            boolean focusMayChange = win.mViewVisibility != viewVisibility\r\n                    || ((flagChanges&WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0)\r\n                    || (!win.mRelayoutCalled);\r\n\r\n            boolean wallpaperMayMove = win.mViewVisibility != viewVisibility\r\n                    && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;\r\n\r\n            win.mRelayoutCalled = true;\r\n            final int oldVisibility = win.mViewVisibility;\r\n            win.mViewVisibility = viewVisibility;\r\n            if (DEBUG_SCREEN_ON) {\r\n                RuntimeException stack = new RuntimeException();\r\n                stack.fillInStackTrace();\r\n                Slog.i(TAG, "Relayout " + win + ": oldVis=" + oldVisibility\r\n                        + " newVis=" + viewVisibility, stack);\r\n            }\r\n            if (viewVisibility == View.VISIBLE &&\r\n                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {\r\n                displayed = !win.isVisibleLw();\r\n                if (win.mExiting) {\r\n                    win.mExiting = false;\r\n                    if (win.mAnimation != null) {\r\n                        win.mAnimation.cancel();\r\n                        win.mAnimation = null;\r\n                    }\r\n                }\r\n                if (win.mDestroying) {\r\n                    win.mDestroying = false;\r\n                    mDestroySurface.remove(win);\r\n                }\r\n                if (oldVisibility == View.GONE) {\r\n                    win.mEnterAnimationPending = true;\r\n                }\r\n                if (displayed) {\r\n                    if (win.mSurface != null && !win.mDrawPending\r\n                            && !win.mCommitDrawPending && !mDisplayFrozen\r\n                            && mDisplayEnabled && mPolicy.isScreenOn()) {\r\n                        applyEnterAnimationLocked(win);\r\n                    }\r\n                    if ((win.mAttrs.flags\r\n                            & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {\r\n                        if (DEBUG_VISIBILITY) Slog.v(TAG,\r\n                                "Relayout window turning screen on: " + win);\r\n                        win.mTurnOnScreen = true;\r\n                    }\r\n                    int diff = 0;\r\n                    if (win.mConfiguration != mCurConfiguration\r\n                            && (win.mConfiguration == null\r\n                                    || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0)) {\r\n                        win.mConfiguration = mCurConfiguration;\r\n                        if (DEBUG_CONFIGURATION) {\r\n                            Slog.i(TAG, "Window " + win + " visible with new config: "\r\n                                    + win.mConfiguration + " / 0x"\r\n                                    + Integer.toHexString(diff));\r\n                        }\r\n                        outConfig.setTo(mCurConfiguration);\r\n                    }\r\n                }\r\n                if ((attrChanges&WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {\r\n                    // To change the format, we need to re-build the surface.\r\n                    win.destroySurfaceLocked();\r\n                    displayed = true;\r\n                }\r\n                try {\r\n                    Surface surface = win.createSurfaceLocked();\r\n                    if (surface != null) {\r\n                        outSurface.copyFrom(surface);\r\n                        win.mReportDestroySurface = false;\r\n                        win.mSurfacePendingDestroy = false;\r\n                        if (SHOW_TRANSACTIONS) Slog.i(TAG,\r\n                                "  OUT SURFACE " + outSurface + ": copied");\r\n                    } else {\r\n                        // For some reason there isn't a surface.  Clear the\r\n                        // caller's object so they see the same state.\r\n                        outSurface.release();\r\n                    }\r\n                } catch (Exception e) {\r\n                    mInputMonitor.updateInputWindowsLw(true /*force*/);\r\n                    \r\n                    Slog.w(TAG, "Exception thrown when creating surface for client "\r\n                             + client + " (" + win.mAttrs.getTitle() + ")",\r\n                             e);\r\n                    Binder.restoreCallingIdentity(origId);\r\n                    return 0;\r\n                }\r\n                if (displayed) {\r\n                    focusMayChange = true;\r\n                }\r\n                if (win.mAttrs.type == TYPE_INPUT_METHOD\r\n                        && mInputMethodWindow == null) {\r\n                    mInputMethodWindow = win;\r\n                    imMayMove = true;\r\n                }\r\n                if (win.mAttrs.type == TYPE_BASE_APPLICATION\r\n                        && win.mAppToken != null\r\n                        && win.mAppToken.startingWindow != null) {\r\n                    // Special handling of starting window over the base\r\n                    // window of the app: propagate lock screen flags to it,\r\n                    // to provide the correct semantics while starting.\r\n                    final int mask =\r\n                        WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED\r\n                        | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD\r\n                        | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;\r\n                    WindowManager.LayoutParams sa = win.mAppToken.startingWindow.mAttrs;\r\n                    sa.flags = (sa.flags&~mask) | (win.mAttrs.flags&mask);\r\n                }\r\n            } else {\r\n                win.mEnterAnimationPending = false;\r\n                if (win.mSurface != null) {\r\n                    if (DEBUG_VISIBILITY) Slog.i(TAG, "Relayout invis " + win\r\n                            + ": mExiting=" + win.mExiting\r\n                            + " mSurfacePendingDestroy=" + win.mSurfacePendingDestroy);\r\n                    // If we are not currently running the exit animation, we\r\n                    // need to see about starting one.\r\n                    if (!win.mExiting || win.mSurfacePendingDestroy) {\r\n                        // Try starting an animation; if there isn't one, we\r\n                        // can destroy the surface right away.\r\n                        int transit = WindowManagerPolicy.TRANSIT_EXIT;\r\n                        if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {\r\n                            transit = WindowManagerPolicy.TRANSIT_PREVIEW_DONE;\r\n                        }\r\n                        if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() &&\r\n                              applyAnimationLocked(win, transit, false)) {\r\n                            focusMayChange = true;\r\n                            win.mExiting = true;\r\n                        } else if (win.isAnimating()) {\r\n                            // Currently in a hide animation... turn this into\r\n                            // an exit.\r\n                            win.mExiting = true;\r\n                        } else if (win == mWallpaperTarget) {\r\n                            // If the wallpaper is currently behind this\r\n                            // window, we need to change both of them inside\r\n                            // of a transaction to avoid artifacts.\r\n                            win.mExiting = true;\r\n                            win.mAnimating = true;\r\n                        } else {\r\n                            if (mInputMethodWindow == win) {\r\n                                mInputMethodWindow = null;\r\n                            }\r\n                            win.destroySurfaceLocked();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (win.mSurface == null || (win.getAttrs().flags\r\n                        & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0\r\n                        || win.mSurfacePendingDestroy) {\r\n                    // We are being called from a local process, which\r\n                    // means outSurface holds its current surface.  Ensure the\r\n                    // surface object is cleared, but we don't want it actually\r\n                    // destroyed at this point.\r\n                    win.mSurfacePendingDestroy = false;\r\n                    outSurface.release();\r\n                    if (DEBUG_VISIBILITY) Slog.i(TAG, "Releasing surface in: " + win);\r\n                } else if (win.mSurface != null) {\r\n                    if (DEBUG_VISIBILITY) Slog.i(TAG,\r\n                            "Keeping surface, will report destroy: " + win);\r\n                    win.mReportDestroySurface = true;\r\n                    outSurface.copyFrom(win.mSurface);\r\n                }\r\n            }\r\n\r\n            if (focusMayChange) {\r\n                //System.out.println("Focus may change: " + win.mAttrs.getTitle());\r\n                if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,\r\n                        false /*updateInputWindows*/)) {\r\n                    imMayMove = false;\r\n                }\r\n                //System.out.println("Relayout " + win + ": focus=" + mCurrentFocus);\r\n            }\r\n\r\n            // updateFocusedWindowLocked() already assigned layers so we only need to\r\n            // reassign them at this point if the IM window state gets shuffled\r\n            boolean assignLayers = false;\r\n\r\n            if (imMayMove) {\r\n                if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {\r\n                    // Little hack here -- we -should- be able to rely on the\r\n                    // function to return true if the IME has moved and needs\r\n                    // its layer recomputed.  However, if the IME was hidden\r\n                    // and isn't actually moved in the list, its layer may be\r\n                    // out of data so we make sure to recompute it.\r\n                    assignLayers = true;\r\n                }\r\n            }\r\n            if (wallpaperMayMove) {\r\n                if ((adjustWallpaperWindowsLocked()&ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {\r\n                    assignLayers = true;\r\n                }\r\n            }\r\n\r\n            mLayoutNeeded = true;\r\n            win.mGivenInsetsPending = insetsPending;\r\n            if (assignLayers) {\r\n                assignLayersLocked();\r\n            }\r\n            configChanged = updateOrientationFromAppTokensLocked(false);\r\n            performLayoutAndPlaceSurfacesLocked();\r\n            if (displayed && win.mIsWallpaper) {\r\n                updateWallpaperOffsetLocked(win, mAppDisplayWidth, mAppDisplayHeight, false);\r\n            }\r\n            if (win.mAppToken != null) {\r\n                win.mAppToken.updateReportedVisibilityLocked();\r\n            }\r\n            outFrame.set(win.mCompatFrame);\r\n            outContentInsets.set(win.mContentInsets);\r\n            outVisibleInsets.set(win.mVisibleInsets);\r\n            if (localLOGV) Slog.v(\r\n                TAG, "Relayout given client " + client.asBinder()\r\n                + ", requestedWidth=" + requestedWidth\r\n                + ", requestedHeight=" + requestedHeight\r\n                + ", viewVisibility=" + viewVisibility\r\n                + "\\nRelayout returning frame=" + outFrame\r\n                + ", surface=" + outSurface);\r\n\r\n            if (localLOGV || DEBUG_FOCUS) Slog.v(\r\n                TAG, "Relayout of " + win + ": focusMayChange=" + focusMayChange);\r\n\r\n            inTouchMode = mInTouchMode;\r\n            \r\n            mInputMonitor.updateInputWindowsLw(true /*force*/);\r\n        }\r\n\r\n        if (configChanged) {\r\n            sendNewConfiguration();\r\n        }\r\n\r\n        Binder.restoreCallingIdentity(origId);\r\n\r\n        return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0)\r\n                | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);\r\n    }\r\n\r\n    public boolean outOfMemoryWindow(Session session, IWindow client) {\r\n        long origId = Binder.clearCallingIdentity();\r\n\r\n        try {\r\n            synchronized(mWindowMap) {\r\n                WindowState win = windowForClientLocked(session, client, false);\r\n                if (win == null) {\r\n                    return false;\r\n                }\r\n                return reclaimSomeSurfaceMemoryLocked(win, "from-client", false);\r\n            }\r\n        } finally {\r\n            Binder.restoreCallingIdentity(origId);\r\n        }\r\n    }\r\n\r\n    public void finishDrawingWindow(Session session, IWindow client) {\r\n        final long origId = Binder.clearCallingIdentity();\r\n        synchronized(mWindowMap) {\r\n            WindowState win = windowForClientLocked(session, client, false);\r\n            if (win != null && win.finishDrawingLocked()) {\r\n                if ((win.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0) {\r\n                    adjustWallpaperWindowsLocked();\r\n                }\r\n                mLayoutNeeded = true;\r\n                performLayoutAndPlaceSurfacesLocked();\r\n            }\r\n        }\r\n        Binder.restoreCallingIdentity(origId);\r\n    }\r\n\r\n    public float getWindowCompatibilityScale(IBinder windowToken) {\r\n        synchronized (mWindowMap) {\r\n            WindowState windowState = mWindowMap.get(windowToken);\r\n            return (windowState != null) ? windowState.mGlobalScale : 1.0f;\r\n        }\r\n    }\r\n\r\n    private AttributeCache.Entry getCachedAnimations(WindowManager.LayoutParams lp) {\r\n        if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: layout params pkg="\r\n                + (lp != null ? lp.packageName : null)\r\n                + " resId=0x" + (lp != null ? Integer.toHexString(lp.windowAnimations) : null));\r\n        if (lp != null && lp.windowAnimations != 0) {\r\n            // If this is a system resource, don't try to load it from the\r\n            // application resources.  It is nice to avoid loading application\r\n            // resources if we can.\r\n            String packageName = lp.packageName != null ? lp.packageName : "android";\r\n            int resId = lp.windowAnimations;\r\n            if ((resId&0xFF000000) == 0x01000000) {\r\n                packageName = "android";\r\n            }\r\n            if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: picked package="\r\n                    + packageName);\r\n            return AttributeCache.instance().get(packageName, resId,\r\n                    com.android.internal.R.styleable.WindowAnimation);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private AttributeCache.Entry getCachedAnimations(String packageName, int resId) {\r\n        if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: package="\r\n                + packageName + " resId=0x" + Integer.toHexString(resId));\r\n        if (packageName != null) {\r\n            if ((resId&0xFF000000) == 0x01000000) {\r\n                packageName = "android";\r\n            }\r\n            if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: picked package="\r\n                    + packageName);\r\n            return AttributeCache.instance().get(packageName, resId,\r\n                    com.android.internal.R.styleable.WindowAnimation);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    void applyEnterAnimationLocked(WindowState win) {\r\n        int transit = WindowManagerPolicy.TRANSIT_SHOW;\r\n        if (win.mEnterAnimationPending) {\r\n            win.mEnterAnimationPending = false;\r\n            transit = WindowManagerPolicy.TRANSIT_ENTER;\r\n        }\r\n\r\n        applyAnimationLocked(win, transit, true);\r\n    }\r\n}	Divergent Change	God Class\n	Long Method\n	Feature Envy\n	WindowManagerService.java\n	9aa0a177fe1900bc8c86e3295a20f74c	\N	Oocorre quando uma classe é alterada de maneiras diferentes por diferentes razões.	WMC (Weighted Method per Class), NCC (Number Concerns per Component), LCOM (Lack of Cohesion in Methods)	Refatoração sugerida: Extract Class	t	3
47	Identifique o Bad Smell na classe abaixo	/*\n * Copyright  2000-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant.taskdefs.optional;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport java.util.Vector;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.ExecTask;\nimport org.apache.tools.ant.taskdefs.Execute;\nimport org.apache.tools.ant.taskdefs.LogOutputStream;\nimport org.apache.tools.ant.taskdefs.MatchingTask;\nimport org.apache.tools.ant.taskdefs.StreamPumper;\nimport org.apache.tools.ant.taskdefs.condition.Os;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.util.FileUtils;\n\n\n/**\n * Create a CAB archive.\n *\n */\n\npublic class Cab extends MatchingTask {\n\n    private File cabFile;\n    private File baseDir;\n    private Vector filesets = new Vector();\n    private boolean doCompress = true;\n    private boolean doVerbose = false;\n    private String cmdOptions;\n\n    protected String archiveType = "cab";\n\n    private FileUtils fileUtils = FileUtils.newFileUtils();\n\n    /**\n     * The name/location of where to create the .cab file.\n     */\n    public void setCabfile(File cabFile) {\n        this.cabFile = cabFile;\n    }\n\n    /**\n     * Base directory to look in for files to CAB.\n     */\n    public void setBasedir(File baseDir) {\n        this.baseDir = baseDir;\n    }\n\n    /**\n     * If true, compress the files otherwise only store them.\n     */\n    public void setCompress(boolean compress) {\n        doCompress = compress;\n    }\n\n    /**\n     * If true, display cabarc output.\n     */\n    public void setVerbose(boolean verbose) {\n        doVerbose = verbose;\n    }\n\n    /**\n     * Sets additional cabarc options that are not supported directly.\n     */\n    public void setOptions(String options) {\n        cmdOptions = options;\n    }\n\n    /**\n     * Adds a set of files to archive.\n     */\n    public void addFileset(FileSet set) {\n        filesets.addElement(set);\n    }\n\n    /*\n     * I'm not fond of this pattern: "sub-method expected to throw\n     * task-cancelling exceptions".  It feels too much like programming\n     * for side-effects to me...\n     */\n    protected void checkConfiguration() throws BuildException {\n        if (baseDir == null && filesets.size() == 0) {\n            throw new BuildException("basedir attribute or at least one "\n                                     + "nested filest is required!",\n                                     getLocation());\n        }\n        if (baseDir != null && !baseDir.exists()) {\n            throw new BuildException("basedir does not exist!", getLocation());\n        }\n        if (cabFile == null) {\n            throw new BuildException("cabfile attribute must be set!",\n                                     getLocation());\n        }\n    }\n\n    /**\n     * Create a new exec delegate.  The delegate task is populated so that\n     * it appears in the logs to be the same task as this one.\n     */\n    protected ExecTask createExec() throws BuildException {\n        ExecTask exec = (ExecTask) getProject().createTask("exec");\n        exec.setOwningTarget(this.getOwningTarget());\n        exec.setTaskName(this.getTaskName());\n        exec.setDescription(this.getDescription());\n\n        return exec;\n    }\n\n    /**\n     * Check to see if the target is up to date with respect to input files.\n     * @return true if the cab file is newer than its dependents.\n     */\n    protected boolean isUpToDate(Vector files) {\n        boolean upToDate = true;\n        for (int i = 0; i < files.size() && upToDate; i++) {\n            String file = files.elementAt(i).toString();\n            if (fileUtils.resolveFile(baseDir, file).lastModified()\n                    > cabFile.lastModified()) {\n                upToDate = false;\n            }\n        }\n        return upToDate;\n    }\n\n    /**\n     * Creates a list file.  This temporary file contains a list of all files\n     * to be included in the cab, one file per line.\n     */\n    protected File createListFile(Vector files)\n        throws IOException {\n        File listFile = fileUtils.createTempFile("ant", "", null);\n        listFile.deleteOnExit();\n\n        PrintWriter writer = new PrintWriter(new FileOutputStream(listFile));\n\n        for (int i = 0; i < files.size(); i++) {\n            writer.println(files.elementAt(i).toString());\n        }\n        writer.close();\n\n        return listFile;\n    }\n\n    /**\n     * Append all files found by a directory scanner to a vector.\n     */\n    protected void appendFiles(Vector files, DirectoryScanner ds) {\n        String[] dsfiles = ds.getIncludedFiles();\n\n        for (int i = 0; i < dsfiles.length; i++) {\n            files.addElement(dsfiles[i]);\n        }\n    }\n\n    /**\n     * Get the complete list of files to be included in the cab.  Filenames\n     * are gathered from filesets if any have been added, otherwise from the\n     * traditional include parameters.\n     */\n    protected Vector getFileList() throws BuildException {\n        Vector files = new Vector();\n\n        if (baseDir != null) {\n            // get files from old methods - includes and nested include\n            appendFiles(files, super.getDirectoryScanner(baseDir));\n        }\n\n        // get files from filesets\n        for (int i = 0; i < filesets.size(); i++) {\n            FileSet fs = (FileSet) filesets.elementAt(i);\n            if (fs != null) {\n                appendFiles(files, fs.getDirectoryScanner(getProject()));\n            }\n        }\n\n        return files;\n    }\n\n    public void execute() throws BuildException {\n\n        checkConfiguration();\n\n        Vector files = getFileList();\n\n        // quick exit if the target is up to date\n        if (isUpToDate(files)) {\n            return;\n        }\n\n        log("Building " + archiveType + ": " + cabFile.getAbsolutePath());\n\n        if (!Os.isFamily("windows")) {\n            log("Using listcab/libcabinet", Project.MSG_VERBOSE);\n\n            StringBuffer sb = new StringBuffer();\n\n            Enumeration fileEnum = files.elements();\n\n            while (fileEnum.hasMoreElements()) {\n                sb.append(fileEnum.nextElement()).append("\\n");\n            }\n            sb.append("\\n").append(cabFile.getAbsolutePath()).append("\\n");\n\n            try {\n                Process p = Execute.launch(getProject(),\n                                           new String[] {"listcab"}, null,\n                                           baseDir != null ? baseDir\n                                                   : getProject().getBaseDir(),\n                                           true);\n                OutputStream out = p.getOutputStream();\n\n                // Create the stream pumpers to forward listcab's stdout and stderr to the log\n                // note: listcab is an interactive program, and issues prompts for every new line.\n                //       Therefore, make it show only with verbose logging turned on.\n                LogOutputStream outLog = new LogOutputStream(this, Project.MSG_VERBOSE);\n                LogOutputStream errLog = new LogOutputStream(this, Project.MSG_ERR);\n                StreamPumper    outPump = new StreamPumper(p.getInputStream(), outLog);\n                StreamPumper    errPump = new StreamPumper(p.getErrorStream(), errLog);\n\n                // Pump streams asynchronously\n                (new Thread(outPump)).start();\n                (new Thread(errPump)).start();\n\n                out.write(sb.toString().getBytes());\n                out.flush();\n                out.close();\n\n                int result = -99; // A wild default for when the thread is interrupted\n\n                try {\n                    // Wait for the process to finish\n                    result = p.waitFor();\n\n                    // Wait for the end of output and error streams\n                    outPump.waitFor();\n                    outLog.close();\n                    errPump.waitFor();\n                    errLog.close();\n                } catch (InterruptedException ie) {\n                    log("Thread interrupted: " + ie);\n                }\n\n                // Informative summary message in case of errors\n                if (Execute.isFailure(result)) {\n                    log("Error executing listcab; error code: " + result);\n                }\n            } catch (IOException ex) {\n                String msg = "Problem creating " + cabFile + " " + ex.getMessage();\n                throw new BuildException(msg, getLocation());\n            }\n        } else {\n            try {\n                File listFile = createListFile(files);\n                ExecTask exec = createExec();\n                File outFile = null;\n\n                // die if cabarc fails\n                exec.setFailonerror(true);\n                exec.setDir(baseDir);\n\n                if (!doVerbose) {\n                    outFile = fileUtils.createTempFile("ant", "", null);\n                    outFile.deleteOnExit();\n                    exec.setOutput(outFile);\n                }\n\n                exec.setExecutable("cabarc");\n                exec.createArg().setValue("-r");\n                exec.createArg().setValue("-p");\n\n                if (!doCompress) {\n                    exec.createArg().setValue("-m");\n                    exec.createArg().setValue("none");\n                }\n\n                if (cmdOptions != null) {\n                    exec.createArg().setLine(cmdOptions);\n                }\n\n                exec.createArg().setValue("n");\n                exec.createArg().setFile(cabFile);\n                exec.createArg().setValue("@" + listFile.getAbsolutePath());\n\n                exec.execute();\n\n                if (outFile != null) {\n                    outFile.delete();\n                }\n\n                listFile.delete();\n            } catch (IOException ioe) {\n                String msg = "Problem creating " + cabFile + " " + ioe.getMessage();\n                throw new BuildException(msg, getLocation());\n            }\n        }\n    }\n}	Long Method	Divergent Change\n	Shotgun Surgery\n	Feature Envy\n	Cab.java\n	19d9e603f8694c4764c33bce53be5b0c	\N	Quando métodos que centralizam a funcionalidade da classe	LOC (Lines of Code), NCO (Number Concerns per Operations), NCC (Number Concerns per Component)	Refatoração sugerida:  Replace Method with Method Object	t	3
49	Identifique o Bad Smell na classe abaixo	/*\n * Copyright  2001-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n/*\n * This package is based on the work done by Keiron Liddle, Aftex Software\n * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n * great code.\n */\npackage org.apache.tools.bzip2;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * An input stream that decompresses from the BZip2 format (without the file\n * header chars) to be read as any other stream.\n *\n */\npublic class CBZip2InputStream extends InputStream implements BZip2Constants {\n    private static void cadvise() {\n        System.out.println("CRC Error");\n        //throw new CCoruptionError();\n    }\n\n    private static void badBGLengths() {\n        cadvise();\n    }\n\n    private static void bitStreamEOF() {\n        cadvise();\n    }\n\n    private static void compressedStreamEOF() {\n        cadvise();\n    }\n\n    private void makeMaps() {\n        int i;\n        nInUse = 0;\n        for (i = 0; i < 256; i++) {\n            if (inUse[i]) {\n                seqToUnseq[nInUse] = (char) i;\n                unseqToSeq[i] = (char) nInUse;\n                nInUse++;\n            }\n        }\n    }\n\n    /*\n      index of the last char in the block, so\n      the block size == last + 1.\n    */\n    private int  last;\n\n    /*\n      index in zptr[] of original string after sorting.\n    */\n    private int  origPtr;\n\n    /*\n      always: in the range 0 .. 9.\n      The current block size is 100000 * this number.\n    */\n    private int blockSize100k;\n\n    private boolean blockRandomised;\n\n    private int bsBuff;\n    private int bsLive;\n    private CRC mCrc = new CRC();\n\n    private boolean[] inUse = new boolean[256];\n    private int nInUse;\n\n    private char[] seqToUnseq = new char[256];\n    private char[] unseqToSeq = new char[256];\n\n    private char[] selector = new char[MAX_SELECTORS];\n    private char[] selectorMtf = new char[MAX_SELECTORS];\n\n    private int[] tt;\n    private char[] ll8;\n\n    /*\n      freq table collected to save a pass over the data\n      during decompression.\n    */\n    private int[] unzftab = new int[256];\n\n    private int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE];\n    private int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE];\n    private int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE];\n    private int[] minLens = new int[N_GROUPS];\n\n    private InputStream bsStream;\n\n    private boolean streamEnd = false;\n\n    private int currentChar = -1;\n\n    private static final int START_BLOCK_STATE = 1;\n    private static final int RAND_PART_A_STATE = 2;\n    private static final int RAND_PART_B_STATE = 3;\n    private static final int RAND_PART_C_STATE = 4;\n    private static final int NO_RAND_PART_A_STATE = 5;\n    private static final int NO_RAND_PART_B_STATE = 6;\n    private static final int NO_RAND_PART_C_STATE = 7;\n\n    private int currentState = START_BLOCK_STATE;\n\n    private int storedBlockCRC, storedCombinedCRC;\n    private int computedBlockCRC, computedCombinedCRC;\n\n    int i2, count, chPrev, ch2;\n    int i, tPos;\n    int rNToGo = 0;\n    int rTPos  = 0;\n    int j2;\n    char z;\n\n    public CBZip2InputStream(InputStream zStream) {\n        ll8 = null;\n        tt = null;\n        bsSetStream(zStream);\n        initialize();\n        initBlock();\n        setupBlock();\n    }\n\n    public int read() {\n        if (streamEnd) {\n            return -1;\n        } else {\n            int retChar = currentChar;\n            switch(currentState) {\n            case START_BLOCK_STATE:\n                break;\n            case RAND_PART_A_STATE:\n                break;\n            case RAND_PART_B_STATE:\n                setupRandPartB();\n                break;\n            case RAND_PART_C_STATE:\n                setupRandPartC();\n                break;\n            case NO_RAND_PART_A_STATE:\n                break;\n            case NO_RAND_PART_B_STATE:\n                setupNoRandPartB();\n                break;\n            case NO_RAND_PART_C_STATE:\n                setupNoRandPartC();\n                break;\n            default:\n                break;\n            }\n            return retChar;\n        }\n    }\n\n    private void initialize() {\n        char magic3, magic4;\n        magic3 = bsGetUChar();\n        magic4 = bsGetUChar();\n        if (magic3 != 'h' || magic4 < '1' || magic4 > '9') {\n            bsFinishedWithStream();\n            streamEnd = true;\n            return;\n        }\n\n        setDecompressStructureSizes(magic4 - '0');\n        computedCombinedCRC = 0;\n    }\n\n    private void initBlock() {\n        char magic1, magic2, magic3, magic4;\n        char magic5, magic6;\n        magic1 = bsGetUChar();\n        magic2 = bsGetUChar();\n        magic3 = bsGetUChar();\n        magic4 = bsGetUChar();\n        magic5 = bsGetUChar();\n        magic6 = bsGetUChar();\n        if (magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45\n            && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90) {\n            complete();\n            return;\n        }\n\n        if (magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59\n            || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59) {\n            badBlockHeader();\n            streamEnd = true;\n            return;\n        }\n\n        storedBlockCRC = bsGetInt32();\n\n        if (bsR(1) == 1) {\n            blockRandomised = true;\n        } else {\n            blockRandomised = false;\n        }\n\n        //        currBlockNo++;\n        getAndMoveToFrontDecode();\n\n        mCrc.initialiseCRC();\n        currentState = START_BLOCK_STATE;\n    }\n\n    private void endBlock() {\n        computedBlockCRC = mCrc.getFinalCRC();\n        /* A bad CRC is considered a fatal error. */\n        if (storedBlockCRC != computedBlockCRC) {\n            crcError();\n        }\n\n        computedCombinedCRC = (computedCombinedCRC << 1)\n            | (computedCombinedCRC >>> 31);\n        computedCombinedCRC ^= computedBlockCRC;\n    }\n\n    private void complete() {\n        storedCombinedCRC = bsGetInt32();\n        if (storedCombinedCRC != computedCombinedCRC) {\n            crcError();\n        }\n\n        bsFinishedWithStream();\n        streamEnd = true;\n    }\n\n    private static void blockOverrun() {\n        cadvise();\n    }\n\n    private static void badBlockHeader() {\n        cadvise();\n    }\n\n    private static void crcError() {\n        cadvise();\n    }\n\n    private void bsFinishedWithStream() {\n        try {\n            if (this.bsStream != null) {\n                if (this.bsStream != System.in) {\n                    this.bsStream.close();\n                    this.bsStream = null;\n                }\n            }\n        } catch (IOException ioe) {\n            //ignore\n        }\n    }\n\n    private void bsSetStream(InputStream f) {\n        bsStream = f;\n        bsLive = 0;\n        bsBuff = 0;\n    }\n\n    private int bsR(int n) {\n        int v;\n        while (bsLive < n) {\n            int zzi;\n            char thech = 0;\n            try {\n                thech = (char) bsStream.read();\n            } catch (IOException e) {\n                compressedStreamEOF();\n            }\n            if (thech == -1) {\n                compressedStreamEOF();\n            }\n            zzi = thech;\n            bsBuff = (bsBuff << 8) | (zzi & 0xff);\n            bsLive += 8;\n        }\n\n        v = (bsBuff >> (bsLive - n)) & ((1 << n) - 1);\n        bsLive -= n;\n        return v;\n    }\n\n    private char bsGetUChar() {\n        return (char) bsR(8);\n    }\n\n    private int bsGetint() {\n        int u = 0;\n        u = (u << 8) | bsR(8);\n        u = (u << 8) | bsR(8);\n        u = (u << 8) | bsR(8);\n        u = (u << 8) | bsR(8);\n        return u;\n    }\n\n    private int bsGetIntVS(int numBits) {\n        return (int) bsR(numBits);\n    }\n\n    private int bsGetInt32() {\n        return (int) bsGetint();\n    }\n\n    private void hbCreateDecodeTables(int[] limit, int[] base,\n                                      int[] perm, char[] length,\n                                      int minLen, int maxLen, int alphaSize) {\n        int pp, i, j, vec;\n\n        pp = 0;\n        for (i = minLen; i <= maxLen; i++) {\n            for (j = 0; j < alphaSize; j++) {\n                if (length[j] == i) {\n                    perm[pp] = j;\n                    pp++;\n                }\n            }\n        }\n\n        for (i = 0; i < MAX_CODE_LEN; i++) {\n            base[i] = 0;\n        }\n        for (i = 0; i < alphaSize; i++) {\n            base[length[i] + 1]++;\n        }\n\n        for (i = 1; i < MAX_CODE_LEN; i++) {\n            base[i] += base[i - 1];\n        }\n\n        for (i = 0; i < MAX_CODE_LEN; i++) {\n            limit[i] = 0;\n        }\n        vec = 0;\n\n        for (i = minLen; i <= maxLen; i++) {\n            vec += (base[i + 1] - base[i]);\n            limit[i] = vec - 1;\n            vec <<= 1;\n        }\n        for (i = minLen + 1; i <= maxLen; i++) {\n            base[i] = ((limit[i - 1] + 1) << 1) - base[i];\n        }\n    }\n\n    private void recvDecodingTables() {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n        int i, j, t, nGroups, nSelectors, alphaSize;\n        int minLen, maxLen;\n        boolean[] inUse16 = new boolean[16];\n\n        /* Receive the mapping table */\n        for (i = 0; i < 16; i++) {\n            if (bsR(1) == 1) {\n                inUse16[i] = true;\n            } else {\n                inUse16[i] = false;\n            }\n        }\n\n        for (i = 0; i < 256; i++) {\n            inUse[i] = false;\n        }\n\n        for (i = 0; i < 16; i++) {\n            if (inUse16[i]) {\n                for (j = 0; j < 16; j++) {\n                    if (bsR(1) == 1) {\n                        inUse[i * 16 + j] = true;\n                    }\n                }\n            }\n        }\n\n        makeMaps();\n        alphaSize = nInUse + 2;\n\n        /* Now the selectors */\n        nGroups = bsR(3);\n        nSelectors = bsR(15);\n        for (i = 0; i < nSelectors; i++) {\n            j = 0;\n            while (bsR(1) == 1) {\n                j++;\n            }\n            selectorMtf[i] = (char) j;\n        }\n\n        /* Undo the MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char tmp, v;\n            for (v = 0; v < nGroups; v++) {\n                pos[v] = v;\n            }\n\n            for (i = 0; i < nSelectors; i++) {\n                v = selectorMtf[i];\n                tmp = pos[v];\n                while (v > 0) {\n                    pos[v] = pos[v - 1];\n                    v--;\n                }\n                pos[0] = tmp;\n                selector[i] = tmp;\n            }\n        }\n\n        /* Now the coding tables */\n        for (t = 0; t < nGroups; t++) {\n            int curr = bsR(5);\n            for (i = 0; i < alphaSize; i++) {\n                while (bsR(1) == 1) {\n                    if (bsR(1) == 0) {\n                        curr++;\n                    } else {\n                        curr--;\n                    }\n                }\n                len[t][i] = (char) curr;\n            }\n        }\n\n        /* Create the Huffman decoding tables */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\n                                 maxLen, alphaSize);\n            minLens[t] = minLen;\n        }\n    }\n\n    private void getAndMoveToFrontDecode() {\n        char[] yy = new char[256];\n        int i, j, nextSym, limitLast;\n        int EOB, groupNo, groupPos;\n\n        limitLast = baseBlockSize * blockSize100k;\n        origPtr = bsGetIntVS(24);\n\n        recvDecodingTables();\n        EOB = nInUse + 1;\n        groupNo = -1;\n        groupPos = 0;\n\n        /*\n          Setting up the unzftab entries here is not strictly\n          necessary, but it does save having to do it later\n          in a separate pass, and so saves a block's worth of\n          cache misses.\n        */\n        for (i = 0; i <= 255; i++) {\n            unzftab[i] = 0;\n        }\n\n        for (i = 0; i <= 255; i++) {\n            yy[i] = (char) i;\n        }\n\n        last = -1;\n\n        {\n            int zt, zn, zvec, zj;\n            if (groupPos == 0) {\n                groupNo++;\n                groupPos = G_SIZE;\n            }\n            groupPos--;\n            zt = selector[groupNo];\n            zn = minLens[zt];\n            zvec = bsR(zn);\n            while (zvec > limit[zt][zn]) {\n                zn++;\n                {\n                    {\n                        while (bsLive < 1) {\n                            int zzi;\n                            char thech = 0;\n                            try {\n                                thech = (char) bsStream.read();\n                            } catch (IOException e) {\n                                compressedStreamEOF();\n                            }\n                            if (thech == -1) {\n                                compressedStreamEOF();\n                            }\n                            zzi = thech;\n                            bsBuff = (bsBuff << 8) | (zzi & 0xff);\n                            bsLive += 8;\n                        }\n                    }\n                    zj = (bsBuff >> (bsLive - 1)) & 1;\n                    bsLive--;\n                }\n                zvec = (zvec << 1) | zj;\n            }\n            nextSym = perm[zt][zvec - base[zt][zn]];\n        }\n\n        while (true) {\n\n            if (nextSym == EOB) {\n                break;\n            }\n\n            if (nextSym == RUNA || nextSym == RUNB) {\n                char ch;\n                int s = -1;\n                int N = 1;\n                do {\n                    if (nextSym == RUNA) {\n                        s = s + (0 + 1) * N;\n                    } else if (nextSym == RUNB) {\n                        s = s + (1 + 1) * N;\n                           }\n                    N = N * 2;\n                    {\n                        int zt, zn, zvec, zj;\n                        if (groupPos == 0) {\n                            groupNo++;\n                            groupPos = G_SIZE;\n                        }\n                        groupPos--;\n                        zt = selector[groupNo];\n                        zn = minLens[zt];\n                        zvec = bsR(zn);\n                        while (zvec > limit[zt][zn]) {\n                            zn++;\n                            {\n                                {\n                                    while (bsLive < 1) {\n                                        int zzi;\n                                        char thech = 0;\n                                        try {\n                                            thech = (char) bsStream.read();\n                                        } catch (IOException e) {\n                                            compressedStreamEOF();\n                                        }\n                                        if (thech == -1) {\n                                            compressedStreamEOF();\n                                        }\n                                        zzi = thech;\n                                        bsBuff = (bsBuff << 8) | (zzi & 0xff);\n                                        bsLive += 8;\n                                    }\n                                }\n                                zj = (bsBuff >> (bsLive - 1)) & 1;\n                                bsLive--;\n                            }\n                            zvec = (zvec << 1) | zj;\n                        }\n                        nextSym = perm[zt][zvec - base[zt][zn]];\n                    }\n                } while (nextSym == RUNA || nextSym == RUNB);\n\n                s++;\n                ch = seqToUnseq[yy[0]];\n                unzftab[ch] += s;\n\n                while (s > 0) {\n                    last++;\n                    ll8[last] = ch;\n                    s--;\n                }\n\n                if (last >= limitLast) {\n                    blockOverrun();\n                }\n                continue;\n            } else {\n                char tmp;\n                last++;\n                if (last >= limitLast) {\n                    blockOverrun();\n                }\n\n                tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp]]++;\n                ll8[last] = seqToUnseq[tmp];\n\n                /*\n                  This loop is hammered during decompression,\n                  hence the unrolling.\n                  for (j = nextSym-1; j > 0; j--) yy[j] = yy[j-1];\n                */\n\n                j = nextSym - 1;\n                for (; j > 3; j -= 4) {\n                    yy[j]     = yy[j - 1];\n                    yy[j - 1] = yy[j - 2];\n                    yy[j - 2] = yy[j - 3];\n                    yy[j - 3] = yy[j - 4];\n                }\n                for (; j > 0; j--) {\n                    yy[j] = yy[j - 1];\n                }\n\n                yy[0] = tmp;\n                {\n                    int zt, zn, zvec, zj;\n                    if (groupPos == 0) {\n                        groupNo++;\n                        groupPos = G_SIZE;\n                    }\n                    groupPos--;\n                    zt = selector[groupNo];\n                    zn = minLens[zt];\n                    zvec = bsR(zn);\n                    while (zvec > limit[zt][zn]) {\n                        zn++;\n                        {\n                            {\n                                while (bsLive < 1) {\n                                    int zzi;\n                                    char thech = 0;\n                                    try {\n                                        thech = (char) bsStream.read();\n                                    } catch (IOException e) {\n                                        compressedStreamEOF();\n                                    }\n                                    zzi = thech;\n                                    bsBuff = (bsBuff << 8) | (zzi & 0xff);\n                                    bsLive += 8;\n                                }\n                            }\n                            zj = (bsBuff >> (bsLive - 1)) & 1;\n                            bsLive--;\n                        }\n                        zvec = (zvec << 1) | zj;\n                    }\n                    nextSym = perm[zt][zvec - base[zt][zn]];\n                }\n                continue;\n            }\n        }\n    }\n\n    private void setupBlock() {\n        int[] cftab = new int[257];\n        char ch;\n\n        cftab[0] = 0;\n        for (i = 1; i <= 256; i++) {\n            cftab[i] = unzftab[i - 1];\n        }\n        for (i = 1; i <= 256; i++) {\n            cftab[i] += cftab[i - 1];\n        }\n\n        for (i = 0; i <= last; i++) {\n            ch = (char) ll8[i];\n            tt[cftab[ch]] = i;\n            cftab[ch]++;\n        }\n        cftab = null;\n\n        tPos = tt[origPtr];\n\n        count = 0;\n        i2 = 0;\n        ch2 = 256;   /* not a char and not EOF */\n\n        if (blockRandomised) {\n            rNToGo = 0;\n            rTPos = 0;\n            setupRandPartA();\n        } else {\n            setupNoRandPartA();\n        }\n    }\n\n    private void setupRandPartA() {\n        if (i2 <= last) {\n            chPrev = ch2;\n            ch2 = ll8[tPos];\n            tPos = tt[tPos];\n            if (rNToGo == 0) {\n                rNToGo = rNums[rTPos];\n                rTPos++;\n                if (rTPos == 512) {\n                    rTPos = 0;\n                }\n            }\n            rNToGo--;\n            ch2 ^= (int) ((rNToGo == 1) ? 1 : 0);\n            i2++;\n\n            currentChar = ch2;\n            currentState = RAND_PART_B_STATE;\n            mCrc.updateCRC(ch2);\n        } else {\n            endBlock();\n            initBlock();\n            setupBlock();\n        }\n    }\n\n    private void setupNoRandPartA() {\n        if (i2 <= last) {\n            chPrev = ch2;\n            ch2 = ll8[tPos];\n            tPos = tt[tPos];\n            i2++;\n\n            currentChar = ch2;\n            currentState = NO_RAND_PART_B_STATE;\n            mCrc.updateCRC(ch2);\n        } else {\n            endBlock();\n            initBlock();\n            setupBlock();\n        }\n    }\n\n    private void setupRandPartB() {\n        if (ch2 != chPrev) {\n            currentState = RAND_PART_A_STATE;\n            count = 1;\n            setupRandPartA();\n        } else {\n            count++;\n            if (count >= 4) {\n                z = ll8[tPos];\n                tPos = tt[tPos];\n                if (rNToGo == 0) {\n                    rNToGo = rNums[rTPos];\n                    rTPos++;\n                    if (rTPos == 512) {\n                        rTPos = 0;\n                    }\n                }\n                rNToGo--;\n                z ^= ((rNToGo == 1) ? 1 : 0);\n                j2 = 0;\n                currentState = RAND_PART_C_STATE;\n                setupRandPartC();\n            } else {\n                currentState = RAND_PART_A_STATE;\n                setupRandPartA();\n            }\n        }\n    }\n\n    private void setupRandPartC() {\n        if (j2 < (int) z) {\n            currentChar = ch2;\n            mCrc.updateCRC(ch2);\n            j2++;\n        } else {\n            currentState = RAND_PART_A_STATE;\n            i2++;\n            count = 0;\n            setupRandPartA();\n        }\n    }\n\n    private void setupNoRandPartB() {\n        if (ch2 != chPrev) {\n            currentState = NO_RAND_PART_A_STATE;\n            count = 1;\n            setupNoRandPartA();\n        } else {\n            count++;\n            if (count >= 4) {\n                z = ll8[tPos];\n                tPos = tt[tPos];\n                currentState = NO_RAND_PART_C_STATE;\n                j2 = 0;\n                setupNoRandPartC();\n            } else {\n                currentState = NO_RAND_PART_A_STATE;\n                setupNoRandPartA();\n            }\n        }\n    }\n\n    private void setupNoRandPartC() {\n        if (j2 < (int) z) {\n            currentChar = ch2;\n            mCrc.updateCRC(ch2);\n            j2++;\n        } else {\n            currentState = NO_RAND_PART_A_STATE;\n            i2++;\n            count = 0;\n            setupNoRandPartA();\n        }\n    }\n\n    private void setDecompressStructureSizes(int newSize100k) {\n        if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k\n               && blockSize100k <= 9)) {\n            // throw new IOException("Invalid block size");\n        }\n\n        blockSize100k = newSize100k;\n\n        if (newSize100k == 0) {\n            return;\n        }\n\n        int n = baseBlockSize * newSize100k;\n        ll8 = new char[n];\n        tt = new int[n];\n    }\n}	Long Method	God Class\n	Divergent Change\n	Feature Envy\n	CBZip2InputStream.java	19d9e603f8694c4764c33bce53be5b0c	\N	Quando métodos que centralizam a funcionalidade da classe	LOC (Lines of Code), NCO (Number Concerns per Operations), NCC (Number Concerns per Component)	Refatoração sugerida:  Replace Method with Method Object	t	3
51	Identifique o Bad Smell na classe abaixo	// Mongo.java\n\n/**\n *      Copyright (C) 2008 10gen Inc.\n *\n *   Licensed under the Apache License, Version 2.0 (the "License");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an "AS IS" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\npackage com.mongodb;\n\nimport org.bson.io.PoolOutputBuffer;\n\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Logger;\n\n/**\n * A database connection with internal connection pooling. For most applications, you should have one Mongo instance\n * for the entire JVM.\n * \n\n * The following are equivalent, and all connect to the local database running on the default port:\n * \n\n * Mongo mongo1 = new Mongo();\n * Mongo mongo1 = new Mongo("localhost");\n * Mongo mongo2 = new Mongo("localhost", 27017);\n * Mongo mongo4 = new Mongo(new ServerAddress("localhost"));\n * \n\n * \n\n * You can connect to a\n * replica set using the Java driver by passing\n * a ServerAddress list to the Mongo constructor. For example:\n * \n\n * Mongo mongo = new Mongo(Arrays.asList(\n *   new ServerAddress("localhost", 27017),\n *   new ServerAddress("localhost", 27018),\n *   new ServerAddress("localhost", 27019)));\n * \n\n * You can connect to a sharded cluster using the same constructor.  Mongo will auto-detect whether the servers are\n * a list of replica set members or a list of mongos servers.\n * \n\n * By default, all read and write operations will be made on the primary,\n * but it's possible to read from secondaries by changing the read preference:\n * \n\n\n * \n\n * mongo.setReadPreference(ReadPreference.secondary());\n * \n\n * By default, write operations will not throw exceptions on failure, but that is easily changed too:\n * \n\n * \n\n * mongo.setWriteConcern(WriteConcern.SAFE);\n * \n\n *\n * Note: This class has been superseded by {@code MongoClient}, and may be deprecated in a future release.\n *\n * @see MongoClient\n * @see ReadPreference\n * @see WriteConcern\n */\npublic class Mongo {\n\n    static Logger logger = Logger.getLogger(Bytes.LOGGER.getName() + ".Mongo");\n\n\n    // Make sure you don't change the format of these two static variables. A preprocessing regexp\n    // is applied and updates the version based on configuration in build.properties.\n\n    /**\n     * @deprecated Replaced by Mongo.getMajorVersion()\n     */\n    @Deprecated\n    public static final int MAJOR_VERSION = 2;\n\n    /**\n     * @deprecated Replaced by Mongo.getMinorVersion()\n     */\n    @Deprecated\n    public static final int MINOR_VERSION = 12;\n\n    private static final String FULL_VERSION = "2.12.0-SNAPSHOT";\n\n    static int cleanerIntervalMS;\n\n    private static final String ADMIN_DATABASE_NAME = "admin";\n\n    static {\n        cleanerIntervalMS = Integer.parseInt(System.getProperty("com.mongodb.cleanerIntervalMS", "1000"));\n    }\n\n    /**\n     * Gets the major version of this library\n     * @return the major version, e.g. 2\n     *\n     * @deprecated Please use {@link #getVersion()} instead.\n     */\n    @Deprecated\n    public static int getMajorVersion() {\n        return MAJOR_VERSION;\n    }\n\n    /**\n     * Gets the minor version of this library\n     * @return the minor version, e.g. 8\n     *\n     * @deprecated Please use {@link #getVersion()} instead.\n     */\n    @Deprecated\n    public static int getMinorVersion() {\n        return MINOR_VERSION;\n    }\n\n    /**\n     * returns a database object\n     * @param addr the database address\n     * @return\n     * @throws MongoException\n     *\n     * @deprecated Please use {@link MongoClient#getDB(String)} instead.\n     */\n    @Deprecated\n    public static DB connect( DBAddress addr ){\n        return new Mongo( addr ).getDB( addr.getDBName() );\n    }\n\n    /**\n     * Creates a Mongo instance based on a (single) mongodb node (localhost, default port)\n     * @throws UnknownHostException\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient()})\n     *\n     */\n    @Deprecated\n    public Mongo()\n        throws UnknownHostException {\n        this( new ServerAddress() );\n    }\n\n    /**\n     * Creates a Mongo instance based on a (single) mongodb node (default port)\n     * @param host server to connect to\n     * @throws UnknownHostException if the database host cannot be resolved\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(String)}\n     *\n     */\n    @Deprecated\n    public Mongo( String host )\n        throws UnknownHostException{\n        this( new ServerAddress( host ) );\n    }\n\n    /**\n     * Creates a Mongo instance based on a (single) mongodb node (default port)\n     * @param host server to connect to\n     * @param options default query options\n     * @throws UnknownHostException if the database host cannot be resolved\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(String, MongoClientOptions)}\n     *\n     */\n    @Deprecated\n    public Mongo( String host , MongoOptions options )\n        throws UnknownHostException {\n        this( new ServerAddress( host ) , options );\n    }\n\n    /**\n     * Creates a Mongo instance based on a (single) mongodb node\n     * @param host the database's host address\n     * @param port the port on which the database is running\n     * @throws UnknownHostException if the database host cannot be resolved\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(String, int)}\n     *\n     */\n    @Deprecated\n    public Mongo( String host , int port )\n        throws UnknownHostException {\n        this( new ServerAddress( host , port ) );\n    }\n\n    /**\n     * Creates a Mongo instance based on a (single) mongodb node\n     * @see com.mongodb.ServerAddress\n     * @param addr the database address\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(ServerAddress)}\n     *\n     */\n    @Deprecated\n    public Mongo( ServerAddress addr ) {\n        this(addr, new MongoOptions());\n    }\n\n    /**\n     * Creates a Mongo instance based on a (single) mongo node using a given ServerAddress\n     * @see com.mongodb.ServerAddress\n     * @param addr the database address\n     * @param options default query options\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(ServerAddress, MongoClientOptions)}\n     *\n     */\n    @Deprecated\n    public Mongo( ServerAddress addr , MongoOptions options ) {\n        this(MongoAuthority.direct(addr), options);\n    }\n\n    /**\n     * \nCreates a Mongo in paired mode. \n This will also work for\n     * a replica set and will find all members (the master will be used by\n     * default).\n\n\n     *\n     * @see com.mongodb.ServerAddress\n     * @param left left side of the pair\n     * @param right right side of the pair\n     * @throws MongoException\n     */\n    @Deprecated\n    public Mongo( ServerAddress left , ServerAddress right ) {\n        this(left, right, new MongoOptions());\n    }\n\n    /**\n     * \nCreates a Mongo connection in paired mode. \n This will also work for\n     * a replica set and will find all members (the master will be used by\n     * default).\n\n\n     *\n     * @see com.mongodb.ServerAddress\n     * @param left left side of the pair\n     * @param right right side of the pair\n     * @param options\n     * @throws MongoException\n     */\n    @Deprecated\n    public Mongo( ServerAddress left , ServerAddress right , MongoOptions options ) {\n        this(MongoAuthority.dynamicSet(Arrays.asList(left, right)), options);\n    }\n\n    /**\n     * Creates a Mongo based on a list of replica set members or a list of mongos.\n     * It will find all members (the master will be used by default). If you pass in a single server in the list,\n     * the driver will still function as if it is a replica set. If you have a standalone server,\n     * use the Mongo(ServerAddress) constructor.\n     * \n\n     * If this is a list of mongos servers, it will pick the closest (lowest ping time) one to send all requests to,\n     * and automatically fail over to the next server if the closest is down.\n     *\n     * @see com.mongodb.ServerAddress\n     * @param seeds Put as many servers as you can in the list and the system will figure out the rest.  This can\n     *              either be a list of mongod servers in the same replica set or a list of mongos servers in the same\n     *              sharded cluster.\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(java.util.List)}\n     *\n     */\n    @Deprecated\n    public Mongo( List seeds ) {\n        this( seeds , new MongoOptions() );\n    }\n\n    /**\n     * Creates a Mongo based on a list of replica set members or a list of mongos.\n     * It will find all members (the master will be used by default). If you pass in a single server in the list,\n     * the driver will still function as if it is a replica set. If you have a standalone server,\n     * use the Mongo(ServerAddress) constructor.\n     * \n\n\n     * If this is a list of mongos servers, it will pick the closest (lowest ping time) one to send all requests to,\n     * and automatically fail over to the next server if the closest is down.\n     *\n     * @see com.mongodb.ServerAddress\n     * @param seeds Put as many servers as you can in the list and the system will figure out the rest.  This can\n     *              either be a list of mongod servers in the same replica set or a list of mongos servers in the same\n     *              sharded cluster.\n     * @param options for configuring this Mongo instance\n     * @throws MongoException\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(java.util.List, MongoClientOptions)}\n     *\n     */\n    @Deprecated\n    public Mongo( List seeds , MongoOptions options ) {\n        this(MongoAuthority.dynamicSet(seeds), options);\n    }\n\n    /**\n     * Creates a Mongo described by a URI.\n     * If only one address is used it will only connect to that node, otherwise it will discover all nodes.\n     * If the URI contains database credentials, the database will be authenticated lazily on first use\n     * with those credentials.\n     * @param uri\n     * @see MongoURI\n     * \n\nexamples:\n     *   \n\nmongodb://localhost\n\n     *   \nmongodb://fred:foobar@localhost/\n\n     *  \n\n     * @throws MongoException\n     * @throws UnknownHostException\n     * @dochub connections\n     *\n     * @deprecated Replaced by {@link MongoClient#MongoClient(MongoClientURI)}\n     *\n     */\n    @Deprecated\n    public Mongo( MongoURI uri ) throws UnknownHostException {\n        this(getMongoAuthorityFromURI(uri), uri.getOptions());\n    }\n\n    /**\n     * Creates a Mongo based on an authority and options.\n     * \n\n     * Note: This constructor is provisional and is subject to change before the final release\n     *\n     * @param authority the authority\n     * @param options the options\n     */\n    Mongo(MongoAuthority authority, MongoOptions options) {\n        logger.info("Creating Mongo instance (driver version " + getVersion() + ") with authority " + authority + " and options " + options);\n        _authority = authority;\n        _options = options;\n        _applyMongoOptions();\n\n        _connector = new DBTCPConnector( this  );\n\n        _connector.start();\n        if (_options.cursorFinalizerEnabled) {\n            _cleaner = new CursorCleanerThread();\n            _cleaner.start();\n        } else {\n            _cleaner = null;\n        }\n    }\n\n    /**\n     * gets a database object\n     * @param dbname the database name\n     * @return\n     */\n    public DB getDB( String dbname ){\n\n        DB db = _dbs.get( dbname );\n        if ( db != null )\n            return db;\n\n        db = new DBApiLayer( this , dbname , _connector );\n        DB temp = _dbs.putIfAbsent( dbname , db );\n        if ( temp != null )\n            return temp;\n        return db;\n    }\n\n    /**\n     * gets a collection of DBs used by the driver since this Mongo instance was created.\n     * This may include DBs that exist in the client but not yet on the server.\n     * @return\n     */\n    public Collection getUsedDatabases(){\n        return _dbs.values();\n    }\n\n    /**\n     * gets a list of all database names present on the server\n     * @return\n     * @throws MongoException\n     */\n    public List getDatabaseNames(){\n\n        BasicDBObject cmd = new BasicDBObject();\n        cmd.put("listDatabases", 1);\n\n\n        CommandResult res = getDB(ADMIN_DATABASE_NAME).command(cmd, getOptions());\n        res.throwOnError();\n\n        List l = (List)res.get("databases");\n\n        List list = new ArrayList();\n\n        for (Object o : l) {\n            list.add(((BasicDBObject)o).getString("name"));\n        }\n        return list;\n    }\n\n\n    /**\n     * Drops the database if it exists.\n     * @param dbName name of database to drop\n     * @throws MongoException\n     */\n    public void dropDatabase(String dbName){\n\n        getDB( dbName ).dropDatabase();\n    }\n\n    /**\n     * gets this driver version\n     * @return the full version string of this driver, e.g. "2.8.0"\n     */\n    public String getVersion(){\n        return FULL_VERSION;\n    }\n\n    /**\n     * returns a string representing the hosts used in this Mongo instance\n     * @return\n     *\n     * @deprecated This method is NOT a part of public API and will be dropped in 3.x versions.\n     */\n    @Deprecated\n    public String debugString(){\n        return _connector.debugString();\n    }\n\n    /**\n     * Gets the current master's hostname\n     * @return\n     */\n    public String getConnectPoint(){\n        return _connector.getConnectPoint();\n    }\n\n    /**\n     * Gets the underlying TCP connector\n     * @return\n     * @deprecated {@link DBTCPConnector} is NOT part of the public API. It will be dropped in 3.x releases.\n     */\n    @Deprecated\n    public DBTCPConnector getConnector() {\n        return _connector;\n    }\n\n    /**\n     * Gets the replica set status object\n     * @return\n     */\n    public ReplicaSetStatus getReplicaSetStatus() {\n        return _connector.getReplicaSetStatus();\n    }\n\n    /**\n     * Gets the address of the current master\n     * @return the address\n     */\n    public ServerAddress getAddress(){\n        return _connector.getAddress();\n    }\n\n    /**\n     * Gets a list of all server addresses used when this Mongo was created\n     * @return\n     */\n    public List getAllAddress() {\n        List result = _connector.getAllAddress();\n        if (result == null) {\n            return Arrays.asList(getAddress());\n        }\n        return result;\n    }\n\n    /**\n     * Gets the list of server addresses currently seen by the connector.\n     * This includes addresses auto-discovered from a replica set.\n     * @return\n     * @throws MongoException\n     */\n    public List getServerAddressList() {\n        return _connector.getServerAddressList();\n    }\n\n    /**\n     * closes the underlying connector, which in turn closes all open connections.\n     * Once called, this Mongo instance can no longer be used.\n     */\n    public void close(){\n\n        try {\n            _connector.close();\n        } catch (final Throwable t) { /* nada */ }\n\n        if (_cleaner != null) {\n            _cleaner.interrupt();\n\n            try {\n                _cleaner.join();\n            } catch (InterruptedException e) {\n                //end early\n            }\n        }\n    }\n\n    /**\n     * Sets the write concern for this database. Will be used as default for\n     * writes to any collection in any database. See the\n     * documentation for {@link WriteConcern} for more information.\n     *\n     * @param concern write concern to use\n     */\n    public void setWriteConcern( WriteConcern concern ){\n        _concern = concern;\n    }\n\n    /**\n     * Gets the default write concern\n     * @return\n     */\n    public WriteConcern getWriteConcern(){\n        return _concern;\n    }\n\n    /**\n     * Sets the read preference for this database. Will be used as default for\n     * reads from any collection in any database. See the\n     * documentation for {@link ReadPreference} for more information.\n     *\n     * @param preference Read Preference to use\n     */\n    public void setReadPreference( ReadPreference preference ){\n        _readPref = preference;\n    }\n\n    /**\n     * Gets the default read preference\n     * @return\n     */\n    public ReadPreference getReadPreference(){\n        return _readPref;\n    }\n\n    /**\n     * makes it possible to run read queries on secondary nodes\n     *\n     * @deprecated Replaced with {@code ReadPreference.secondaryPreferred()}\n     * @see ReadPreference#secondaryPreferred()\n     */\n    @Deprecated\n    public void slaveOk(){\n        addOption( Bytes.QUERYOPTION_SLAVEOK );\n    }\n\n    /**\n     * adds a default query option\n     * @param option\n     */\n    public void addOption( int option ){\n        _netOptions.add( option );\n    }\n\n    /**\n     * sets the default query options\n     * @param options\n     */\n    public void setOptions( int options ){\n        _netOptions.set( options );\n    }\n\n    /**\n     * reset the default query options\n     */\n    public void resetOptions(){\n        _netOptions.reset();\n    }\n\n    /**\n     * gets the default query options\n     * @return\n     */\n    public int getOptions(){\n        return _netOptions.get();\n    }\n\n    /**\n     * Helper method for setting up MongoOptions at instantiation\n     * so that any options which affect this connection can be set.\n     */\n    @SuppressWarnings("deprecation")\n    void _applyMongoOptions() {\n        if (_options.slaveOk) {\n            slaveOk();\n        }\n        if (_options.getReadPreference() != null) {\n           setReadPreference(_options.getReadPreference());\n        }\n        setWriteConcern(_options.getWriteConcern());\n    }\n\n    /**\n     * Returns the mongo options.\n     *\n     * @deprecated Please use {@link MongoClient}\n     *             and corresponding {@link com.mongodb.MongoClient#getMongoClientOptions()}\n     */\n    @Deprecated\n    public MongoOptions getMongoOptions() {\n        return _options;\n    }\n\n    /**\n     * Gets the maximum size for a BSON object supported by the current master server.\n     * Note that this value may change over time depending on which server is master.\n     * If the size is not known yet, a request may be sent to the master server\n     * @return the maximum size\n     * @throws MongoException\n     */\n    public int getMaxBsonObjectSize() {\n        int maxsize = _connector.getMaxBsonObjectSize();\n        if (maxsize == 0) {\n            _connector.initDirectConnection();\n        }\n        maxsize = _connector.getMaxBsonObjectSize();\n        return maxsize > 0 ? maxsize : Bytes.MAX_OBJECT_SIZE;\n    }\n\n    boolean isMongosConnection() {\n        return _connector.isMongosConnection();\n    }\n\n    private static MongoAuthority getMongoAuthorityFromURI(final MongoURI uri) throws UnknownHostException {\n        if ( uri.getHosts().size() == 1 ){\n            return MongoAuthority.direct(new ServerAddress(uri.getHosts().get(0)), uri.getCredentials());\n        }\n        else {\n            List replicaSetSeeds = new ArrayList(uri.getHosts().size());\n            for ( String host : uri.getHosts() )\n                replicaSetSeeds.add( new ServerAddress( host ) );\n            return MongoAuthority.dynamicSet(replicaSetSeeds, uri.getCredentials());\n        }\n    }\n\n    final MongoOptions _options;\n    final DBTCPConnector _connector;\n    final ConcurrentMap _dbs = new ConcurrentHashMap();\n    private WriteConcern _concern = WriteConcern.NORMAL;\n    private ReadPreference _readPref = ReadPreference.primary();\n    final Bytes.OptionHolder _netOptions = new Bytes.OptionHolder( null );\n    final CursorCleanerThread _cleaner;\n    final MongoAuthority _authority;\n\n\n    org.bson.util.SimplePool _bufferPool =\n        new org.bson.util.SimplePool( 1000 ){\n\n        protected PoolOutputBuffer createNew(){\n            return new PoolOutputBuffer();\n        }\n\n    };\n\n    /**\n     * Forces the master server to fsync the RAM data to disk\n     * This is done automatically by the server at intervals, but can be forced for better reliability. \n     * @param async if true, the fsync will be done asynchronously on the server.\n     * @return\n     * @throws MongoException\n     */\n    public CommandResult fsync(boolean async) {\n        DBObject cmd = new BasicDBObject("fsync", 1);\n        if (async) {\n            cmd.put("async", 1);\n        }\n        return getDB(ADMIN_DATABASE_NAME).command(cmd);\n    }\n\n    /**\n     * Forces the master server to fsync the RAM data to disk, then lock all writes.\n     * The database will be read-only after this command returns.\n     * @return\n     * @throws MongoException\n     */\n    public CommandResult fsyncAndLock() {\n        DBObject cmd = new BasicDBObject("fsync", 1);\n        cmd.put("lock", 1);\n        return getDB(ADMIN_DATABASE_NAME).command(cmd);\n    }\n\n    /**\n     * Unlocks the database, allowing the write operations to go through.\n     * This command may be asynchronous on the server, which means there may be a small delay before the database becomes writable.\n     * @return\n     * @throws MongoException\n     */\n    public DBObject unlock() {\n        DB db = getDB(ADMIN_DATABASE_NAME);\n        DBCollection col = db.getCollection("$cmd.sys.unlock");\n        return col.findOne();\n    }\n\n    /**\n     * Returns true if the database is locked (read-only), false otherwise.\n     * @return\n     * @throws MongoException\n     */\n    public boolean isLocked() {\n        DB db = getDB(ADMIN_DATABASE_NAME);\n        DBCollection col = db.getCollection("$cmd.sys.inprog");\n        BasicDBObject res = (BasicDBObject) col.findOne();\n        if (res.containsField("fsyncLock")) {\n            return res.getInt("fsyncLock") == 1;\n        }\n        return false;\n    }\n\n    // -------\n\n\n    /**\n     * Mongo.Holder can be used as a static place to hold several instances of Mongo.\n     * Security is not enforced at this level, and needs to be done on the application side.\n     */\n    public static class Holder {\n\n        /**\n         * Attempts to find an existing MongoClient instance matching that URI in the holder, and returns it if exists.\n         * Otherwise creates a new Mongo instance based on this URI and adds it to the holder.\n         *\n         * @param uri the Mongo URI\n         * @return the client\n         * @throws MongoException\n         * @throws UnknownHostException\n         *\n         * @deprecated Please use {@link #connect(MongoClientURI)} instead.\n         */\n        @Deprecated\n        public Mongo connect(final MongoURI uri) throws UnknownHostException {\n            return connect(uri.toClientURI());\n        }\n\n        /**\n         * Attempts to find an existing MongoClient instance matching that URI in the holder, and returns it if exists.\n         * Otherwise creates a new Mongo instance based on this URI and adds it to the holder.\n         *\n         * @param uri the Mongo URI\n         * @return the client\n         * @throws MongoException\n         * @throws UnknownHostException\n         */\n        public Mongo connect(final MongoClientURI uri) throws UnknownHostException {\n\n            final String key = toKey(uri);\n\n            Mongo client = _mongos.get(key);\n\n            if (client == null) {\n                final Mongo newbie = new MongoClient(uri);\n                client = _mongos.putIfAbsent(key, newbie);\n                if (client == null) {\n                    client = newbie;\n                } else {\n                    newbie.close();\n                }\n            }\n\n            return client;\n        }\n\n        private String toKey(final MongoClientURI uri) {\n            return uri.toString();\n        }\n\n        public static Holder singleton() { return _default; }\n\n        private static Holder _default = new Holder();\n        private final ConcurrentMap _mongos = new ConcurrentHashMap();\n\n    }\n\n    class CursorCleanerThread extends Thread {\n\n        CursorCleanerThread() {\n            setDaemon(true);\n            setName("MongoCleaner" + hashCode());\n        }\n\n        public void run() {\n            while (_connector.isOpen()) {\n                try {\n                    try {\n                        Thread.sleep(cleanerIntervalMS);\n                    } catch (InterruptedException e) {\n                        //caused by the Mongo instance being closed -- proceed with cleanup\n                    }\n                    for (DB db : _dbs.values()) {\n                        db.cleanCursors(true);\n                    }\n                } catch (Throwable t) {\n                    // thread must never die\n                }\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return "Mongo{" +\n                "authority=" + _authority +\n                ", options=" + _options +\n                '}';\n    }\n\n    /**\n     * Gets the authority, which includes the connection type, the server address(es), and the credentials.\n\n     * @return the authority\n     */\n    MongoAuthority getAuthority() {\n        return _authority;\n    }\n}	Divergent Change	God Class\n	Shotgun Surgery\n	Long Method	Mongo.java\n	9aa0a177fe1900bc8c86e3295a20f74c	\N	Oocorre quando uma classe é alterada de maneiras diferentes por diferentes razões.	WMC (Weighted Method per Class), NCC (Number Concerns per Component), LCOM (Lack of Cohesion in Methods)	Refatoração sugerida: Extract Class	t	3
53	Identifique o Bad Smell na classe abaixo	/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server;\n\nimport com.android.internal.app.ResolverActivity;\nimport com.android.internal.util.FastXmlSerializer;\nimport com.android.internal.util.XmlUtils;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport android.app.ActivityManagerNative;\nimport android.app.IActivityManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.ComponentInfo;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageDeleteObserver;\nimport android.content.pm.IPackageInstallObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.IPackageStatsObserver;\nimport android.content.pm.InstrumentationInfo;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageStats;\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;\nimport static android.content.pm.PackageManager.PKG_INSTALL_COMPLETE;\nimport static android.content.pm.PackageManager.PKG_INSTALL_INCOMPLETE;\nimport android.content.pm.PackageParser;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.PermissionGroupInfo;\nimport android.content.pm.ProviderInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.HandlerThread;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.ParcelFileDescriptor;\nimport android.os.Process;\nimport android.os.ServiceManager;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.util.*;\nimport android.view.Display;\nimport android.view.WindowManager;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nclass PackageManagerService extends IPackageManager.Stub {\n    private static final String TAG = "PackageManager";\n    private static final boolean DEBUG_SETTINGS = false;\n    private static final boolean DEBUG_PREFERRED = false;\n\n    private static final boolean MULTIPLE_APPLICATION_UIDS = true;\n    private static final int RADIO_UID = Process.PHONE_UID;\n    private static final int FIRST_APPLICATION_UID =\n        Process.FIRST_APPLICATION_UID;\n    private static final int MAX_APPLICATION_UIDS = 1000;\n\n    private static final boolean SHOW_INFO = false;\n\n    private static final boolean GET_CERTIFICATES = true;\n\n    private static final int REMOVE_EVENTS =\n        FileObserver.CLOSE_WRITE | FileObserver.DELETE | FileObserver.MOVED_FROM;\n    private static final int ADD_EVENTS =\n        FileObserver.CLOSE_WRITE /*| FileObserver.CREATE*/ | FileObserver.MOVED_TO;\n\n    private static final int OBSERVER_EVENTS = REMOVE_EVENTS | ADD_EVENTS;\n\n    static final int SCAN_MONITOR = 1<<0;\n    static final int SCAN_NO_DEX = 1<<1;\n    static final int SCAN_FORCE_DEX = 1<<2;\n    static final int SCAN_UPDATE_SIGNATURE = 1<<3;\n    static final int SCAN_FORWARD_LOCKED = 1<<4;\n    \n    static final int LOG_BOOT_PROGRESS_PMS_START = 3060;\n    static final int LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START = 3070;\n    static final int LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START = 3080;\n    static final int LOG_BOOT_PROGRESS_PMS_SCAN_END = 3090;\n    static final int LOG_BOOT_PROGRESS_PMS_READY = 3100;\n\n    final HandlerThread mHandlerThread = new HandlerThread("PackageManager",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    final Handler mHandler;\n\n    final int mSdkVersion = SystemProperties.getInt(\n            "ro.build.version.sdk", 0);\n    \n    final Context mContext;\n    final boolean mFactoryTest;\n    final DisplayMetrics mMetrics;\n    final int mDefParseFlags;\n    final String[] mSeparateProcesses;\n\n    // This is where all application persistent data goes.\n    final File mAppDataDir;\n\n    // This is the object monitoring the framework dir.\n    final FileObserver mFrameworkInstallObserver;\n\n    // This is the object monitoring the system app dir.\n    final FileObserver mSystemInstallObserver;\n\n    // This is the object monitoring mAppInstallDir.\n    final FileObserver mAppInstallObserver;\n\n    // This is the object monitoring mDrmAppPrivateInstallDir.\n    final FileObserver mDrmAppInstallObserver;\n\n    // Used for priviledge escalation.  MUST NOT BE CALLED WITH mPackages\n    // LOCK HELD.  Can be called with mInstallLock held.\n    final Installer mInstaller;\n    \n    final File mFrameworkDir;\n    final File mSystemAppDir;\n    final File mAppInstallDir;\n\n    // Directory containing the private parts (e.g. code and non-resource assets) of forward-locked\n    // apps.\n    final File mDrmAppPrivateInstallDir;\n    \n    // ----------------------------------------------------------------\n    \n    // Lock for state used when installing and doing other long running\n    // operations.  Methods that must be called with this lock held have\n    // the prefix "LI".\n    Object mInstallLock = new Object();\n    \n    // These are the directories in the 3rd party applications installed dir\n    // that we have currently loaded packages from.  Keys are the application's\n    // installed zip file (absolute codePath), and values are Package.\n    final HashMap<String, PackageParser.Package> mAppDirs =\n            new HashMap<String, PackageParser.Package>();\n\n    // Information for the parser to write more useful error messages.\n    File mScanningPath;\n    int mLastScanError;\n\n    final int[] mOutPermissions = new int[3];\n\n    // ----------------------------------------------------------------\n    \n    // Keys are String (package name), values are Package.  This also serves\n    // as the lock for the global state.  Methods that must be called with\n    // this lock held have the prefix "LP".\n    final HashMap<String, PackageParser.Package> mPackages =\n            new HashMap<String, PackageParser.Package>();\n\n    final Settings mSettings;\n    boolean mRestoredSettings;\n    boolean mReportedUidError;\n\n    // Group-ids that are given to all packages as read from etc/permissions.xml.\n    int[] mGlobalGids;\n\n    // These are the built-in uid -> permission mappings that were read from the\n    // etc/permissions.xml file.\n    final SparseArray<HashSet<String>> mSystemPermissions =\n            new SparseArray<HashSet<String>>();\n    \n    // These are the built-in shared libraries that were read from the\n    // etc/permissions.xml file.\n    final HashMap<String, String> mSharedLibraries = new HashMap<String, String>();\n    \n    // All available activities, for your resolving pleasure.\n    final ActivityIntentResolver mActivities =\n            new ActivityIntentResolver();\n\n    // All available receivers, for your resolving pleasure.\n    final ActivityIntentResolver mReceivers =\n            new ActivityIntentResolver();\n\n    // All available services, for your resolving pleasure.\n    final ServiceIntentResolver mServices = new ServiceIntentResolver();\n\n    // Keys are String (provider class name), values are Provider.\n    final HashMap<ComponentName, PackageParser.Provider> mProvidersByComponent =\n            new HashMap<ComponentName, PackageParser.Provider>();\n\n    // Mapping from provider base names (first directory in content URI codePath)\n    // to the provider information.\n    final HashMap<String, PackageParser.Provider> mProviders =\n            new HashMap<String, PackageParser.Provider>();\n\n    // Mapping from instrumentation class names to info about them.\n    final HashMap<ComponentName, PackageParser.Instrumentation> mInstrumentation =\n            new HashMap<ComponentName, PackageParser.Instrumentation>();\n\n    // Mapping from permission names to info about them.\n    final HashMap<String, PackageParser.PermissionGroup> mPermissionGroups =\n            new HashMap<String, PackageParser.PermissionGroup>();\n\n    boolean mSystemReady;\n    boolean mSafeMode;\n    boolean mHasSystemUidErrors;\n\n    ApplicationInfo mAndroidApplication;\n    final ActivityInfo mResolveActivity = new ActivityInfo();\n    final ResolveInfo mResolveInfo = new ResolveInfo();\n    ComponentName mResolveComponentName;\n    PackageParser.Package mPlatformPackage;\n\n    public static final IPackageManager main(Context context, boolean factoryTest) {\n        PackageManagerService m = new PackageManagerService(context, factoryTest);\n        ServiceManager.addService("package", m);\n        return m;\n    }\n\n    static String[] splitString(String str, char sep) {\n        int count = 1;\n        int i = 0;\n        while ((i=str.indexOf(sep, i)) >= 0) {\n            count++;\n            i++;\n        }\n        \n        String[] res = new String[count];\n        i=0;\n        count = 0;\n        int lastI=0;\n        while ((i=str.indexOf(sep, i)) >= 0) {\n            res[count] = str.substring(lastI, i);\n            count++;\n            i++;\n            lastI = i;\n        }\n        res[count] = str.substring(lastI, str.length());\n        return res;\n    }\n    \n    public PackageManagerService(Context context, boolean factoryTest) {\n        EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,\n                SystemClock.uptimeMillis());\n        \n        if (mSdkVersion <= 0) {\n            Log.w(TAG, "**** ro.build.version.sdk not set!");\n        }\n        \n        mContext = context;\n        mFactoryTest = factoryTest;\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings();\n        mSettings.addSharedUserLP("android.uid.system",\n                Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);\n        mSettings.addSharedUserLP("android.uid.phone",\n                MULTIPLE_APPLICATION_UIDS\n                        ? RADIO_UID : FIRST_APPLICATION_UID,\n                ApplicationInfo.FLAG_SYSTEM);\n\n        String separateProcesses = SystemProperties.get("debug.separate_processes");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if ("*".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Log.w(TAG, "Running with debug.separate_processes: * (ALL)");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(",");\n                Log.w(TAG, "Running with debug.separate_processes: "\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n        \n        Installer installer = new Installer();\n        // Little hacky thing to check if installd is here, to determine\n        // whether we are running on the simulator and thus need to take\n        // care of building the /data file structure ourself.\n        // (apparently the sim now has a working installer)\n        if (installer.ping() && Process.supportsProcesses()) {\n            mInstaller = installer;\n        } else {\n            mInstaller = null;\n        }\n\n        WindowManager wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);\n        Display d = wm.getDefaultDisplay();\n        d.getMetrics(mMetrics);\n\n        synchronized (mInstallLock) {\n        synchronized (mPackages) {\n            mHandlerThread.start();\n            mHandler = new Handler(mHandlerThread.getLooper());\n            \n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, "data");\n            mDrmAppPrivateInstallDir = new File(dataDir, "app-private");\n\n            if (mInstaller == null) {\n                // Make sure these dirs exist, when we are running in\n                // the simulator.\n                // Make a wide-open directory for random misc stuff.\n                File miscDir = new File(dataDir, "misc");\n                miscDir.mkdirs();\n                mAppDataDir.mkdirs();\n                mDrmAppPrivateInstallDir.mkdirs();\n            }\n\n            readPermissions();\n\n            mRestoredSettings = mSettings.readLP();\n            long startTime = SystemClock.uptimeMillis();\n            \n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,\n                    startTime);\n            \n            int scanMode = SCAN_MONITOR;\n            \n            final HashSet<String> libFiles = new HashSet<String>();\n            \n            mFrameworkDir = new File(Environment.getRootDirectory(), "framework");\n            \n            if (mInstaller != null) {\n                /**\n                 * Out of paranoia, ensure that everything in the boot class\n                 * path has been dexed.\n                 */\n                String bootClassPath = System.getProperty("java.boot.class.path");\n                if (bootClassPath != null) {\n                    String[] paths = splitString(bootClassPath, ':');\n                    for (int i=0; i<paths.length; i++) {\n                        try {\n                            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {\n                                libFiles.add(paths[i]);\n                                mInstaller.dexopt(paths[i], Process.SYSTEM_UID, true);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Log.w(TAG, "Boot class path not found: " + paths[i]);\n                        } catch (IOException e) {\n                            Log.w(TAG, "Exception reading boot class path: " + paths[i], e);\n                        }\n                    }\n                } else {\n                    Log.w(TAG, "No BOOTCLASSPATH found!");\n                }\n                \n                /**\n                 * Also ensure all external libraries have had dexopt run on them.\n                 */\n                if (mSharedLibraries.size() > 0) {\n                    Iterator<String> libs = mSharedLibraries.values().iterator();\n                    while (libs.hasNext()) {\n                        String lib = libs.next();\n                        try {\n                            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {\n                                libFiles.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Log.w(TAG, "Library not found: " + lib);\n                        } catch (IOException e) {\n                            Log.w(TAG, "Exception reading library: " + lib, e);\n                        }\n                    }\n                }\n                \n                // Gross hack for now: we know this file doesn't contain any\n                // code, so don't dexopt it to avoid the resulting log spew.\n                libFiles.add(mFrameworkDir.getPath() + "/framework-res.apk");\n                \n                /**\n                 * And there are a number of commands implemented in Java, which\n                 * we currently need to do the dexopt on so that they can be\n                 * run from a non-root shell.\n                 */\n                String[] frameworkFiles = mFrameworkDir.list();\n                if (frameworkFiles != null && mInstaller != null) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(mFrameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we alrady did it.\n                        if (libFiles.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(".apk") && !path.endsWith(".jar")) {\n                            continue;\n                        }\n                        try {\n                            if (dalvik.system.DexFile.isDexOptNeeded(path)) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Log.w(TAG, "Jar not found: " + path);\n                        } catch (IOException e) {\n                            Log.w(TAG, "Exception reading jar: " + path, e);\n                        }\n                    }\n                }\n            }\n            \n            mFrameworkInstallObserver = new AppDirObserver(\n                mFrameworkDir.getPath(), OBSERVER_EVENTS, true);\n            mFrameworkInstallObserver.startWatching();\n            scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM,\n                    scanMode | SCAN_NO_DEX);\n            mSystemAppDir = new File(Environment.getRootDirectory(), "app");\n            mSystemInstallObserver = new AppDirObserver(\n                mSystemAppDir.getPath(), OBSERVER_EVENTS, true);\n            mSystemInstallObserver.startWatching();\n            scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM, scanMode);\n            mAppInstallDir = new File(dataDir, "app");\n            if (mInstaller == null) {\n                // Make sure these dirs exist, when we are running in\n                // the simulator.\n                mAppInstallDir.mkdirs(); // scanDirLI() assumes this dir exists\n            }\n            //look for any incomplete package installations\n            ArrayList<String> deletePkgsList = mSettings.getListOfIncompleteInstallPackages();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n            \n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                    SystemClock.uptimeMillis());\n            mAppInstallObserver = new AppDirObserver(\n                mAppInstallDir.getPath(), OBSERVER_EVENTS, false);\n            mAppInstallObserver.startWatching();\n            scanDirLI(mAppInstallDir, 0, scanMode);\n\n            mDrmAppInstallObserver = new AppDirObserver(\n                mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, false);\n            mDrmAppInstallObserver.startWatching();\n            scanDirLI(mDrmAppPrivateInstallDir, 0, scanMode);\n\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,\n                    SystemClock.uptimeMillis());\n            Log.i(TAG, "Time to scan packages: "\n                    + ((SystemClock.uptimeMillis()-startTime)/1000f)\n                    + " seconds");\n\n            updatePermissionsLP();\n\n            mSettings.writeLP();\n\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,\n                    SystemClock.uptimeMillis());\n            \n            // Now after opening every single application zip, make sure they\n            // are all flushed.  Not really needed, but keeps things nice and\n            // tidy.\n            Runtime.getRuntime().gc();\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n    }\n    \n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            if (!(e instanceof SecurityException) && !(e instanceof IllegalArgumentException)) {\n                Log.e(TAG, "Package Manager Crash", e);\n            }\n            throw e;\n        }\n    }\n\n    void cleanupInstallFailedPackage(String packageName) {\n        if (mInstaller != null) {\n            int retCode = mInstaller.remove(packageName);\n            if (retCode < 0) {\n                Log.w(TAG, "Couldn't remove app data directory for package: "\n                           + packageName + ", retcode=" + retCode);\n            }\n        } else {\n            //for emulator\n            PackageParser.Package pkg = mPackages.get(packageName);\n            File dataDir = new File(pkg.applicationInfo.dataDir);\n            dataDir.delete();\n        }\n        mSettings.removePackageLP(packageName);\n    }\n\n    void readPermissions() {\n        final File permFile = new File(Environment.getRootDirectory(),\n                "etc/permissions.xml");\n        FileReader permReader = null;\n        try {\n            permReader = new FileReader(permFile);\n        } catch (FileNotFoundException e) {\n            Log.w(TAG, "Couldn't find or open permissions file " + permFile);\n            return;\n        }\n\n        try {\n            XmlPullParser parser = Xml.newPullParser();\n            parser.setInput(permReader);\n\n            XmlUtils.beginDocument(parser, "permissions");\n\n            while (true) {\n                XmlUtils.nextElement(parser);\n                if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {\n                    break;\n                }\n\n                String name = parser.getName();\n                if ("group".equals(name)) {\n                    String gidStr = parser.getAttributeValue(null, "gid");\n                    if (gidStr != null) {\n                        int gid = Integer.parseInt(gidStr);\n                        mGlobalGids = appendInt(mGlobalGids, gid);\n                    } else {\n                        Log.w(TAG, "<group> without gid at "\n                                + parser.getPositionDescription());\n                    }\n                    XmlUtils.skipCurrentTag(parser);\n                    continue;\n                    \n                } else if ("permission".equals(name)) {\n                    String perm = parser.getAttributeValue(null, "name");\n                    if (perm == null) {\n                        Log.w(TAG, "<permission> without name at "\n                                + parser.getPositionDescription());\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                    perm = perm.intern();\n                    readPermission(parser, perm);\n                    \n                } else if ("assign-permission".equals(name)) {\n                    String perm = parser.getAttributeValue(null, "name");\n                    if (perm == null) {\n                        Log.w(TAG, "<assign-permission> without name at "\n                                + parser.getPositionDescription());\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                    String uidStr = parser.getAttributeValue(null, "uid");\n                    if (uidStr == null) {\n                        Log.w(TAG, "<assign-permission> without uid at "\n                                + parser.getPositionDescription());\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                    int uid = Process.getUidForName(uidStr);\n                    if (uid < 0) {\n                        Log.w(TAG, "<assign-permission> with unknown uid \\""\n                                + uidStr + "\\" at "\n                                + parser.getPositionDescription());\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                    perm = perm.intern();\n                    HashSet<String> perms = mSystemPermissions.get(uid);\n                    if (perms == null) {\n                        perms = new HashSet<String>();\n                        mSystemPermissions.put(uid, perms);\n                    }\n                    perms.add(perm);\n                    XmlUtils.skipCurrentTag(parser);\n                    \n                } else if ("library".equals(name)) {\n                    String lname = parser.getAttributeValue(null, "name");\n                    String lfile = parser.getAttributeValue(null, "file");\n                    if (lname == null) {\n                        Log.w(TAG, "<library> without name at "\n                                + parser.getPositionDescription());\n                    } else if (lfile == null) {\n                        Log.w(TAG, "<library> without file at "\n                                + parser.getPositionDescription());\n                    } else {\n                        this.mSharedLibraries.put(lname, lfile);\n                    }\n                    XmlUtils.skipCurrentTag(parser);\n                    continue;\n                    \n                } else {\n                    XmlUtils.skipCurrentTag(parser);\n                    continue;\n                }\n\n            }\n        } catch (XmlPullParserException e) {\n            Log.w(TAG, "Got execption parsing permissions.", e);\n        } catch (IOException e) {\n            Log.w(TAG, "Got execption parsing permissions.", e);\n        }\n    }\n\n    void readPermission(XmlPullParser parser, String name)\n            throws IOException, XmlPullParserException {\n\n        name = name.intern();\n\n        BasePermission bp = mSettings.mPermissions.get(name);\n        if (bp == null) {\n            bp = new BasePermission(name, null, BasePermission.TYPE_BUILTIN);\n            mSettings.mPermissions.put(name, bp);\n        }\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT\n               && (type != XmlPullParser.END_TAG\n                       || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG\n                    || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if ("group".equals(tagName)) {\n                String gidStr = parser.getAttributeValue(null, "gid");\n                if (gidStr != null) {\n                    int gid = Process.getGidForName(gidStr);\n                    bp.gids = appendInt(bp.gids, gid);\n                } else {\n                    Log.w(TAG, "<group> without gid at "\n                            + parser.getPositionDescription());\n                }\n            }\n            XmlUtils.skipCurrentTag(parser);\n        }\n    }\n\n    int[] appendInt(int[] cur, int val) {\n        if (cur == null) {\n            return new int[] { val };\n        }\n        final int N = cur.length;\n        for (int i=0; i<N; i++) {\n            if (cur[i] == val) {\n                return cur;\n            }\n        }\n        int[] ret = new int[N+1];\n        System.arraycopy(cur, 0, ret, 0, N);\n        ret[N] = val;\n        return ret;\n    }\n\n    int[] appendInts(int[] cur, int[] add) {\n        if (add == null) return cur;\n        if (cur == null) return add;\n        final int N = add.length;\n        for (int i=0; i<N; i++) {\n            cur = appendInt(cur, add[i]);\n        }\n        return cur;\n    }\n\n    PackageInfo generatePackageInfo(PackageParser.Package p, int flags) {\n        final PackageSetting ps = (PackageSetting)p.mExtras;\n        if (ps == null) {\n            return null;\n        }\n        final GrantedPermissions gp = ps.sharedUser != null ? ps.sharedUser : ps;\n        return PackageParser.generatePackageInfo(p, gp.gids, flags);\n    }\n\n    public PackageInfo getPackageInfo(String packageName, int flags) {\n        synchronized (mPackages) {\n            PackageParser.Package p = mPackages.get(packageName);\n            if (Config.LOGV) Log.v(\n                TAG, "getApplicationInfo " + packageName\n                + ": " + p);\n            if (p != null) {\n                return generatePackageInfo(p, flags);\n            }\n        }\n        return null;\n    }\n\n    public int getPackageUid(String packageName) {\n        synchronized (mPackages) {\n            PackageParser.Package p = mPackages.get(packageName);\n            return p != null ? p.applicationInfo.uid : -1;\n        }\n    }\n\n    public int[] getPackageGids(String packageName) {\n        synchronized (mPackages) {\n            PackageParser.Package p = mPackages.get(packageName);\n            if (Config.LOGV) Log.v(\n                TAG, "getApplicationInfo " + packageName\n                + ": " + p);\n            if (p != null) {\n                final PackageSetting ps = (PackageSetting)p.mExtras;\n                final SharedUserSetting suid = ps.sharedUser;\n                return suid != null ? suid.gids : ps.gids;\n            }\n        }\n        // stupid thing to indicate an error.\n        return new int[0];\n    }\n\n    public PermissionInfo getPermissionInfo(String name, int flags) {\n        synchronized (mPackages) {\n            final BasePermission p = mSettings.mPermissions.get(name);\n            if (p != null && p.perm != null) {\n                return PackageParser.generatePermissionInfo(p.perm, flags);\n            }\n            return null;\n        }\n    }\n\n    public List<PermissionInfo> queryPermissionsByGroup(String group, int flags) {\n        synchronized (mPackages) {\n            ArrayList<PermissionInfo> out = new ArrayList<PermissionInfo>(10);\n            for (BasePermission p : mSettings.mPermissions.values()) {\n                if (group == null) {\n                    if (p.perm.info.group == null) {\n                        out.add(PackageParser.generatePermissionInfo(p.perm, flags));\n                    }\n                } else {\n                    if (group.equals(p.perm.info.group)) {\n                        out.add(PackageParser.generatePermissionInfo(p.perm, flags));\n                    }\n                }\n            }\n            \n            if (out.size() > 0) {\n                return out;\n            }\n            return mPermissionGroups.containsKey(group) ? out : null;\n        }\n    }\n    \n    public PermissionGroupInfo getPermissionGroupInfo(String name, int flags) {\n        synchronized (mPackages) {\n            return PackageParser.generatePermissionGroupInfo(\n                    mPermissionGroups.get(name), flags);\n        }\n    }\n\n    public List<PermissionGroupInfo> getAllPermissionGroups(int flags) {\n        synchronized (mPackages) {\n            final int N = mPermissionGroups.size();\n            ArrayList<PermissionGroupInfo> out\n                    = new ArrayList<PermissionGroupInfo>(N);\n            for (PackageParser.PermissionGroup pg : mPermissionGroups.values()) {\n                out.add(PackageParser.generatePermissionGroupInfo(pg, flags));\n            }\n            return out;\n        }\n    }\n    \n    public ApplicationInfo getApplicationInfo(String packageName, int flags) {\n        synchronized (mPackages) {\n            PackageParser.Package p = mPackages.get(packageName);\n            if (Config.LOGV) Log.v(\n                TAG, "getApplicationInfo " + packageName\n                + ": " + p);\n            if (p != null) {\n                // Note: isEnabledLP() does not apply here - always return info\n                return PackageParser.generateApplicationInfo(p, flags);\n            }\n            if ("android".equals(packageName)||"system".equals(packageName)) {\n                return mAndroidApplication;\n            }\n        }\n        return null;\n    }\n    \n    public void freeApplicationCache(final long freeStorageSize, final IPackageDataObserver observer) {\n        mContext.enforceCallingOrSelfPermission(\n                android.Manifest.permission.CLEAR_APP_CACHE, null);\n        // Queue up an async operation since clearing cache may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                boolean succeded = true;\n                if (mInstaller != null) {\n                    int retCode = mInstaller.freeCache(freeStorageSize);\n                    if (retCode < 0) {\n                        Log.w(TAG, "Couldn't clear application caches");\n                        succeded = false;\n                    } \n                } //end if mInstaller\n                if(observer != null) {\n                    try {\n                        observer.onRemoveCompleted(null, succeded);\n                    } catch (RemoteException e) {\n                        Log.i(TAG, "Observer no longer exists.");\n                    }\n                } //end if observer\n            } //end run\n        });\n    }\n\n    public ActivityInfo getActivityInfo(ComponentName component, int flags) {\n        synchronized (mPackages) {\n            PackageParser.Activity a = mActivities.mActivities.get(component);\n            if (Config.LOGV) Log.v(\n                TAG, "getActivityInfo " + component + ": " + a);\n            if (a != null && mSettings.isEnabledLP(a.info, flags)) {\n                return PackageParser.generateActivityInfo(a, flags);\n            }\n            if (mResolveComponentName.equals(component)) {\n                return mResolveActivity;\n            }\n        }\n        return null;\n    }\n\n    public ActivityInfo getReceiverInfo(ComponentName component, int flags) {\n        synchronized (mPackages) {\n            PackageParser.Activity a = mReceivers.mActivities.get(component);\n            if (Config.LOGV) Log.v(\n                TAG, "getReceiverInfo " + component + ": " + a);\n            if (a != null && mSettings.isEnabledLP(a.info, flags)) {\n                return PackageParser.generateActivityInfo(a, flags);\n            }\n        }\n        return null;\n    }\n\n    public ServiceInfo getServiceInfo(ComponentName component, int flags) {\n        synchronized (mPackages) {\n            PackageParser.Service s = mServices.mServices.get(component);\n            if (Config.LOGV) Log.v(\n                TAG, "getServiceInfo " + component + ": " + s);\n            if (s != null && mSettings.isEnabledLP(s.info, flags)) {\n                return PackageParser.generateServiceInfo(s, flags);\n            }\n        }\n        return null;\n    }\n\n    public int checkPermission(String permName, String pkgName) {\n        synchronized (mPackages) {\n            PackageParser.Package p = mPackages.get(pkgName);\n            if (p != null && p.mExtras != null) {\n                PackageSetting ps = (PackageSetting)p.mExtras;\n                if (ps.sharedUser != null) {\n                    if (ps.sharedUser.grantedPermissions.contains(permName)) {\n                        return PackageManager.PERMISSION_GRANTED;\n                    }\n                } else if (ps.grantedPermissions.contains(permName)) {\n                    return PackageManager.PERMISSION_GRANTED;\n                }\n            }\n        }\n        return PackageManager.PERMISSION_DENIED;\n    }\n\n    public int checkUidPermission(String permName, int uid) {\n        synchronized (mPackages) {\n            Object obj = mSettings.getUserIdLP(uid);\n            if (obj != null) {\n                if (obj instanceof SharedUserSetting) {\n                    SharedUserSetting sus = (SharedUserSetting)obj;\n                    if (sus.grantedPermissions.contains(permName)) {\n                        return PackageManager.PERMISSION_GRANTED;\n                    }\n                } else if (obj instanceof PackageSetting) {\n                    PackageSetting ps = (PackageSetting)obj;\n                    if (ps.grantedPermissions.contains(permName)) {\n                        return PackageManager.PERMISSION_GRANTED;\n                    }\n                }\n            } else {\n                HashSet<String> perms = mSystemPermissions.get(uid);\n                if (perms != null && perms.contains(permName)) {\n                    return PackageManager.PERMISSION_GRANTED;\n                }\n            }\n        }\n        return PackageManager.PERMISSION_DENIED;\n    }\n\n    private BasePermission findPermissionTreeLP(String permName) {\n        for(BasePermission bp : mSettings.mPermissionTrees.values()) {\n            if (permName.startsWith(bp.name) &&\n                    permName.length() > bp.name.length() &&\n                    permName.charAt(bp.name.length()) == '.') {\n                return bp;\n            }\n        }\n        return null;\n    }\n\n    private BasePermission checkPermissionTreeLP(String permName) {\n        if (permName != null) {\n            BasePermission bp = findPermissionTreeLP(permName);\n            if (bp != null) {\n                if (bp.uid == Binder.getCallingUid()) {\n                    return bp;\n                }\n                throw new SecurityException("Calling uid "\n                        + Binder.getCallingUid()\n                        + " is not allowed to add to permission tree "\n                        + bp.name + " owned by uid " + bp.uid);\n            }\n        }\n        throw new SecurityException("No permission tree found for " + permName);\n    }\n\n    public boolean addPermission(PermissionInfo info) {\n        synchronized (mPackages) {\n            if (info.labelRes == 0 && info.nonLocalizedLabel == null) {\n                throw new SecurityException("Label must be specified in permission");\n            }\n            BasePermission tree = checkPermissionTreeLP(info.name);\n            BasePermission bp = mSettings.mPermissions.get(info.name);\n            boolean added = bp == null;\n            if (added) {\n                bp = new BasePermission(info.name, tree.sourcePackage,\n                        BasePermission.TYPE_DYNAMIC);\n            } else if (bp.type != BasePermission.TYPE_DYNAMIC) {\n                throw new SecurityException(\n                        "Not allowed to modify non-dynamic permission "\n                        + info.name);\n            }\n            bp.perm = new PackageParser.Permission(tree.perm.owner,\n                    new PermissionInfo(info));\n            bp.perm.info.packageName = tree.perm.info.packageName;\n            bp.uid = tree.uid;\n            if (added) {\n                mSettings.mPermissions.put(info.name, bp);\n            }\n            mSettings.writeLP();\n            return added;\n        }\n    }\n\n    public void removePermission(String name) {\n        synchronized (mPackages) {\n            checkPermissionTreeLP(name);\n            BasePermission bp = mSettings.mPermissions.get(name);\n            if (bp != null) {\n                if (bp.type != BasePermission.TYPE_DYNAMIC) {\n                    throw new SecurityException(\n                            "Not allowed to modify non-dynamic permission "\n                            + name);\n                }\n                mSettings.mPermissions.remove(name);\n                mSettings.writeLP();\n            }\n        }\n    }\n\n    public int checkSignatures(String pkg1, String pkg2) {\n        synchronized (mPackages) {\n            PackageParser.Package p1 = mPackages.get(pkg1);\n            PackageParser.Package p2 = mPackages.get(pkg2);\n            if (p1 == null || p1.mExtras == null\n                    || p2 == null || p2.mExtras == null) {\n                return PackageManager.SIGNATURE_UNKNOWN_PACKAGE;\n            }\n            return checkSignaturesLP(p1, p2);\n        }\n    }\n\n    int checkSignaturesLP(PackageParser.Package p1, PackageParser.Package p2) {\n        if (p1.mSignatures == null) {\n            return p2.mSignatures == null\n                    ? PackageManager.SIGNATURE_NEITHER_SIGNED\n                    : PackageManager.SIGNATURE_FIRST_NOT_SIGNED;\n        }\n        if (p2.mSignatures == null) {\n            return PackageManager.SIGNATURE_SECOND_NOT_SIGNED;\n        }\n        final int N1 = p1.mSignatures.length;\n        final int N2 = p2.mSignatures.length;\n        for (int i=0; i<N1; i++) {\n            boolean match = false;\n            for (int j=0; j<N2; j++) {\n                if (p1.mSignatures[i].equals(p2.mSignatures[j])) {\n                    match = true;\n                    break;\n                }\n            }\n            if (!match) {\n                return PackageManager.SIGNATURE_NO_MATCH;\n            }\n        }\n        return PackageManager.SIGNATURE_MATCH;\n    }\n\n    public String[] getPackagesForUid(int uid) {\n        synchronized (mPackages) {\n            Object obj = mSettings.getUserIdLP(uid);\n            if (obj instanceof SharedUserSetting) {\n                SharedUserSetting sus = (SharedUserSetting)obj;\n                final int N = sus.packages.size();\n                String[] res = new String[N];\n                Iterator<PackageSetting> it = sus.packages.iterator();\n                int i=0;\n                while (it.hasNext()) {\n                    res[i++] = it.next().name;\n                }\n                return res;\n            } else if (obj instanceof PackageSetting) {\n                PackageSetting ps = (PackageSetting)obj;\n                return new String[] { ps.name };\n            }\n        }\n        return null;\n    }\n\n    public String getNameForUid(int uid) {\n        synchronized (mPackages) {\n            Object obj = mSettings.getUserIdLP(uid);\n            if (obj instanceof SharedUserSetting) {\n                SharedUserSetting sus = (SharedUserSetting)obj;\n                return sus.name + ":" + sus.userId;\n            } else if (obj instanceof PackageSetting) {\n                PackageSetting ps = (PackageSetting)obj;\n                return ps.name;\n            }\n        }\n        return null;\n    }\n\n    public ResolveInfo resolveIntent(Intent intent, String resolvedType,\n            int flags) {\n        List<ResolveInfo> query = queryIntentActivities(intent, resolvedType, flags);\n        if (query != null) {\n            final int N = query.size();\n            if (N == 1) {\n                return query.get(0);\n            } else if (N > 1) {\n                // If there is more than one activity with the same priority,\n                // then let the user decide between them.\n                ResolveInfo r0 = query.get(0);\n                ResolveInfo r1 = query.get(1);\n                if (false) {\n                    System.out.println(r0.activityInfo.name +\n                                       "=" + r0.priority + " vs " +\n                                       r1.activityInfo.name +\n                                       "=" + r1.priority);\n                }\n                // If the first activity has a higher priority, or a different\n                // default, then it is always desireable to pick it.\n                if (r0.priority != r1.priority\n                        || r0.preferredOrder != r1.preferredOrder\n                        || r0.isDefault != r1.isDefault) {\n                    return query.get(0);\n                }\n                // If we have saved a preference for a preferred activity for\n                // this Intent, use that.\n                ResolveInfo ri = findPreferredActivity(intent, resolvedType,\n                        flags, query, r0.priority);\n                if (ri != null) {\n                    return ri;\n                }\n                return mResolveInfo;\n            }\n        }\n        return null;\n    }\n\n    ResolveInfo findPreferredActivity(Intent intent, String resolvedType,\n            int flags, List<ResolveInfo> query, int priority) {\n        synchronized (mPackages) {\n            if (DEBUG_PREFERRED) intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);\n            List<PreferredActivity> prefs =\n                    mSettings.mPreferredActivities.queryIntent(null,\n                            intent, resolvedType,\n                            (flags&PackageManager.MATCH_DEFAULT_ONLY) != 0);\n            if (prefs != null && prefs.size() > 0) {\n                // First figure out how good the original match set is.\n                // We will only allow preferred activities that came\n                // from the same match quality.\n                int match = 0;\n                final int N = query.size();\n                if (DEBUG_PREFERRED) Log.v(TAG, "Figuring out best match...");\n                for (int j=0; j<N; j++) {\n                    ResolveInfo ri = query.get(j);\n                    if (DEBUG_PREFERRED) Log.v(TAG, "Match for " + ri.activityInfo\n                            + ": 0x" + Integer.toHexString(match));\n                    if (ri.match > match) match = ri.match;\n                }\n                if (DEBUG_PREFERRED) Log.v(TAG, "Best match: 0x"\n                        + Integer.toHexString(match));\n                match &= IntentFilter.MATCH_CATEGORY_MASK;\n                final int M = prefs.size();\n                for (int i=0; i<M; i++) {\n                    PreferredActivity pa = prefs.get(i);\n                    if (pa.mMatch != match) {\n                        continue;\n                    }\n                    ActivityInfo ai = getActivityInfo(pa.mActivity, flags);\n                    if (DEBUG_PREFERRED) {\n                        Log.v(TAG, "Got preferred activity:");\n                        ai.dump(new LogPrinter(Log.INFO, TAG), "  ");\n                    }\n                    if (ai != null) {\n                        for (int j=0; j<N; j++) {\n                            ResolveInfo ri = query.get(j);\n                            if (!ri.activityInfo.applicationInfo.packageName\n                                    .equals(ai.applicationInfo.packageName)) {\n                                continue;\n                            }\n                            if (!ri.activityInfo.name.equals(ai.name)) {\n                                continue;\n                            }\n\n                            // Okay we found a previously set preferred app.\n                            // If the result set is different from when this\n                            // was created, we need to clear it and re-ask the\n                            // user their preference.\n                            if (!pa.sameSet(query, priority)) {\n                                Log.i(TAG, "Result set changed, dropping preferred activity for "\n                                        + intent + " type " + resolvedType);\n                                mSettings.mPreferredActivities.removeFilter(pa);\n                                return null;\n                            }\n\n                            // Yay!\n                            return ri;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    public List<ResolveInfo> queryIntentActivities(Intent intent,\n            String resolvedType, int flags) {\n        ComponentName comp = intent.getComponent();\n        if (comp != null) {\n            List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);\n            ActivityInfo ai = getActivityInfo(comp, flags);\n            if (ai != null) {\n                ResolveInfo ri = new ResolveInfo();\n                ri.activityInfo = ai;\n                list.add(ri);\n            }\n            return list;\n        }\n\n        synchronized (mPackages) {\n            return (List<ResolveInfo>)mActivities.\n                queryIntent(null, intent, resolvedType, flags);\n        }\n    }\n\n    public List<ResolveInfo> queryIntentActivityOptions(ComponentName caller,\n            Intent[] specifics, String[] specificTypes, Intent intent,\n            String resolvedType, int flags) {\n        final String resultsAction = intent.getAction();\n\n        List<ResolveInfo> results = queryIntentActivities(\n            intent, resolvedType, flags|PackageManager.GET_RESOLVED_FILTER);\n        if (Config.LOGV) Log.v(TAG, "Query " + intent + ": " + results);\n\n        int specificsPos = 0;\n        int N;\n\n        // todo: note that the algorithm used here is O(N^2).  This\n        // isn't a problem in our current environment, but if we start running\n        // into situations where we have more than 5 or 10 matches then this\n        // should probably be changed to something smarter...\n\n        // First we go through and resolve each of the specific items\n        // that were supplied, taking care of removing any corresponding\n        // duplicate items in the generic resolve list.\n        if (specifics != null) {\n            for (int i=0; i<specifics.length; i++) {\n                final Intent sintent = specifics[i];\n                if (sintent == null) {\n                    continue;\n                }\n\n                if (Config.LOGV) Log.v(TAG, "Specific #" + i + ": " + sintent);\n                String action = sintent.getAction();\n                if (resultsAction != null && resultsAction.equals(action)) {\n                    // If this action was explicitly requested, then don't\n                    // remove things that have it.\n                    action = null;\n                }\n                ComponentName comp = sintent.getComponent();\n                ResolveInfo ri = null;\n                ActivityInfo ai = null;\n                if (comp == null) {\n                    ri = resolveIntent(\n                        sintent,\n                        specificTypes != null ? specificTypes[i] : null,\n                        flags);\n                    if (ri == null) {\n                        continue;\n                    }\n                    if (ri == mResolveInfo) {\n                        // ACK!  Must do something better with this.\n                    }\n                    ai = ri.activityInfo;\n                    comp = new ComponentName(ai.applicationInfo.packageName,\n                            ai.name);\n                } else {\n                    ai = getActivityInfo(comp, flags);\n                    if (ai == null) {\n                        continue;\n                    }\n                }\n\n                // Look for any generic query activities that are duplicates\n                // of this specific one, and remove them from the results.\n                if (Config.LOGV) Log.v(TAG, "Specific #" + i + ": " + ai);\n                N = results.size();\n                int j;\n                for (j=specificsPos; j<N; j++) {\n                    ResolveInfo sri = results.get(j);\n                    if ((sri.activityInfo.name.equals(comp.getClassName())\n                            && sri.activityInfo.applicationInfo.packageName.equals(\n                                    comp.getPackageName()))\n                        || (action != null && sri.filter.matchAction(action))) {\n                        results.remove(j);\n                        if (Config.LOGV) Log.v(\n                            TAG, "Removing duplicate item from " + j\n                            + " due to specific " + specificsPos);\n                        if (ri == null) {\n                            ri = sri;\n                        }\n                        j--;\n                        N--;\n                    }\n                }\n\n                // Add this specific item to its proper place.\n                if (ri == null) {\n                    ri = new ResolveInfo();\n                    ri.activityInfo = ai;\n                }\n                results.add(specificsPos, ri);\n                ri.specificIndex = i;\n                specificsPos++;\n            }\n        }\n\n        // Now we go through the remaining generic results and remove any\n        // duplicate actions that are found here.\n        N = results.size();\n        for (int i=specificsPos; i<N-1; i++) {\n            final ResolveInfo rii = results.get(i);\n            if (rii.filter == null) {\n                continue;\n            }\n\n            // Iterate over all of the actions of this result's intent\n            // filter...  typically this should be just one.\n            final Iterator<String> it = rii.filter.actionsIterator();\n            if (it == null) {\n                continue;\n            }\n            while (it.hasNext()) {\n                final String action = it.next();\n                if (resultsAction != null && resultsAction.equals(action)) {\n                    // If this action was explicitly requested, then don't\n                    // remove things that have it.\n                    continue;\n                }\n                for (int j=i+1; j<N; j++) {\n                    final ResolveInfo rij = results.get(j);\n                    if (rij.filter != null && rij.filter.hasAction(action)) {\n                        results.remove(j);\n                        if (Config.LOGV) Log.v(\n                            TAG, "Removing duplicate item from " + j\n                            + " due to action " + action + " at " + i);\n                        j--;\n                        N--;\n                    }\n                }\n            }\n\n            // If the caller didn't request filter information, drop it now\n            // so we don't have to marshall/unmarshall it.\n            if ((flags&PackageManager.GET_RESOLVED_FILTER) == 0) {\n                rii.filter = null;\n            }\n        }\n\n        // Filter out the caller activity if so requested.\n        if (caller != null) {\n            N = results.size();\n            for (int i=0; i<N; i++) {\n                ActivityInfo ainfo = results.get(i).activityInfo;\n                if (caller.getPackageName().equals(ainfo.applicationInfo.packageName)\n                        && caller.getClassName().equals(ainfo.name)) {\n                    results.remove(i);\n                    break;\n                }\n            }\n        }\n\n        // If the caller didn't request filter information,\n        // drop them now so we don't have to\n        // marshall/unmarshall it.\n        if ((flags&PackageManager.GET_RESOLVED_FILTER) == 0) {\n            N = results.size();\n            for (int i=0; i<N; i++) {\n                results.get(i).filter = null;\n            }\n        }\n\n        if (Config.LOGV) Log.v(TAG, "Result: " + results);\n        return results;\n    }\n\n    public List<ResolveInfo> queryIntentReceivers(Intent intent,\n            String resolvedType, int flags) {\n        synchronized (mPackages) {\n            return (List<ResolveInfo>)mReceivers.\n                queryIntent(null, intent, resolvedType, flags);\n        }\n    }\n\n    public ResolveInfo resolveService(Intent intent, String resolvedType,\n            int flags) {\n        List<ResolveInfo> query = queryIntentServices(intent, resolvedType,\n                flags);\n        if (query != null) {\n            if (query.size() >= 1) {\n                // If there is more than one service with the same priority,\n                // just arbitrarily pick the first one.\n                return query.get(0);\n            }\n        }\n        return null;\n    }\n\n    public List<ResolveInfo> queryIntentServices(Intent intent,\n            String resolvedType, int flags) {\n        ComponentName comp = intent.getComponent();\n        if (comp != null) {\n            List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);\n            ServiceInfo si = getServiceInfo(comp, flags);\n            if (si != null) {\n                ResolveInfo ri = new ResolveInfo();\n                ri.serviceInfo = si;\n                list.add(ri);\n            }\n            return list;\n        }\n\n        synchronized (mPackages) {\n            return (List<ResolveInfo>)mServices.\n                queryIntent(null, intent, resolvedType, flags);\n        }\n    }\n\n    public List<PackageInfo> getInstalledPackages(int flags) {\n        ArrayList<PackageInfo> finalList = new ArrayList<PackageInfo>();\n\n        synchronized (mPackages) {\n            Iterator<PackageParser.Package> i = mPackages.values().iterator();\n            while (i.hasNext()) {\n                final PackageParser.Package p = i.next();\n                PackageInfo pi = generatePackageInfo(p, flags);\n                if (pi != null) {\n                    finalList.add(pi);\n                }\n            }\n        }\n\n        return finalList;\n    }\n\n    public List<ApplicationInfo> getInstalledApplications(int flags) {\n        ArrayList<ApplicationInfo> finalList = new ArrayList<ApplicationInfo>();\n\n        synchronized (mPackages) {\n            Iterator<PackageParser.Package> i = mPackages.values().iterator();\n            while (i.hasNext()) {\n                final PackageParser.Package p = i.next();\n                if (p.applicationInfo != null) {\n                    finalList.add(p.applicationInfo);\n                }\n            }\n        }\n\n        return finalList;\n    }\n\n    public List<ApplicationInfo> getPersistentApplications(int flags) {\n        ArrayList<ApplicationInfo> finalList = new ArrayList<ApplicationInfo>();\n\n        synchronized (mPackages) {\n            Iterator<PackageParser.Package> i = mPackages.values().iterator();\n            while (i.hasNext()) {\n                PackageParser.Package p = i.next();\n                if (p.applicationInfo != null\n                        && (p.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) != 0\n                        && (!mSafeMode || (p.applicationInfo.flags\n                                &ApplicationInfo.FLAG_SYSTEM) != 0)) {\n                    finalList.add(p.applicationInfo);\n                }\n            }\n        }\n\n        return finalList;\n    }\n\n    public ProviderInfo resolveContentProvider(String name, int flags) {\n        synchronized (mPackages) {\n            final PackageParser.Provider provider = mProviders.get(name);\n            return provider != null\n                    && mSettings.isEnabledLP(provider.info, flags)\n                    && (!mSafeMode || (provider.info.applicationInfo.flags\n                            &ApplicationInfo.FLAG_SYSTEM) != 0)\n                    ? PackageParser.generateProviderInfo(provider, flags)\n                    : null;\n        }\n    }\n\n    public void querySyncProviders(List outNames, List outInfo) {\n        synchronized (mPackages) {\n            Iterator<Map.Entry<String, PackageParser.Provider>> i\n                = mProviders.entrySet().iterator();\n\n            while (i.hasNext()) {\n                Map.Entry<String, PackageParser.Provider> entry = i.next();\n                PackageParser.Provider p = entry.getValue();\n\n                if (p.syncable\n                        && (!mSafeMode || (p.info.applicationInfo.flags\n                                &ApplicationInfo.FLAG_SYSTEM) != 0)) {\n                    outNames.add(entry.getKey());\n                    outInfo.add(PackageParser.generateProviderInfo(p, 0));\n                }\n            }\n        }\n    }\n\n    public List<ProviderInfo> queryContentProviders(String processName,\n            int uid, int flags) {\n        ArrayList<ProviderInfo> finalList = null;\n\n        synchronized (mPackages) {\n            Iterator<PackageParser.Provider> i = mProvidersByComponent.values().iterator();\n            while (i.hasNext()) {\n                PackageParser.Provider p = i.next();\n                if (p.info.authority != null\n                    && (processName == null ||\n                            (p.info.processName.equals(processName)\n                                    && p.info.applicationInfo.uid == uid))\n                    && mSettings.isEnabledLP(p.info, flags)\n                    && (!mSafeMode || (p.info.applicationInfo.flags\n                            &ApplicationInfo.FLAG_SYSTEM) != 0)) {\n                    if (finalList == null) {\n                        finalList = new ArrayList<ProviderInfo>(3);\n                    }\n                    finalList.add(PackageParser.generateProviderInfo(p,\n                            flags));\n                }\n            }\n        }\n\n        if (finalList != null) {\n            Collections.sort(finalList, mProviderInitOrderSorter);\n        }\n\n        return finalList;\n    }\n\n    public InstrumentationInfo getInstrumentationInfo(ComponentName name,\n            int flags) {\n        synchronized (mPackages) {\n            final PackageParser.Instrumentation i = mInstrumentation.get(name);\n            return PackageParser.generateInstrumentationInfo(i, flags);\n        }\n    }\n\n    public List<InstrumentationInfo> queryInstrumentation(String targetPackage,\n            int flags) {\n        ArrayList<InstrumentationInfo> finalList =\n            new ArrayList<InstrumentationInfo>();\n\n        synchronized (mPackages) {\n            Iterator<PackageParser.Instrumentation> i = mInstrumentation.values().iterator();\n            while (i.hasNext()) {\n                PackageParser.Instrumentation p = i.next();\n                if (targetPackage == null\n                        || targetPackage.equals(p.info.targetPackage)) {\n                    finalList.add(PackageParser.generateInstrumentationInfo(p,\n                            flags));\n                }\n            }\n        }\n\n        return finalList;\n    }\n\n    private void scanDirLI(File dir, int flags, int scanMode) {\n        Log.d(TAG, "Scanning app dir " + dir);\n\n        String[] files = dir.list();\n\n        int i;\n        for (i=0; i<files.length; i++) {\n            File file = new File(dir, files[i]);\n            PackageParser.Package pkg = scanPackageLI(file, file, file, \n                    flags|PackageParser.PARSE_MUST_BE_APK, scanMode);\n        }\n    }\n\n    private static void reportSettingsProblem(int priority, String msg) {\n        try {\n            File dataDir = Environment.getDataDirectory();\n            File systemDir = new File(dataDir, "system");\n            File fname = new File(systemDir, "uiderrors.txt");\n            FileOutputStream out = new FileOutputStream(fname, true);\n            PrintWriter pw = new PrintWriter(out);\n            pw.println(msg);\n            pw.close();\n            FileUtils.setPermissions(\n                    fname.toString(),\n                    FileUtils.S_IRWXU|FileUtils.S_IRWXG|FileUtils.S_IROTH,\n                    -1, -1);\n        } catch (java.io.IOException e) {\n        }\n        Log.println(priority, TAG, msg);\n    }\n\n    private boolean collectCertificatesLI(PackageParser pp, PackageSetting ps,\n            PackageParser.Package pkg, File srcFile, int parseFlags) {\n        if (GET_CERTIFICATES) {\n            if (ps == null || !ps.codePath.equals(srcFile)\n                    || ps.timeStamp != srcFile.lastModified()) {\n                Log.i(TAG, srcFile.toString() + " changed; collecting certs");\n                if (!pp.collectCertificates(pkg, parseFlags)) {\n                    mLastScanError = pp.getParseError();\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private PackageParser.Package scanPackageLI(File scanFile,\n            File destCodeFile, File destResourceFile, int parseFlags,\n            int scanMode) {\n        mLastScanError = PackageManager.INSTALL_SUCCEEDED;\n        parseFlags |= mDefParseFlags;\n        PackageParser pp = new PackageParser(scanFile.getPath());\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setSdkVersion(mSdkVersion);\n        final PackageParser.Package pkg = pp.parsePackage(scanFile,\n                destCodeFile.getAbsolutePath(), mMetrics, parseFlags);\n        if (pkg == null) {\n            mLastScanError = pp.getParseError();\n            return null;\n        }\n        PackageSetting ps;\n        synchronized (mPackages) {\n            ps = mSettings.peekPackageLP(pkg.packageName,\n                    scanFile.toString());\n        }\n        if (!collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags)) {\n            return null;\n        }\n        // The apk is forward locked (not public) if its code and resources\n        // are kept in different files.\n        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {\n            scanMode |= SCAN_FORWARD_LOCKED;\n        }\n        return scanPackageLI(scanFile, destCodeFile, destResourceFile,\n                pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE);\n    }\n\n    private static String fixProcessName(String defProcessName,\n            String processName, int uid) {\n        if (processName == null) {\n            return defProcessName;\n        }\n        return processName;\n    }\n\n    private boolean verifySignaturesLP(PackageSetting pkgSetting, \n            PackageParser.Package pkg, int parseFlags, boolean updateSignature) {\n        if (pkg.mSignatures != null) {\n            if (!pkgSetting.signatures.updateSignatures(pkg.mSignatures,\n                   	Divergent Change	God Class\n	Feature Envy\n	Shotgun Surgery\n	PackageManagerService.java\n	9aa0a177fe1900bc8c86e3295a20f74c	\N	Oocorre quando uma classe é alterada de maneiras diferentes por diferentes razões.	WMC (Weighted Method per Class), NCC (Number Concerns per Component), LCOM (Lack of Cohesion in Methods)	Refatoração sugerida: Extract Class	t	3
55	Identifique o Bad Smell na classe abaixo	/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.cassandra.config;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.nio.ByteBuffer;\nimport java.util.*;\n\nimport com.google.common.collect.MapDifference;\nimport com.google.common.collect.Maps;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.apache.cassandra.cql3.CFDefinition;\nimport org.apache.cassandra.cql3.QueryProcessor;\nimport org.apache.cassandra.cql3.UntypedResultSet;\nimport org.apache.cassandra.db.*;\nimport org.apache.cassandra.db.compaction.AbstractCompactionStrategy;\nimport org.apache.cassandra.db.index.SecondaryIndex;\nimport org.apache.cassandra.db.marshal.*;\nimport org.apache.cassandra.io.IColumnSerializer;\nimport org.apache.cassandra.io.compress.CompressionParameters;\nimport org.apache.cassandra.io.compress.SnappyCompressor;\nimport org.apache.cassandra.thrift.CfDef;\nimport org.apache.cassandra.thrift.IndexType;\nimport org.apache.cassandra.thrift.InvalidRequestException;\nimport org.apache.cassandra.utils.ByteBufferUtil;\nimport org.apache.cassandra.utils.FBUtilities;\n\nimport static org.apache.cassandra.utils.FBUtilities.*;\n\npublic final class CFMetaData\n{\n    //\n    // !! Important !!\n    // This class can be tricky to modify.  Please read http://wiki.apache.org/cassandra/ConfigurationNotes\n    // for how to do so safely.\n    //\n\n    private static Logger logger = LoggerFactory.getLogger(CFMetaData.class);\n\n    public final static double DEFAULT_READ_REPAIR_CHANCE = 0.1;\n    public final static double DEFAULT_DCLOCAL_READ_REPAIR_CHANCE = 0.0;\n    public final static boolean DEFAULT_REPLICATE_ON_WRITE = true;\n    public final static int DEFAULT_GC_GRACE_SECONDS = 864000;\n    public final static int DEFAULT_MIN_COMPACTION_THRESHOLD = 4;\n    public final static int DEFAULT_MAX_COMPACTION_THRESHOLD = 32;\n    public final static String DEFAULT_COMPACTION_STRATEGY_CLASS = "SizeTieredCompactionStrategy";\n    public final static ByteBuffer DEFAULT_KEY_NAME = ByteBufferUtil.bytes("KEY");\n    public final static Caching DEFAULT_CACHING_STRATEGY = Caching.KEYS_ONLY;\n    public final static Double DEFAULT_BF_FP_CHANCE = null;\n\n    // Note that this is the default only for user created tables\n    public final static String DEFAULT_COMPRESSOR = SnappyCompressor.isAvailable() ? SnappyCompressor.class.getCanonicalName() : null;\n\n    public static final CFMetaData StatusCf = newSystemMetadata(SystemTable.STATUS_CF, 0, "persistent metadata for the local node", BytesType.instance, null);\n    public static final CFMetaData HintsCf = newSystemMetadata(HintedHandOffManager.HINTS_CF, 1, "hinted handoff data", BytesType.instance, BytesType.instance);\n    @Deprecated\n    public static final CFMetaData MigrationsCf = newSystemMetadata(DefsTable.OLD_MIGRATIONS_CF, 2, "individual schema mutations", TimeUUIDType.instance, null);\n    @Deprecated\n    public static final CFMetaData SchemaCf = newSystemMetadata(DefsTable.OLD_SCHEMA_CF, 3, "current state of the schema", UTF8Type.instance, null);\n    public static final CFMetaData IndexCf = newSystemMetadata(SystemTable.INDEX_CF, 5, "indexes that have been completed", UTF8Type.instance, null);\n    public static final CFMetaData NodeIdCf = newSystemMetadata(SystemTable.NODE_ID_CF, 6, "nodeId and their metadata", TimeUUIDType.instance, null);\n    public static final CFMetaData VersionCf =\n            newSystemMetadata(SystemTable.VERSION_CF, 7, "server version information", UTF8Type.instance, null)\n            .keyAlias(ByteBufferUtil.bytes("component"))\n            .keyValidator(UTF8Type.instance)\n            .columnMetadata(Collections.singletonMap(ByteBufferUtil.bytes("version"),\n                                                     new ColumnDefinition(ByteBufferUtil.bytes("version"),\n                                                                          UTF8Type.instance,\n                                                                          null,\n                                                                          null,\n                                                                          null,\n                                                                          null)));\n\n    // new-style schema\n    public static final CFMetaData SchemaKeyspacesCf;\n    public static final CFMetaData SchemaColumnFamiliesCf;\n    public static final CFMetaData SchemaColumnsCf;\n    static\n    {\n        SchemaKeyspacesCf = newSchemaMetadata(SystemTable.SCHEMA_KEYSPACES_CF,\n                                              8,\n                                              "Keyspace definitions",\n                                              AsciiType.instance,\n                                              null)\n                            .keyValidator(AsciiType.instance)\n                            .keyAlias("keyspace")\n                            .columnMetadata(ColumnDefinition.utf8("name", null),\n                                            ColumnDefinition.bool("durable_writes", null),\n                                            ColumnDefinition.ascii("strategy_class", null),\n                                            ColumnDefinition.ascii("strategy_options", null));\n\n        SchemaColumnFamiliesCf = newSchemaMetadata(SystemTable.SCHEMA_COLUMNFAMILIES_CF,\n                                                   9,\n                                                   "ColumnFamily definitions",\n                                                   CompositeType.getInstance(Arrays.<AbstractType<?>>asList(AsciiType.instance, AsciiType.instance)),\n                                                   null)\n                                 .keyValidator(AsciiType.instance)\n                                 .keyAlias("keyspace")\n                                 .columnAliases(Arrays.asList(ByteBufferUtil.bytes("columnfamily")))\n                                 .columnMetadata(ColumnDefinition.int32("id", 1),\n                                                 ColumnDefinition.ascii("type", 1),\n                                                 ColumnDefinition.ascii("comparator", 1),\n                                                 ColumnDefinition.ascii("subcomparator", 1),\n                                                 ColumnDefinition.utf8("comment", 1),\n                                                 ColumnDefinition.double_("read_repair_chance", 1),\n                                                 ColumnDefinition.double_("local_read_repair_chance", 1),\n                                                 ColumnDefinition.bool("replicate_on_write", 1),\n                                                 ColumnDefinition.int32("gc_grace_seconds", 1),\n                                                 ColumnDefinition.ascii("default_validator", 1),\n                                                 ColumnDefinition.ascii("key_validator", 1),\n                                                 ColumnDefinition.int32("min_compaction_threshold", 1),\n                                                 ColumnDefinition.int32("max_compaction_threshold", 1),\n                                                 ColumnDefinition.ascii("key_alias", 1),\n                                                 ColumnDefinition.double_("bloom_filter_fp_chance", 1),\n                                                 ColumnDefinition.ascii("caching", 1),\n                                                 ColumnDefinition.ascii("compaction_strategy_class", 1),\n                                                 ColumnDefinition.ascii("compression_parameters", 1),\n                                                 ColumnDefinition.utf8("value_alias", 1),\n                                                 ColumnDefinition.utf8("column_aliases", 1),\n                                                 ColumnDefinition.ascii("compaction_strategy_options", 1));\n\n        SchemaColumnsCf = newSchemaMetadata(SystemTable.SCHEMA_COLUMNS_CF,\n                                            10,\n                                            "ColumnFamily column attributes",\n                                            CompositeType.getInstance(Arrays.<AbstractType<?>>asList(AsciiType.instance,\n                                                                                                     AsciiType.instance,\n                                                                                                     AsciiType.instance)),\n                                            null)\n                          .keyValidator(AsciiType.instance)\n                          .keyAlias("keyspace")\n                          .columnAliases(Arrays.asList(ByteBufferUtil.bytes("columnfamily"), ByteBufferUtil.bytes("column")))\n                          .columnMetadata(ColumnDefinition.ascii("validator", 2),\n                                          ColumnDefinition.ascii("index_type", 2),\n                                          ColumnDefinition.ascii("index_options", 2),\n                                          ColumnDefinition.ascii("index_name", 2),\n                                          ColumnDefinition.ascii("component_index", 2));\n    }\n\n    public enum Caching\n    {\n        ALL, KEYS_ONLY, ROWS_ONLY, NONE;\n\n        public static Caching fromString(String cache) throws ConfigurationException\n        {\n            try\n            {\n                return valueOf(cache.toUpperCase());\n            }\n            catch (IllegalArgumentException e)\n            {\n                throw new ConfigurationException(String.format("%s not found, available types: %s.", cache, StringUtils.join(values(), ", ")));\n            }\n        }\n    }\n\n    //REQUIRED\n    public final Integer cfId;                        // internal id, never exposed to user\n    public final String ksName;                       // name of keyspace\n    public final String cfName;                       // name of this column family\n    public final ColumnFamilyType cfType;             // standard, super\n    public AbstractType<?> comparator;          // bytes, long, timeuuid, utf8, etc.\n    public AbstractType<?> subcolumnComparator; // like comparator, for supercolumns\n\n    //OPTIONAL\n    private String comment;                           // default none, for humans only\n    private double readRepairChance;                  // default 1.0 (always), chance [0.0,1.0] of read repair\n    private double dcLocalReadRepairChance;           // default 0.0\n    private boolean replicateOnWrite;                 // default false\n    private int gcGraceSeconds;                       // default 864000 (ten days)\n    private AbstractType<?> defaultValidator;         // default BytesType (no-op), use comparator types\n    private AbstractType<?> keyValidator;             // default BytesType (no-op), use comparator types\n    private int minCompactionThreshold;               // default 4\n    private int maxCompactionThreshold;               // default 32\n    private ByteBuffer keyAlias;                      // default NULL\n    private List<ByteBuffer> columnAliases = new ArrayList<ByteBuffer>();\n    private ByteBuffer valueAlias;                    // default NULL\n    private Double bloomFilterFpChance;               // default NULL\n    private Caching caching;                          // default KEYS_ONLY (possible: all, key_only, row_only, none)\n\n    Map<ByteBuffer, ColumnDefinition> column_metadata;\n    public Class<? extends AbstractCompactionStrategy> compactionStrategyClass;\n    public Map<String, String> compactionStrategyOptions;\n\n    public CompressionParameters compressionParameters;\n\n    // Processed infos used by CQL. This can be fully reconstructed from the CFMedata,\n    // so it's not saved on disk. It is however costlyish to recreate for each query\n    // so we cache it here (and update on each relevant CFMetadata change)\n    private CFDefinition cqlCfDef;\n\n    public CFMetaData comment(String prop) { comment = enforceCommentNotNull(prop); return this;}\n    public CFMetaData readRepairChance(double prop) {readRepairChance = prop; return this;}\n    public CFMetaData dcLocalReadRepairChance(double prop) {dcLocalReadRepairChance = prop; return this;}\n    public CFMetaData replicateOnWrite(boolean prop) {replicateOnWrite = prop; return this;}\n    public CFMetaData gcGraceSeconds(int prop) {gcGraceSeconds = prop; return this;}\n    public CFMetaData defaultValidator(AbstractType<?> prop) {defaultValidator = prop; updateCfDef(); return this;}\n    public CFMetaData keyValidator(AbstractType<?> prop) {keyValidator = prop; updateCfDef(); return this;}\n    public CFMetaData minCompactionThreshold(int prop) {minCompactionThreshold = prop; return this;}\n    public CFMetaData maxCompactionThreshold(int prop) {maxCompactionThreshold = prop; return this;}\n    public CFMetaData keyAlias(ByteBuffer prop) {keyAlias = prop; updateCfDef(); return this;}\n    public CFMetaData keyAlias(String alias) { return keyAlias(ByteBufferUtil.bytes(alias)); }\n    public CFMetaData columnAliases(List<ByteBuffer> prop) {columnAliases = prop; updateCfDef(); return this;}\n    public CFMetaData valueAlias(ByteBuffer prop) {valueAlias = prop; updateCfDef(); return this;}\n    public CFMetaData columnMetadata(Map<ByteBuffer,ColumnDefinition> prop) {column_metadata = prop; updateCfDef(); return this;}\n    public CFMetaData columnMetadata(ColumnDefinition... cds)\n    {\n        Map<ByteBuffer, ColumnDefinition> map = new HashMap<ByteBuffer, ColumnDefinition>();\n        for (ColumnDefinition cd : cds)\n            map.put(cd.name, cd);\n\n        return columnMetadata(map);\n    }\n    public CFMetaData compactionStrategyClass(Class<? extends AbstractCompactionStrategy> prop) {compactionStrategyClass = prop; return this;}\n    public CFMetaData compactionStrategyOptions(Map<String, String> prop) {compactionStrategyOptions = prop; return this;}\n    public CFMetaData compressionParameters(CompressionParameters prop) {compressionParameters = prop; return this;}\n    public CFMetaData bloomFilterFpChance(Double prop) {bloomFilterFpChance = prop; return this;}\n    public CFMetaData caching(Caching prop) {caching = prop; return this;}\n\n    public CFMetaData(String keyspace, String name, ColumnFamilyType type, AbstractType<?> comp, AbstractType<?> subcc)\n    {\n        this(keyspace, name, type, comp, subcc, Schema.instance.nextCFId());\n    }\n\n    CFMetaData(String keyspace, String name, ColumnFamilyType type, AbstractType<?> comp, AbstractType<?> subcc, int id)\n    {\n        // Final fields must be set in constructor\n        ksName = keyspace;\n        cfName = name;\n        cfType = type;\n        comparator = comp;\n        subcolumnComparator = enforceSubccDefault(type, subcc);\n\n        // System cfs have specific ids, and copies of old CFMDs need\n        //  to copy over the old id.\n        cfId = id;\n\n        this.init();\n    }\n\n    private AbstractType<?> enforceSubccDefault(ColumnFamilyType cftype, AbstractType<?> subcc)\n    {\n        return (subcc == null) && (cftype == ColumnFamilyType.Super) ? BytesType.instance : subcc;\n    }\n\n    private static String enforceCommentNotNull (CharSequence comment)\n    {\n        return (comment == null) ? "" : comment.toString();\n    }\n\n    private void init()\n    {\n        // Set a bunch of defaults\n        readRepairChance             = DEFAULT_READ_REPAIR_CHANCE;\n        dcLocalReadRepairChance      = DEFAULT_DCLOCAL_READ_REPAIR_CHANCE;\n        replicateOnWrite             = DEFAULT_REPLICATE_ON_WRITE;\n        gcGraceSeconds               = DEFAULT_GC_GRACE_SECONDS;\n        minCompactionThreshold       = DEFAULT_MIN_COMPACTION_THRESHOLD;\n        maxCompactionThreshold       = DEFAULT_MAX_COMPACTION_THRESHOLD;\n        caching                      = DEFAULT_CACHING_STRATEGY;\n        bloomFilterFpChance          = DEFAULT_BF_FP_CHANCE;\n\n        // Defaults strange or simple enough to not need a DEFAULT_T for\n        defaultValidator = BytesType.instance;\n        keyValidator = BytesType.instance;\n        comment = "";\n        keyAlias = null; // This qualifies as a 'strange default'.\n        valueAlias = null;\n        column_metadata = new HashMap<ByteBuffer,ColumnDefinition>();\n\n        try\n        {\n            compactionStrategyClass = createCompactionStrategy(DEFAULT_COMPACTION_STRATEGY_CLASS);\n        }\n        catch (ConfigurationException e)\n        {\n            throw new AssertionError(e);\n        }\n        compactionStrategyOptions = new HashMap<String, String>();\n\n        compressionParameters = new CompressionParameters(null);\n        updateCfDef(); // init cqlCfDef\n    }\n\n    private static CFMetaData newSystemMetadata(String cfName, int cfId, String comment, AbstractType<?> comparator, AbstractType<?> subcc)\n    {\n        ColumnFamilyType type = subcc == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super;\n        CFMetaData newCFMD = new CFMetaData(Table.SYSTEM_TABLE, cfName, type, comparator,  subcc, cfId);\n\n        return newCFMD.comment(comment)\n                      .readRepairChance(0)\n                      .dcLocalReadRepairChance(0)\n                      .gcGraceSeconds(0);\n    }\n\n    private static CFMetaData newSchemaMetadata(String cfName, int cfId, String comment, AbstractType<?> comparator, AbstractType<?> subcc)\n    {\n        /*\n         * Schema column families needs a gc_grace (since they are replicated\n         * on every node). That gc_grace should be high enough that no node\n         * could be dead for that long a time.\n         */\n        int gcGrace = 120 * 24 * 3600; // 3 months\n        return newSystemMetadata(cfName, cfId, comment, comparator, subcc).gcGraceSeconds(gcGrace);\n    }\n\n    public static CFMetaData newIndexMetadata(CFMetaData parent, ColumnDefinition info, AbstractType<?> columnComparator)\n    {\n        // Depends on parent's cache setting, turn on its index CF's cache.\n        // Here, only key cache is enabled, but later (in KeysIndex) row cache will be turned on depending on cardinality.\n        Caching indexCaching = parent.getCaching() == Caching.ALL || parent.getCaching() == Caching.KEYS_ONLY\n                             ? Caching.KEYS_ONLY\n                             : Caching.NONE;\n\n        return new CFMetaData(parent.ksName, parent.indexColumnFamilyName(info), ColumnFamilyType.Standard, columnComparator, null)\n                             .keyValidator(info.getValidator())\n                             .readRepairChance(0.0)\n                             .dcLocalReadRepairChance(0.0)\n                             .gcGraceSeconds(0)\n                             .caching(indexCaching)\n                             .compactionStrategyClass(parent.compactionStrategyClass)\n                             .compactionStrategyOptions(parent.compactionStrategyOptions)\n                             .reloadSecondaryIndexMetadata(parent);\n    }\n\n    public CFMetaData reloadSecondaryIndexMetadata(CFMetaData parent)\n    {\n        minCompactionThreshold(parent.minCompactionThreshold);\n        maxCompactionThreshold(parent.maxCompactionThreshold);\n        compactionStrategyClass(parent.compactionStrategyClass);\n        compactionStrategyOptions(parent.compactionStrategyOptions);\n        compressionParameters(parent.compressionParameters);\n        return this;\n    }\n\n    public CFMetaData clone()\n    {\n        return copyOpts(new CFMetaData(ksName, cfName, cfType, comparator, subcolumnComparator, cfId), this);\n    }\n\n    // Create a new CFMD by changing just the cfName\n    public static CFMetaData rename(CFMetaData cfm, String newName)\n    {\n        return copyOpts(new CFMetaData(cfm.ksName, newName, cfm.cfType, cfm.comparator, cfm.subcolumnComparator, cfm.cfId), cfm);\n    }\n\n    static CFMetaData copyOpts(CFMetaData newCFMD, CFMetaData oldCFMD)\n    {\n        Map<ByteBuffer, ColumnDefinition> clonedColumns = new HashMap<ByteBuffer, ColumnDefinition>();\n        for (ColumnDefinition cd : oldCFMD.column_metadata.values())\n        {\n            ColumnDefinition cloned = cd.clone();\n            clonedColumns.put(cloned.name, cloned);\n        }\n        return newCFMD.comment(oldCFMD.comment)\n                      .readRepairChance(oldCFMD.readRepairChance)\n                      .dcLocalReadRepairChance(oldCFMD.dcLocalReadRepairChance)\n                      .replicateOnWrite(oldCFMD.replicateOnWrite)\n                      .gcGraceSeconds(oldCFMD.gcGraceSeconds)\n                      .defaultValidator(oldCFMD.defaultValidator)\n                      .keyValidator(oldCFMD.keyValidator)\n                      .minCompactionThreshold(oldCFMD.minCompactionThreshold)\n                      .maxCompactionThreshold(oldCFMD.maxCompactionThreshold)\n                      .keyAlias(oldCFMD.keyAlias)\n                      .columnAliases(new ArrayList<ByteBuffer>(oldCFMD.columnAliases))\n                      .valueAlias(oldCFMD.valueAlias)\n                      .columnMetadata(clonedColumns)\n                      .compactionStrategyClass(oldCFMD.compactionStrategyClass)\n                      .compactionStrategyOptions(oldCFMD.compactionStrategyOptions)\n                      .compressionParameters(oldCFMD.compressionParameters)\n                      .bloomFilterFpChance(oldCFMD.bloomFilterFpChance)\n                      .caching(oldCFMD.caching);\n    }\n\n    /**\n     * generate a column family name for an index corresponding to the given column.\n     * This is NOT the same as the index's name! This is only used in sstable filenames and is not exposed to users.\n     *\n     * @param info A definition of the column with index\n     *\n     * @return name of the index ColumnFamily\n     */\n    public String indexColumnFamilyName(ColumnDefinition info)\n    {\n        // TODO simplify this when info.index_name is guaranteed to be set\n        return cfName + Directories.SECONDARY_INDEX_NAME_SEPARATOR + (info.getIndexName() == null ? ByteBufferUtil.bytesToHex(info.name) : info.getIndexName());\n    }\n\n    public String getComment()\n    {\n        return comment;\n    }\n\n    public double getReadRepairChance()\n    {\n        return readRepairChance;\n    }\n\n    public double getDcLocalReadRepair()\n    {\n        return dcLocalReadRepairChance;\n    }\n\n    public boolean getReplicateOnWrite()\n    {\n        return replicateOnWrite;\n    }\n\n    public int getGcGraceSeconds()\n    {\n        return gcGraceSeconds;\n    }\n\n    public AbstractType<?> getDefaultValidator()\n    {\n        return defaultValidator;\n    }\n\n    public AbstractType<?> getKeyValidator()\n    {\n        return keyValidator;\n    }\n\n    public Integer getMinCompactionThreshold()\n    {\n        return minCompactionThreshold;\n    }\n\n    public Integer getMaxCompactionThreshold()\n    {\n        return maxCompactionThreshold;\n    }\n\n    public ByteBuffer getKeyName()\n    {\n        return keyAlias == null ? DEFAULT_KEY_NAME : keyAlias;\n    }\n\n    public ByteBuffer getKeyAlias()\n    {\n        return keyAlias;\n    }\n\n    public List<ByteBuffer> getColumnAliases()\n    {\n        return columnAliases;\n    }\n\n    public ByteBuffer getValueAlias()\n    {\n        return valueAlias;\n    }\n\n    public CompressionParameters compressionParameters()\n    {\n        return compressionParameters;\n    }\n\n    public Map<ByteBuffer, ColumnDefinition> getColumn_metadata()\n    {\n        return Collections.unmodifiableMap(column_metadata);\n    }\n\n    public AbstractType<?> getComparatorFor(ByteBuffer superColumnName)\n    {\n        return superColumnName == null ? comparator : subcolumnComparator;\n    }\n\n    public Double getBloomFilterFpChance()\n    {\n        return bloomFilterFpChance;\n    }\n\n    public Caching getCaching()\n    {\n        return caching;\n    }\n\n    public boolean equals(Object obj)\n    {\n        if (obj == this)\n        {\n            return true;\n        }\n        else if (obj == null || obj.getClass() != getClass())\n        {\n            return false;\n        }\n\n        CFMetaData rhs = (CFMetaData) obj;\n        return new EqualsBuilder()\n            .append(ksName, rhs.ksName)\n            .append(cfName, rhs.cfName)\n            .append(cfType, rhs.cfType)\n            .append(comparator, rhs.comparator)\n            .append(subcolumnComparator, rhs.subcolumnComparator)\n            .append(comment, rhs.comment)\n            .append(readRepairChance, rhs.readRepairChance)\n            .append(dcLocalReadRepairChance, rhs.dcLocalReadRepairChance)\n            .append(replicateOnWrite, rhs.replicateOnWrite)\n            .append(gcGraceSeconds, rhs.gcGraceSeconds)\n            .append(defaultValidator, rhs.defaultValidator)\n            .append(keyValidator, rhs.keyValidator)\n            .append(minCompactionThreshold, rhs.minCompactionThreshold)\n            .append(maxCompactionThreshold, rhs.maxCompactionThreshold)\n            .append(cfId.intValue(), rhs.cfId.intValue())\n            .append(column_metadata, rhs.column_metadata)\n            .append(keyAlias, rhs.keyAlias)\n            .append(columnAliases, rhs.columnAliases)\n            .append(valueAlias, rhs.valueAlias)\n            .append(compactionStrategyClass, rhs.compactionStrategyClass)\n            .append(compactionStrategyOptions, rhs.compactionStrategyOptions)\n            .append(compressionParameters, rhs.compressionParameters)\n            .append(bloomFilterFpChance, rhs.bloomFilterFpChance)\n            .append(caching, rhs.caching)\n            .isEquals();\n    }\n\n    public int hashCode()\n    {\n        return new HashCodeBuilder(29, 1597)\n            .append(ksName)\n            .append(cfName)\n            .append(cfType)\n            .append(comparator)\n            .append(subcolumnComparator)\n            .append(comment)\n            .append(readRepairChance)\n            .append(dcLocalReadRepairChance)\n            .append(replicateOnWrite)\n            .append(gcGraceSeconds)\n            .append(defaultValidator)\n            .append(keyValidator)\n            .append(minCompactionThreshold)\n            .append(maxCompactionThreshold)\n            .append(cfId)\n            .append(column_metadata)\n            .append(keyAlias)\n            .append(columnAliases)\n            .append(valueAlias)\n            .append(compactionStrategyClass)\n            .append(compactionStrategyOptions)\n            .append(compressionParameters)\n            .append(bloomFilterFpChance)\n            .append(caching)\n            .toHashCode();\n    }\n\n    public AbstractType<?> getValueValidator(ByteBuffer column)\n    {\n        return getValueValidator(column_metadata.get(column));\n    }\n\n    public AbstractType<?> getValueValidator(ColumnDefinition columnDefinition)\n    {\n        return columnDefinition == null\n               ? defaultValidator\n               : columnDefinition.getValidator();\n    }\n\n    /** applies implicit defaults to cf definition. useful in updates */\n    public static void applyImplicitDefaults(org.apache.cassandra.thrift.CfDef cf_def)\n    {\n        if (!cf_def.isSetComment())\n            cf_def.setComment("");\n        if (!cf_def.isSetReplicate_on_write())\n            cf_def.setReplicate_on_write(CFMetaData.DEFAULT_REPLICATE_ON_WRITE);\n        if (!cf_def.isSetMin_compaction_threshold())\n            cf_def.setMin_compaction_threshold(CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD);\n        if (!cf_def.isSetMax_compaction_threshold())\n            cf_def.setMax_compaction_threshold(CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD);\n        if (null == cf_def.compaction_strategy)\n            cf_def.compaction_strategy = DEFAULT_COMPACTION_STRATEGY_CLASS;\n        if (null == cf_def.compaction_strategy_options)\n            cf_def.compaction_strategy_options = Collections.emptyMap();\n        if (!cf_def.isSetCompression_options())\n        {\n            cf_def.setCompression_options(new HashMap<String, String>()\n            {{\n                if (DEFAULT_COMPRESSOR != null)\n                    put(CompressionParameters.SSTABLE_COMPRESSION, DEFAULT_COMPRESSOR);\n            }});\n        }\n        if (!cf_def.isSetDclocal_read_repair_chance())\n            cf_def.setDclocal_read_repair_chance(CFMetaData.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE);\n    }\n\n    public static CFMetaData fromThrift(org.apache.cassandra.thrift.CfDef cf_def) throws InvalidRequestException, ConfigurationException\n    {\n        ColumnFamilyType cfType = ColumnFamilyType.create(cf_def.column_type);\n        if (cfType == null)\n        {\n          throw new InvalidRequestException("Invalid column type " + cf_def.column_type);\n        }\n\n        applyImplicitDefaults(cf_def);\n\n        CFMetaData newCFMD = new CFMetaData(cf_def.keyspace,\n                                            cf_def.name,\n                                            cfType,\n                                            TypeParser.parse(cf_def.comparator_type),\n                                            cf_def.subcomparator_type == null ? null : TypeParser.parse(cf_def.subcomparator_type),\n                                            cf_def.isSetId() ? cf_def.id : Schema.instance.nextCFId());\n\n        if (cf_def.isSetGc_grace_seconds()) { newCFMD.gcGraceSeconds(cf_def.gc_grace_seconds); }\n        if (cf_def.isSetMin_compaction_threshold()) { newCFMD.minCompactionThreshold(cf_def.min_compaction_threshold); }\n        if (cf_def.isSetMax_compaction_threshold()) { newCFMD.maxCompactionThreshold(cf_def.max_compaction_threshold); }\n        if (cf_def.isSetKey_alias()) { newCFMD.keyAlias(cf_def.key_alias); }\n        if (cf_def.isSetKey_validation_class()) { newCFMD.keyValidator(TypeParser.parse(cf_def.key_validation_class)); }\n        if (cf_def.isSetCompaction_strategy())\n            newCFMD.compactionStrategyClass = createCompactionStrategy(cf_def.compaction_strategy);\n        if (cf_def.isSetCompaction_strategy_options())\n            newCFMD.compactionStrategyOptions(new HashMap<String, String>(cf_def.compaction_strategy_options));\n        if (cf_def.isSetBloom_filter_fp_chance())\n            newCFMD.bloomFilterFpChance(cf_def.bloom_filter_fp_chance);\n        if (cf_def.isSetCaching())\n            newCFMD.caching(Caching.fromString(cf_def.caching));\n        if (cf_def.isSetRead_repair_chance())\n            newCFMD.readRepairChance(cf_def.read_repair_chance);\n        if (cf_def.isSetDclocal_read_repair_chance())\n            newCFMD.dcLocalReadRepairChance(cf_def.dclocal_read_repair_chance);\n\n        CompressionParameters cp = CompressionParameters.create(cf_def.compression_options);\n\n        try\n        {\n            return newCFMD.comment(cf_def.comment)\n                          .replicateOnWrite(cf_def.replicate_on_write)\n                          .defaultValidator(TypeParser.parse(cf_def.default_validation_class))\n                          .keyValidator(TypeParser.parse(cf_def.key_validation_class))\n                          .columnMetadata(ColumnDefinition.fromThrift(cf_def.column_metadata))\n                          .compressionParameters(cp);\n        }\n        catch (MarshalException e)\n        {\n            throw new ConfigurationException(e.getMessage());\n        }\n    }\n\n    public void reload() throws IOException\n    {\n        Row cfDefRow = SystemTable.readSchemaRow(ksName, cfName);\n\n        if (cfDefRow.cf == null || cfDefRow.cf.isEmpty())\n            throw new IOException(String.format("%s not found in the schema definitions table.", ksName + ":" + cfName));\n\n        try\n        {\n            apply(fromSchema(cfDefRow));\n        }\n        catch (ConfigurationException e)\n        {\n            throw new IOException(e);\n        }\n    }\n\n    /**\n     * Updates CFMetaData in-place to match cf_def\n     *\n     * *Note*: This method left public only for DefsTest, don't use directly!\n     *\n     * @throws ConfigurationException if ks/cf names or cf ids didn't match\n     */\n    public void apply(CFMetaData cfm) throws ConfigurationException\n    {\n        logger.debug("applying {} to {}", cfm, this);\n        // validate\n        if (!cfm.ksName.equals(ksName))\n            throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",\n                                                           cfm.ksName, ksName));\n        if (!cfm.cfName.equals(cfName))\n            throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",\n                                                           cfm.cfName, cfName));\n        if (!cfm.cfId.equals(cfId))\n            throw new ConfigurationException(String.format("Column family ID mismatch (found %s; expected %s)",\n                                                           cfm.cfId, cfId));\n\n        if (!cfm.cfType.equals(cfType))\n            throw new ConfigurationException("types do not match.");\n\n        if (!cfm.comparator.isCompatibleWith(comparator))\n            throw new ConfigurationException("comparators do not match or are not compatible.");\n        if (cfm.subcolumnComparator == null)\n        {\n            if (subcolumnComparator != null)\n                throw new ConfigurationException("subcolumncomparators do not match.");\n            // else, it's null and we're good.\n        }\n        else if (!cfm.subcolumnComparator.isCompatibleWith(subcolumnComparator))\n            throw new ConfigurationException("subcolumncomparators do not match or are note compatible.");\n\n        // TODO: this method should probably return a new CFMetaData so that\n        // 1) we can keep comparator and subcolumnComparator final\n        // 2) updates are applied atomically\n        comparator = cfm.comparator;\n        subcolumnComparator = cfm.subcolumnComparator;\n\n        // compaction thresholds are checked by ThriftValidation. We shouldn't be doing\n        // validation on the apply path; it's too late for that.\n\n        comment = enforceCommentNotNull(cfm.comment);\n        readRepairChance = cfm.readRepairChance;\n        dcLocalReadRepairChance = cfm.dcLocalReadRepairChance;\n        replicateOnWrite = cfm.replicateOnWrite;\n        gcGraceSeconds = cfm.gcGraceSeconds;\n        defaultValidator = cfm.defaultValidator;\n        keyValidator = cfm.keyValidator;\n        minCompactionThreshold = cfm.minCompactionThreshold;\n        maxCompactionThreshold = cfm.maxCompactionThreshold;\n        keyAlias = cfm.keyAlias;\n\n        // We don't want updates coming from thrift to erase columnAliases/valuAlias, which would be wrong, but those are not exposed throught thrift. So\n        // we just only override the value when the new has those set.\n        // Note that this doesn't remove feature on the CQL side since removing columnAliases/valuAlias is non-sensical and not allowed (actually, updating\n        // those is not allowed either but it would be possible to allow it through some ALTER RENAME later).\n        if (!cfm.columnAliases.isEmpty())\n            columnAliases = cfm.columnAliases;\n        if (cfm.valueAlias != null)\n            valueAlias = cfm.valueAlias;\n        bloomFilterFpChance = cfm.bloomFilterFpChance;\n        caching = cfm.caching;\n\n        MapDifference<ByteBuffer, ColumnDefinition> columnDiff = Maps.difference(column_metadata, cfm.column_metadata);\n        // columns that are no longer needed\n        for (ColumnDefinition cd : columnDiff.entriesOnlyOnLeft().values())\n            column_metadata.remove(cd.name);\n        // newly added columns\n        for (ColumnDefinition cd : columnDiff.entriesOnlyOnRight().values())\n            column_metadata.put(cd.name, cd);\n        // old columns with updated attributes\n        for (ByteBuffer name : columnDiff.entriesDiffering().keySet())\n        {\n            ColumnDefinition oldDef = column_metadata.get(name);\n            ColumnDefinition def = cfm.column_metadata.get(name);\n            oldDef.apply(def, getColumnDefinitionComparator(oldDef));\n        }\n\n        compactionStrategyClass = cfm.compactionStrategyClass;\n        compactionStrategyOptions = cfm.compactionStrategyOptions;\n\n        compressionParameters = cfm.compressionParameters();\n\n        updateCfDef();\n        logger.debug("application result is {}", this);\n    }\n\n    public static Class<? extends AbstractCompactionStrategy> createCompactionStrategy(String className) throws ConfigurationException\n    {\n        className = className.contains(".") ? className : "org.apache.cassandra.db.compaction." + className;\n        return FBUtilities.classForName(className, "compaction strategy");\n    }\n\n    public AbstractCompactionStrategy createCompactionStrategyInstance(ColumnFamilyStore cfs)\n    {\n        try\n        {\n            Constructor<? extends AbstractCompactionStrategy> constructor = compactionStrategyClass.getConstructor(new Class[] {\n                ColumnFamilyStore.class,\n                Map.class // options\n            });\n            return constructor.newInstance(cfs, compactionStrategyOptions);\n        }\n        catch (NoSuchMethodException e)\n        {\n            throw new RuntimeException(e);\n        }\n        catch (InstantiationException e)\n        {\n            throw new RuntimeException(e);\n        }\n        catch (IllegalAccessException e)\n        {\n            throw new RuntimeException(e);\n        }\n        catch (InvocationTargetException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // converts CFM to thrift CfDef\n    public org.apache.cassandra.thrift.CfDef toThrift()\n    {\n        org.apache.cassandra.thrift.CfDef def = new org.apache.cassandra.thrift.CfDef(ksName, cfName);\n        def.setId(cfId);\n        def.setColumn_type(cfType.name());\n        def.setComparator_type(comparator.toString());\n        if (subcolumnComparator != null)\n        {\n            assert cfType == ColumnFamilyType.Super\n                   : String.format("%s CF %s should not have subcomparator %s defined", cfType, cfName, subcolumnComparator);\n            def.setSubcomparator_type(subcolumnComparator.toString());\n        }\n        def.setComment(enforceCommentNotNull(comment));\n        def.setRead_repair_chance(readRepairChance);\n        def.setDclocal_read_repair_chance(dcLocalReadRepairChance);\n        def.setReplicate_on_write(replicateOnWrite);\n        def.setGc_grace_seconds(gcGraceSeconds);\n        def.setDefault_validation_class(defaultValidator == null ? null : defaultValidator.toString());\n        def.setKey_validation_class(keyValidator.toString());\n        def.setMin_compaction_threshold(minCompactionThreshold);\n        def.setMax_compaction_threshold(maxCompactionThreshold);\n        def.setKey_alias(keyAlias);\n        List<org.apache.cassandra.thrift.ColumnDef> column_meta = new ArrayList<org.apache.cassandra.thrift.ColumnDef>(column_metadata.size());\n        for (ColumnDefinition cd : column_metadata.values())\n        {\n            // Non-null componentIndex are only used by CQL (so far) so we don't expose\n            // them through thrift\n            if (cd.componentIndex == null)\n                column_meta.add(cd.toThrift());\n        }\n        def.setColumn_metadata(column_meta);\n        def.setCompaction_strategy(compactionStrategyClass.getName());\n        def.setCompaction_strategy_options(new HashMap<String, String>(compactionStrategyOptions));\n        def.setCompression_options(compressionParameters.asThriftOptions());\n        if (bloomFilterFpChance != null)\n            def.setBloom_filter_fp_chance(bloomFilterFpChance);\n        def.setCaching(caching.toString());\n        return def;\n    }\n\n    public ColumnDefinition getColumnDefinition(ByteBuffer name)\n    {\n        return column_metadata.get(name);\n    }\n\n    public ColumnDefinition getColumnDefinitionForIndex(String indexName)\n    {\n        for (ColumnDefinition def : column_metadata.values())\n        {\n            if (indexName.equals(def.getIndexName()))\n                return def;\n        }\n        return null;\n    }\n\n    /**\n     * Convert a null index_name to appropriate default name according to column status\n     */\n    public void addDefaultIndexNames() throws ConfigurationException\n    {\n        // if this is ColumnFamily update we need to add previously defined index names to the existing columns first\n        Integer cfId = Schema.instance.getId(ksName, cfName);\n        if (cfId != null)\n        {\n            CFMetaData cfm = Schema.instance.getCFMetaData(cfId);\n\n            for (Map.Entry<ByteBuffer, ColumnDefinition> entry : column_metadata.entrySet())\n            {\n                ColumnDefinition newDef = entry.getValue();\n\n                if (!cfm.column_metadata.containsKey(entry.getKey()) || newDef.getIndexType() == null)\n                    continue;\n\n                String oldIndexName = cfm.column_metadata.get(entry.getKey()).getIndexName();\n\n                if (oldIndexName == null)\n                    continue;\n\n                if (newDef.getIndexName() != null && !oldIndexName.equals(newDef.getIndexName()))\n                    throw new ConfigurationException("Can't modify index name: was '" + oldIndexName + "' changed to '" + newDef.getIndexName() + "'.");\n\n                newDef.setIndexName(oldIndexName);\n            }\n        }\n\n        Set<String> existingNames = existingIndexNames(null);\n        for (ColumnDefinition column : column_metadata.values())\n        {\n            if (column.getIndexType() != null && column.getIndexName() == null)\n            {\n                String baseName = getDefaultIndexName(cfName, comparator, column.name);\n                String indexName = baseName;\n                int i = 0;\n                while (existingNames.contains(indexName))\n                    indexName = baseName + '_' + (++i);\n                column.setIndexName(indexName);\n            }\n        }\n    }\n\n    public static String getDefaultIndexName(String cfName, AbstractType<?> comparator, ByteBuffer columnName)\n    {\n        return (cfName + "_" + comparator.getString(columnName) + "_idx").replaceAll("\\\\W", "");\n    }\n\n    public IColumnSerializer getColumnSerializer()\n    {\n        if (cfType == ColumnFamilyType.Standard)\n            return Column.serializer();\n        return SuperColumn.serializer(subcolumnComparator);\n    }\n\n    public static boolean isNameValid(String name)\n    {\n        return name != null && !name.isEmpty() && name.length() <= Schema.NAME_LENGTH && name.matches("\\\\w+");\n    }\n\n    public static boolean isIndexNameValid(String name)\n    {\n        return name != null && !name.isEmpty() && name.matches("\\\\w+");\n    }\n\n    public CFMetaData validate() throws ConfigurationException\n    {\n        if (!isNameValid(ksName))\n            throw new ConfigurationException(String.format("Keyspace name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \\"%s\\")", Schema.NAME_LENGTH, ksName));\n        if (!isNameValid(cfName))\n            throw new ConfigurationException(String.format("ColumnFamily name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \\"%s\\")", Schema.NAME_LENGTH, cfName));\n\n        if (cfType == null)\n            throw new ConfigurationException(String.format("Invalid column family type for %s", cfName));\n\n        if (cfType == ColumnFamilyType.Super)\n        {\n            if (subcolumnComparator == null)\n                throw new ConfigurationException(String.format("Missing subcolumn comparator for super column family %s", cfName));\n        }\n        else\n        {\n            if (subcolumnComparator != null)\n                throw new ConfigurationException(String.format("Subcolumn comparator (%s) is invalid for standard column family %s", subcolumnComparator, cfName));\n        }\n\n\n        if (comparator instanceof CounterColumnType)\n            throw new ConfigurationException("CounterColumnType is not a valid comparator");\n        if (subcolumnComparator instanceof CounterColumnType)\n            throw new ConfigurationException("CounterColumnType is not a valid sub-column comparator");\n        if (keyValidator instanceof CounterColumnType)\n            throw new ConfigurationException("CounterColumnType is not a valid key validator");\n\n        // Mixing counter with non counter columns is not supported (#2614)\n        if (defaultValidator instanceof CounterColumnType)\n        {\n            for (ColumnDefinition def : column_metadata.values())\n                if (!(def.getValidator() instanceof CounterColumnType))\n                    throw new ConfigurationException("Cannot add a non counter column (" + comparator.getString(def.name) + ") in a counter column family");\n        }\n        else\n        {\n            for (ColumnDefinition def : column_metadata.values())\n                if (def.getValidator() instanceof CounterColumnType)\n                    throw new ConfigurationException("Cannot add a counter column (" + comparator.getString(def.name) + ") in a non counter column family");\n        }\n\n        // check if any of the columns has name equal to the cf.key_alias\n        for (ColumnDefinition columndef : column_metadata.values())\n        {\n            if (keyAlias != null && keyAlias.equals(columndef.name))\n                throw new ConfigurationException("Cannot have key alias equals to a column name: " + UTF8Type.instance.compose(keyAlias));\n\n            for (ByteBuffer alias : columnAliases)\n                if (alias.equals(columndef.name))\n                    throw new ConfigurationException("Cannot have column alias equals to a column name: " + UTF8Type.instance.compose(alias));\n\n            if (valueAlias != null && valueAlias.equals(columndef.name))\n                throw new ConfigurationException("Cannot have value alias equals to a column name: " + UTF8Type.instance.compose(valueAlias));\n        }\n\n        validateAlias(keyAlias, "Key");\n        for (ByteBuffer alias : columnAliases)\n            validateAlias(alias, "Column");\n        validateAlias(valueAlias, "Value");\n\n        // initialize a set of names NOT in the CF under consideration\n        Set<String> indexNames = existingIndexNames(cfName);\n        for (ColumnDefinition c : column_metadata.values())\n        {\n            AbstractType<?> comparator = getColumnDefinitionComparator(c);\n\n            try\n            {\n                comparator.validate(c.name);\n            }\n            catch (MarshalException e)\n            {\n                throw new ConfigurationException(String.format("Column name %s is not valid for comparator %s",\n                                                               ByteBufferUtil.bytesToHex(c.name), comparator));\n            }\n\n            if (c.getIndexType() == null)\n            {\n                if (c.getIndexName() != null)\n                    throw new ConfigurationException("Index name cannot be set without index type");\n            }\n            else\n            {\n                if (cfType == ColumnFamilyType.Super)\n                    throw new ConfigurationException("Secondary indexes are not supported on super column families");\n                if (!isIndexNameValid(c.getIndexName()))\n                    throw new ConfigurationException("Illegal index name " + c.getIndexName());\n                // check index names against this CF _and_ globally\n                if (indexNames.contains(c.getIndexName()))\n                    throw new ConfigurationException("Duplicate index name " + c.getIndexName());\n                indexNames.add(c.getIndexName());\n\n                if (c.getIndexType() == IndexType.CUSTOM)\n                {\n                    if (c.getIndexOptions() == null || !c.getIndexOptions().containsKey(SecondaryIndex.CUSTOM_INDEX_OPTION_NAME))\n                        throw new ConfigurationException("Required index option missing: " + SecondaryIndex.CUSTOM_INDEX_OPTION_NAME);\n                }\n\n                // This method validates the column metadata but does not intialize the index\n                SecondaryIndex.createInstance(null, c);\n            }\n        }\n\n        validateCompactionThresholds();\n\n        return this;\n    }\n\n    private static Set<String> existingIndexNames(String cfToExclude)\n    {\n        Set<String> indexNames = new HashSet<String>();\n        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())\n        {\n            if (cfToExclude == null || !cfs.getColumnFamilyName().equals(cfToExclude))\n                for (ColumnDefinition cd : cfs.metadata.getColumn_metadata().values())\n                    indexNames.add(cd.getIndexName());\n        }\n        return indexNames;\n    }\n\n    private static void validateAlias(ByteBuffer alias, String msg) throws ConfigurationException\n    {\n        if (alias != null)\n        {\n            if (!alias.hasRemaining())\n                throw new ConfigurationException(msg + " alias may not be empty");\n            try\n            {\n                UTF8Type.instance.validate(alias);\n            }\n            catch (MarshalException e)\n            {\n                throw new ConfigurationException(msg + " alias must be UTF8");\n            }\n        }\n    }\n\n    private void validateCompactionThresholds() throws ConfigurationException\n    {\n        if (maxCompactionThreshold == 0)\n            return;\n\n        if (minCompactionThreshold <= 1)\n            throw new ConfigurationException(String.format("Min compaction threshold cannot be less than 2 (got %d).", minCompactionThreshold));\n\n        if (minCompactionThreshold > maxCompactionThreshold)\n            throw new ConfigurationException(String.format("Min compaction threshold (got %d) cannot be greater than max compaction threshold (got %d)",\n                                                            minCompactionThreshold, maxCompactionThreshold));\n    }\n\n    /**\n     * Create schema mutations to update this metadata to provided new state.\n     *\n     * @param newState The new metadata (for the same CF)\n     * @param modificationTimestamp Timestamp to use for mutation\n     *\n     * @return Difference between attributes in form of schema mutation\n     */\n    public RowMutation toSchemaUpdate(CFMetaData newState, long modificationTimestamp)\n    {\n        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(ksName));\n\n        newState.toSchemaNoColumns(rm, modificationTimestamp);\n\n        MapDifference<ByteBuffer, ColumnDefinition> columnDiff = Maps.difference(column_metadata, newState.column_metadata);\n\n        // columns that are no longer needed\n        for (ColumnDefinition cd : columnDiff.entriesOnlyOnLeft().values())\n            cd.deleteFromSchema(rm, cfName, getColumnDefinitionComparator(cd), modificationTimestamp);\n\n        // newly added columns\n        for (ColumnDefinition cd : columnDiff.entriesOnlyOnRight().values())\n            cd.toSchema(rm, cfName, getColumnDefinitionComparator(cd), modificationTimestamp);\n\n        // old columns with updated attributes\n        for (ByteBuffer name : columnDiff.entriesDiffering().keySet())\n        {\n            ColumnDefinition cd = newState.getColumnDefinition(name);\n            cd.toSchema(rm, cfName, getColumnDefinitionComparator(cd), modificationTimestamp);\n        }\n\n        return rm;\n    }\n\n    /**\n     * Remove all CF attributes from schema\n     *\n     * @param timestamp Timestamp to use\n     *\n     * @return RowMutation to use to completely remove cf from schema\n     */\n    public RowMutation dropFromSchema(long timestamp)\n    {\n        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(ksName));\n        ColumnFamily cf = rm.addOrGet(SystemTable.SCHEMA_COLUMNFAMILIES_CF);\n        int ldt = (int) (System.currentTimeMillis() / 1000);\n\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "id"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "type"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "comparator"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "subcomparator"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "comment"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "read_repair_chance"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "local_read_repair_chance"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "replicate_on_write"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "gc_grace_seconds"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "default_validator"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "key_validator"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "min_compaction_threshold"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "max_compaction_threshold"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "key_alias"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "bloom_filter_fp_chance"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "caching"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "compaction_strategy_class"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "compression_parameters"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "value_alias"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "column_aliases"));\n        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "compaction_strategy_options"));\n\n        for (ColumnDefinition cd : column_metadata.values())\n            cd.deleteFromSchema(rm, cfName, getColumnDefinitionComparator(cd), timestamp);\n\n        return rm;\n    }\n\n    public void toSchema(RowMutation rm, long timestamp)\n    {\n        toSchemaNoColumns(rm, timestamp);\n\n        for (ColumnDefinition cd : column_metadata.values())\n            cd.toSchema(rm, cfName, getColumnDefinitionComparator(cd), timestamp);\n    }\n\n    private void toSchemaNoColumns(RowMutation rm, long timestamp)\n    {\n        // For property that can be null (and can be changed), we insert tombstones, to make sure\n        // we don't keep a property the user has removed\n        ColumnFamily cf = rm.addOrGet(SystemTable.SCHEMA_COLUMNFAMILIES_CF);\n        int ldt = (int) (System.currentTimeMillis() / 1000);\n\n        cf.addColumn(Column.create(cfId, timestamp, cfName, "id"));\n        cf.addColumn(Column.create(cfType.toString(), timestamp, cfName, "type"));\n        cf.addColumn(Column.create(comparator.toString(), timestamp, cfName, "comparator"));\n        if (subcolumnComparator != null)\n            cf.addColumn(Column.create(subcolumnComparator.toString(), timestamp, cfName, "subcomparator"));\n        cf.addColumn(comment == null ? DeletedColumn.create(ldt, timestamp, cfName, "comment")\n                                     : Column.create(comment, timestamp, cfName, "comment"));\n        cf.addColumn(Column.create(readRepairChance, timestamp, cfName, "read_repair_chance"));\n        cf.addColumn(Column.create(dcLocalReadRepairChance, timestamp, cfName, "local_read_repair_chance"));\n        cf.addColumn(Column.create(replicateOnWrite, timestamp, cfName, "replicate_on_write"));\n        cf.addColumn(Column.create(gcGraceSeconds, timestamp, cfName, "gc_grace_seconds"));\n        cf.addColumn(Column.create(defaultValidator.toString(), timestamp, cfName, "default_validator"));\n        cf.addColumn(Column.create(keyValidator.toString(), timestamp, cfName, "key_validator"));\n        cf.addColumn(Column.create(minCompactionThreshold, timestamp, cfName, "min_compaction_threshold"));\n        cf.addColumn(Column.create(maxCompactionThreshold, timestamp, cfName, "max_compaction_threshold"));\n        cf.addColumn(keyAlias == null ? DeletedColumn.create(ldt, timestamp, cfName, "key_alias")\n                                      : Column.create(keyAlias, timestamp, cfName, "key_alias"));\n        cf.addColumn(bloomFilterFpChance == null ? DeletedColumn.create(ldt, timestamp, cfName, "bloomFilterFpChance")\n                                                 : Column.create(bloomFilterFpChance, timestamp, cfName, "bloom_filter_fp_chance"));\n        cf.addColumn(Column.create(caching.toString(), timestamp, cfName, "caching"));\n        cf.addColumn(Column.create(compactionStrategyClass.getName(), timestamp, cfName, "compaction_strategy_class"));\n        cf.addColumn(Column.create(json(compressionParameters.asThriftOptions()), timestamp, cfName, "compression_parameters"));\n        cf.addColumn(valueAlias == null ? DeletedColumn.create(ldt, timestamp, cfName, "value_alias")\n                                        : Column.create(valueAlias, timestamp, cfName, "value_alias"));\n        cf.addColumn(Column.create(json(columnAliasesAsStrings()), timestamp, cfName, "column_aliases"));\n        cf.addColumn(Column.create(json(compactionStrategyOptions), timestamp, cfName, "compaction_strategy_options"));\n    }\n\n    // Package protected for use by tests\n    static CFMetaData fromSchemaNoColumns(UntypedResultSet.Row result)\n    {\n        try\n        {\n            CFMetaData cfm = new CFMetaData(result.getString("keyspace"),\n                                            result.getString("columnfamily"),\n                                            ColumnFamilyType.valueOf(result.getString("type")),\n                                            TypeParser.parse(result.getString("comparator")),\n                                            result.has("subcomparator") ? TypeParser.parse(result.getString("subcomparator")) : null,\n                                            result.getInt("id"));\n            cfm.readRepairChance(result.getDouble("read_repair_chance"));\n            cfm.dcLocalReadRepairChance(result.getDouble("local_read_repair_chance"));\n            cfm.replicateOnWrite(result.getBoolean("replicate_on_write"));\n            cfm.gcGraceSeconds(result.getInt("gc_grace_seconds"));\n            cfm.defaultValidator(TypeParser.parse(result.getString("default_validator")));\n            cfm.keyValidator(TypeParser.parse(result.getString("key_validator")));\n            cfm.minCompactionThreshold(result.getInt("min_compaction_threshold"));\n            cfm.maxCompactionThreshold(result.getInt("max_compaction_threshold"));\n            if (result.has("comment"))\n                cfm.comment(result.getString("comment"));\n            if (result.has("key_alias"))\n                cfm.keyAlias(result.getBytes("key_alias"));\n            if (result.has("bloom_filter_fp_chance"))\n                cfm.bloomFilterFpChance(result.getDouble("bloom_filter_fp_chance"));\n            cfm.caching(Caching.valueOf(result.getString("caching")));\n            cfm.compactionStrategyClass(createCompactionStrategy(result.getString("compaction_strategy_class")));\n            cfm.compressionParameters(CompressionParameters.create(fromJsonMap(result.getString("compression_parameters"))));\n            if (result.has("value_alias"))\n                cfm.valueAlias(result.getBytes("value_alias"));\n            cfm.columnAliases(columnAliasesFromStrings(fromJsonList(result.getString("column_aliases"))));\n            cfm.compactionStrategyOptions(fromJsonMap(result.getString("compaction_strategy_options")));\n\n            return cfm;\n        }\n        catch (ConfigurationException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Deserialize CF metadata from low-level representation\n     *\n     * @return Thrift-based metadata deserialized from schema\n     *\n     * @throws IOException on any I/O related error\n     */\n    public static CFMetaData fromSchema(UntypedResultSet.Row result)\n    {\n        CFMetaData cfDef = fromSchemaNoColumns(result);\n\n        Row serializedColumnDefinitions = ColumnDefinition.readSchema(cfDef.ksName, cfDef.cfName);\n        return addColumnDefinitionSchema(cfDef, serializedColumnDefinitions).updateCfDef();\n    }\n\n    private static CFMetaData fromSchema(Row row)\n    {\n        UntypedResultSet.Row result = QueryProcessor.resultify("SELECT * FROM system.schema_columnfamilies", row).one();\n        return fromSchema(result);\n    }\n\n    private List<String> columnAliasesAsStrings()\n    {\n        List<String> aliases = new ArrayList<String>(columnAliases.size());\n        for (ByteBuffer rawAlias : columnAliases)\n            aliases.add(UTF8Type.instance.compose(rawAlias));\n        return aliases;\n    }\n\n    private static List<ByteBuffer> columnAliasesFromStrings(List<String> aliases)\n    {\n        List<ByteBuffer> rawAliases = new ArrayList<ByteBuffer>(aliases.size());\n        for (String alias : aliases)\n            rawAliases.add(UTF8Type.instance.decompose(alias));\n        return rawAliases;\n    }\n\n    /**\n     * Convert current metadata into schema mutation\n     *\n     * @param timestamp Timestamp to use\n     *\n     * @return Low-level representation of the CF\n     *\n     * @throws ConfigurationException if any of the attributes didn't pass validation\n     */\n    public RowMutation toSchema(long timestamp) throws ConfigurationException\n    {\n        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(ksName));\n        toSchema(rm, timestamp);\n        return rm;\n    }\n\n    public AbstractType<?> getColumnDefinitionComparator(ColumnDefinition def)\n    {\n        return getColumnDefinitionComparator(def.componentIndex);\n    }\n\n    public AbstractType<?> getColumnDefinitionComparator(Integer componentIndex)\n    {\n        AbstractType<?> cfComparator = cfType == ColumnFamilyType.Super ? subcolumnComparator : comparator;\n        if (cfComparator instanceof CompositeType)\n        {\n            if (componentIndex == null)\n                return cfComparator;\n\n            List<AbstractType<?>> types = ((CompositeType)cfComparator).types;\n            AbstractType<?> t = types.get(componentIndex);\n            assert t != null : "Non-sensical component index";\n            return t;\n        }\n        else\n        {\n            return cfComparator;\n        }\n    }\n\n    // Package protected for use by tests\n    static CFMetaData addColumnDefinitionSchema(CFMetaData cfDef, Row serializedColumnDefinitions)\n    {\n        for (ColumnDefinition cd : ColumnDefinition.fromSchema(serializedColumnDefinitions, cfDef))\n            cfDef.column_metadata.put(cd.name, cd);\n        return cfDef;\n    }\n\n    public void addColumnDefinition(ColumnDefinition def)\n    {\n        column_metadata.put(def.name, def);\n    }\n\n    public boolean removeColumnDefinition(ColumnDefinition def)\n    {\n        return column_metadata.remove(def.name) != null;\n    }\n\n    private CFMetaData updateCfDef()\n    {\n        cqlCfDef = new CFDefinition(this);\n        return this;\n    }\n\n    public CFDefinition getCfDef()\n    {\n        assert cqlCfDef != null;\n        return cqlCfDef;\n    }\n\n    @Override\n    public String toString()\n    {\n        return new ToStringBuilder(this)\n            .append("cfId", cfId)\n            .append("ksName", ksName)\n            .append("cfName", cfName)\n            .append("cfType", cfType)\n            .append("comparator", comparator)\n            .append("subcolumncomparator", subcolumnComparator)\n            .append("comment", comment)\n            .append("readRepairChance", readRepairChance)\n            .append("dclocalReadRepairChance", dcLocalReadRepairChance)\n            .append("replicateOnWrite", replicateOnWrite)\n            .append("gcGraceSeconds", gcGraceSeconds)\n            .append("defaultValidator", defaultValidator)\n            .append("keyValidator", keyValidator)\n            .append("minCompactionThreshold", minCompactionThreshold)\n            .append("maxCompactionThreshold", maxCompactionThreshold)\n            .append("keyAlias", keyAlias)\n            .append("columnAliases", columnAliases)\n            .append("valueAlias", valueAlias)\n            .append("column_metadata", column_metadata)\n            .append("compactionStrategyClass", compactionStrategyClass)\n            .append("compactionStrategyOptions", compactionStrategyOptions)\n            .append("compressionOptions", compressionParameters.asThriftOptions())\n            .append("bloomFilterFpChance", bloomFilterFpChance)\n            .append("caching", caching)\n            .toString();\n    }\n}	Divergent Change	Long Method\n	God Class\n	Feature Envy\n	CFMetaData.java\n	9aa0a177fe1900bc8c86e3295a20f74c	\N	Oocorre quando uma classe é alterada de maneiras diferentes por diferentes razões.	WMC (Weighted Method per Class), NCC (Number Concerns per Component), LCOM (Lack of Cohesion in Methods)	Refatoração sugerida: Extract Class	t	3
\.


--
-- Data for Name: question_temp; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.question_temp (id, ask, code, correct, fake1, fake2, fake3, filename, md5correct, right_answer, tip, tip2, tip3, valid, question_id, room_id) FROM stdin;
\.


--
-- Data for Name: room; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.room (id, description, git_url, is_public, name, open, total_participantes, type) FROM stdin;
1	\N	\N	f	Quiz	t	\N	1
2	\N	\N	f	Identificação(Grupo 1)	t	\N	2
3	\N	\N	f	Identificação(Grupo 2)	t	0	2
\.


--
-- Data for Name: room_admin; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.room_admin (room_id, admin_id) FROM stdin;
1	1
2	1
3	1
\.


--
-- Data for Name: room_member; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.room_member (room_id, member_id) FROM stdin;
1	2
2	2
3	2
\.


--
-- Data for Name: rooms_team; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.rooms_team (team_id, room_id) FROM stdin;
1	1
2	2
3	3
\.


--
-- Data for Name: score; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.score (id, bonus, bonus_consecutive, consecutive_hits, gettip, panalites, points, score, total_errors, total_hits, room_id, team_id, user_id) FROM stdin;
1	0	0	0	t	0	\N	0	0	0	1	\N	1
3	0	0	0	t	0	\N	0	0	0	2	\N	1
5	0	0	0	t	0	\N	0	0	0	3	\N	1
\.


--
-- Data for Name: team; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.team (id, name) FROM stdin;
1	
2	
3	
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, mail, name, passwd) FROM stdin;
1	hoyamams@gmail.com	Hoyama M Santos	$2a$10$aXcRp1.dYO/8IWvckCP18.PfGirN6hAvSS8WG8MafdTstNn4qMdq.
2	lucastimoteo90@gmail.com	Lucas T silva	$2a$10$KbFN8BXPqcU/Qms0u3DsUuuw1cMWFdGstXXPM5cvXGBVcAjQd6xFS
\.


--
-- Data for Name: users_team; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users_team (team_id, user_id) FROM stdin;
1	1
2	1
3	1
\.


--
-- Name: answer_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.answer_id_seq', 22, true);


--
-- Name: bad_smell_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.bad_smell_id_seq', 1, false);


--
-- Name: battle_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.battle_id_seq', 1, false);


--
-- Name: code_bad_smell_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.code_bad_smell_id_seq', 1, false);


--
-- Name: pmderrors_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.pmderrors_id_seq', 1, false);


--
-- Name: question_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.question_id_seq', 55, true);


--
-- Name: question_temp_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.question_temp_id_seq', 1, false);


--
-- Name: room_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.room_id_seq', 3, true);


--
-- Name: score_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.score_id_seq', 8, true);


--
-- Name: team_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.team_id_seq', 3, true);


--
-- Name: users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.users_id_seq', 2, true);


--
-- Name: answer answer_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer
    ADD CONSTRAINT answer_pkey PRIMARY KEY (id);


--
-- Name: bad_smell bad_smell_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.bad_smell
    ADD CONSTRAINT bad_smell_pkey PRIMARY KEY (id);


--
-- Name: battle battle_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.battle
    ADD CONSTRAINT battle_pkey PRIMARY KEY (id);


--
-- Name: code_bad_smell code_bad_smell_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_bad_smell
    ADD CONSTRAINT code_bad_smell_pkey PRIMARY KEY (id);


--
-- Name: easy_question easy_question_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.easy_question
    ADD CONSTRAINT easy_question_pkey PRIMARY KEY (id);


--
-- Name: easy_room easy_room_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.easy_room
    ADD CONSTRAINT easy_room_pkey PRIMARY KEY (id);


--
-- Name: hard_question hard_question_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hard_question
    ADD CONSTRAINT hard_question_pkey PRIMARY KEY (id);


--
-- Name: hard_room hard_room_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hard_room
    ADD CONSTRAINT hard_room_pkey PRIMARY KEY (id);


--
-- Name: medium_room medium_room_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.medium_room
    ADD CONSTRAINT medium_room_pkey PRIMARY KEY (id);


--
-- Name: pmderrors pmderrors_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pmderrors
    ADD CONSTRAINT pmderrors_pkey PRIMARY KEY (id);


--
-- Name: question question_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question
    ADD CONSTRAINT question_pkey PRIMARY KEY (id);


--
-- Name: question_temp question_temp_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question_temp
    ADD CONSTRAINT question_temp_pkey PRIMARY KEY (id);


--
-- Name: room room_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.room
    ADD CONSTRAINT room_pkey PRIMARY KEY (id);


--
-- Name: score score_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.score
    ADD CONSTRAINT score_pkey PRIMARY KEY (id);


--
-- Name: team team_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.team
    ADD CONSTRAINT team_pkey PRIMARY KEY (id);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: question_temp fk1vmy6yucmsc0gwvo3rufvkkjl; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question_temp
    ADD CONSTRAINT fk1vmy6yucmsc0gwvo3rufvkkjl FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: easy_room fk2ajgbwrc96p4ywo9xsp389c39; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.easy_room
    ADD CONSTRAINT fk2ajgbwrc96p4ywo9xsp389c39 FOREIGN KEY (id) REFERENCES public.room(id);


--
-- Name: battle fk3n7wy1ipagdjx7qvdyon2v5fj; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.battle
    ADD CONSTRAINT fk3n7wy1ipagdjx7qvdyon2v5fj FOREIGN KEY (team1_id) REFERENCES public.team(id);


--
-- Name: profiles fk410q61iev7klncmpqfuo85ivh; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT fk410q61iev7klncmpqfuo85ivh FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: hard_room fk56njt1w0bk3uayahtau3uyi6r; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hard_room
    ADD CONSTRAINT fk56njt1w0bk3uayahtau3uyi6r FOREIGN KEY (id) REFERENCES public.room(id);


--
-- Name: room_admin fk7e6qlj9aok7y8odht1cr9r951; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.room_admin
    ADD CONSTRAINT fk7e6qlj9aok7y8odht1cr9r951 FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: answer fk8frr4bcabmmeyyu60qt7iiblo; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer
    ADD CONSTRAINT fk8frr4bcabmmeyyu60qt7iiblo FOREIGN KEY (question_id) REFERENCES public.question(id);


--
-- Name: question fk8uj5u1ki48awftnyabhfgpke; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question
    ADD CONSTRAINT fk8uj5u1ki48awftnyabhfgpke FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: users_team fk9sxddw43xnts7af421l1vn0oy; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_team
    ADD CONSTRAINT fk9sxddw43xnts7af421l1vn0oy FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: question_temp fkdm495hm8005uksnc0a3eftm5q; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question_temp
    ADD CONSTRAINT fkdm495hm8005uksnc0a3eftm5q FOREIGN KEY (question_id) REFERENCES public.question(id);


--
-- Name: score fkdxo2txw37je6766o72jobhlnh; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.score
    ADD CONSTRAINT fkdxo2txw37je6766o72jobhlnh FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: battle fkevqjx61ihapp0wevlwtf3oxys; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.battle
    ADD CONSTRAINT fkevqjx61ihapp0wevlwtf3oxys FOREIGN KEY (attack_id) REFERENCES public.team(id);


--
-- Name: rooms_team fkf856tlhq8eva8f27wcr8pxkco; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rooms_team
    ADD CONSTRAINT fkf856tlhq8eva8f27wcr8pxkco FOREIGN KEY (team_id) REFERENCES public.team(id);


--
-- Name: room_admin fkffjxdavl21ivogob1qsnyhvcf; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.room_admin
    ADD CONSTRAINT fkffjxdavl21ivogob1qsnyhvcf FOREIGN KEY (admin_id) REFERENCES public.users(id);


--
-- Name: users_team fkju2qittgiknj29l07uji9lfsv; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_team
    ADD CONSTRAINT fkju2qittgiknj29l07uji9lfsv FOREIGN KEY (team_id) REFERENCES public.team(id);


--
-- Name: room_member fkk3rb8vxpgbk60p8hw6ofgv1it; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.room_member
    ADD CONSTRAINT fkk3rb8vxpgbk60p8hw6ofgv1it FOREIGN KEY (member_id) REFERENCES public.users(id);


--
-- Name: medium_room fkl99ugp7b9xt38lmygohrnq252; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.medium_room
    ADD CONSTRAINT fkl99ugp7b9xt38lmygohrnq252 FOREIGN KEY (id) REFERENCES public.room(id);


--
-- Name: code_bad_smell fklhj8477ili09rq8oxxpcgav5k; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_bad_smell
    ADD CONSTRAINT fklhj8477ili09rq8oxxpcgav5k FOREIGN KEY (hard_question_id) REFERENCES public.hard_question(id);


--
-- Name: room_member fklmp67erahqx7u5shbkc12p0lw; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.room_member
    ADD CONSTRAINT fklmp67erahqx7u5shbkc12p0lw FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: battle fkm93boh47b7m08u1lyqq1yat43; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.battle
    ADD CONSTRAINT fkm93boh47b7m08u1lyqq1yat43 FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: hard_question fkmiegfwsjykxuyx7qbuheus3ko; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hard_question
    ADD CONSTRAINT fkmiegfwsjykxuyx7qbuheus3ko FOREIGN KEY (id) REFERENCES public.question(id);


--
-- Name: easy_question fkmykbidyav8n2w06en46r63ktg; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.easy_question
    ADD CONSTRAINT fkmykbidyav8n2w06en46r63ktg FOREIGN KEY (id) REFERENCES public.question(id);


--
-- Name: pmderrors fkn73loleg3snffs2m99iikgxme; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pmderrors
    ADD CONSTRAINT fkn73loleg3snffs2m99iikgxme FOREIGN KEY (room_id) REFERENCES public.medium_room(id);


--
-- Name: answer fkol45e11qsdhrx656nhm0kfip3; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer
    ADD CONSTRAINT fkol45e11qsdhrx656nhm0kfip3 FOREIGN KEY (team_id) REFERENCES public.team(id);


--
-- Name: rooms_team fkppmw16pam2bot8t5ujbqus85d; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rooms_team
    ADD CONSTRAINT fkppmw16pam2bot8t5ujbqus85d FOREIGN KEY (room_id) REFERENCES public.room(id);


--
-- Name: score fkpqss47h2fevnmkh76r14055o0; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.score
    ADD CONSTRAINT fkpqss47h2fevnmkh76r14055o0 FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: code_bad_smell fkqp7rf8ehhj7bipjirdc7fuku0; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_bad_smell
    ADD CONSTRAINT fkqp7rf8ehhj7bipjirdc7fuku0 FOREIGN KEY (badsmell_id) REFERENCES public.bad_smell(id);


--
-- Name: battle fkqyseqpb75l3cfxknbem1axitv; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.battle
    ADD CONSTRAINT fkqyseqpb75l3cfxknbem1axitv FOREIGN KEY (team2_id) REFERENCES public.team(id);


--
-- Name: answer fksdj8jab9t00diflkysw22k7bv; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer
    ADD CONSTRAINT fksdj8jab9t00diflkysw22k7bv FOREIGN KEY (user_id) REFERENCES public.users(id);


--
-- Name: score fksy1akiym9mylj43mab7ti3q3e; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.score
    ADD CONSTRAINT fksy1akiym9mylj43mab7ti3q3e FOREIGN KEY (team_id) REFERENCES public.team(id);


--
-- PostgreSQL database dump complete
--

